[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Data Analysis with R (IDAR)",
    "section": "",
    "text": "Introduction\nThis book is a compilation of lesson notes for a 3-month online course offered by The GRAPH Courses. To access the lesson videos, exercise files, and online quizzes, please visit our website, thegraphcourses.org.\nThe GRAPH Courses is a project of the Global Research and Analyses for Public Health (GRAPH) Network, a non-profit organization dedicated to making code and data skills accessible through affordable live bootcamps and free self-paced courses."
  },
  {
    "objectID": "index.html#contributors",
    "href": "index.html#contributors",
    "title": "Introduction to Data Analysis with R (IDAR)",
    "section": "Contributors",
    "text": "Contributors\nWe are extremely grateful to the following individuals who have contributed to the development of these materials over several years:\nAmanda McKinley, Andree Valle Campos, Aziza Merzouki, Benedict Nguimbis, Bennour Hsin, Camille Beatrice Valera, Daniel Camara, Eduardo Araujo, Elton Mukonda, Guy Wafeu, Imad El Badisy, Imane Bensouda Korachi, Joy Vaz, Kene David Nwosu, Lameck Agasa, Laure Nguemo, Laure Vancauwenberghe, Matteo Franza, Michal Shrestha, Olivia Keiser, Sabina Rodriguez Velasquez, Sara Botero Mesa."
  },
  {
    "objectID": "index.html#partners-funders",
    "href": "index.html#partners-funders",
    "title": "Introduction to Data Analysis with R (IDAR)",
    "section": "Partners & Funders",
    "text": "Partners & Funders\n\nUniversity of Geneva\nUniversity of Oxford\nWorld Health Organization\nGlobal Fund\nErnst Goehner Foundation"
  },
  {
    "objectID": "foundations_ls01_setting_up.html#learning-objective",
    "href": "foundations_ls01_setting_up.html#learning-objective",
    "title": "1  Setting up R and RStudio",
    "section": "Learning objective",
    "text": "Learning objective\n\nYou can access R and RStudio, either through RStudio.cloud or by downloading and installing these software to your computer."
  },
  {
    "objectID": "foundations_ls01_setting_up.html#introduction",
    "href": "foundations_ls01_setting_up.html#introduction",
    "title": "1  Setting up R and RStudio",
    "section": "1.1 Introduction",
    "text": "1.1 Introduction\nTo start you off on your R journey, we’ll need to set you up with the required software, R and RStudio. R is the programming language that you’ll use write code, while RStudio is an integrated development environment (IDE) that makes working with R easier."
  },
  {
    "objectID": "foundations_ls01_setting_up.html#working-locally-vs.-on-the-cloud",
    "href": "foundations_ls01_setting_up.html#working-locally-vs.-on-the-cloud",
    "title": "1  Setting up R and RStudio",
    "section": "1.2 Working locally vs. on the cloud",
    "text": "1.2 Working locally vs. on the cloud\nThere are two main ways that you can access and work with R and RStudio: download them to your computer, or use a web server to access them on the cloud.\nUsing R and RStudio on the cloud is the less common option, but it may be the right choice if you are just getting started with programming, and you do not yet want to worry about installing software. You may also prefer the cloud option if your local computer is old, slow, or otherwise unfit for running R.\nBelow, we go through the setup process for RStudio Cloud, Rstudio on Windows and RStudio on macOS separately. Jump to the section that is relevant for you!\n\n\n\n\n\n\nWatch Out\n\n\n\nRStudio cloud will only give you 25 free project hours per month. After that, you will need to upgrade to a paid plan. If you think you’ll need more than 25 hours per month, you may want to avoid this option."
  },
  {
    "objectID": "foundations_ls01_setting_up.html#rstudio-on-the-cloud",
    "href": "foundations_ls01_setting_up.html#rstudio-on-the-cloud",
    "title": "1  Setting up R and RStudio",
    "section": "1.3 RStudio on the cloud",
    "text": "1.3 RStudio on the cloud\nIf you’ll be working on the cloud, follow the steps below:\n\nGo to the website rstudio.cloud and follow the instructions to sign up for a free account. (We recommend signing up with Google if you have a Google account, so you don’t need to remember any new passwords).\nOnce you’re done, click on the “New Project” icon at the top right, and select “New RStudio Project”.\n\n\nYou should see a screen like this:\n\nThis is RStudio, your new home for a long time to come!\nAt the top of the screen, rename the project from “Untitled Project” to something like “r_intro”.\n\nYou can start using R by typing code into the “console” pane on the left:\n\nTry using R as a calculator here; type 2 + 2 and press Enter.\nThat’s it; you’re ready to roll. Whenever you want to reopen RStudio, navigate to rstudio.cloud,\nProceed to the “wrapping up” section of the lesson."
  },
  {
    "objectID": "foundations_ls01_setting_up.html#set-up-on-windows",
    "href": "foundations_ls01_setting_up.html#set-up-on-windows",
    "title": "1  Setting up R and RStudio",
    "section": "1.4 Set up on Windows",
    "text": "1.4 Set up on Windows\n\n1.4.1 Download and install R\nIf you’re working on Windows, follow the steps below to download and install R:\n\nGo to cran.rstudio.com to access the R installation page. Then click the download link for Windows:\n\nChoose the “base” sub-directory.\n\nThen click on the download link at the top of the page to download the latest version of R:\n\nNote that the screenshot above may not show the latest version.\nAfter the download is finished, click on the downloaded file, then follow the instructions on the installation pop-up window. During installation, you should not have to change any of the defaults; just keep clicking “Next” until the installation is done.\nWell done! You should now have R on your computer. But you likely won’t ever need to interact with R directly. Instead you’ll use the RStudio IDE to work with R. Follow the instructions in the next section to get RStudio.\n\n\n\n1.4.2 Download, install & run RStudio\nTo download RStudio, go to rstudio.com/products/rstudio/download/#download and download the Windows version.\n\nAfter the download is finished, click on the downloaded file and follow the installation instructions.\nOnce installed, RStudio can be opened like any application on your computer: press the Windows key to bring up the Start menu, and search for “rstudio”. Click to to open the app:\n\nYou should see a window like this:\n\nThis is RStudio, your new home for a long time to come!\nYou can start using R by typing code into the “console” pane on the left:\n\nTry using R as a calculator here; type 2 + 2 and press Enter.\nThat’s it; you’re ready to roll. Proceed to the “wrapping up” section of the lesson."
  },
  {
    "objectID": "foundations_ls01_setting_up.html#set-up-on-macos",
    "href": "foundations_ls01_setting_up.html#set-up-on-macos",
    "title": "1  Setting up R and RStudio",
    "section": "1.5 Set up on macOS",
    "text": "1.5 Set up on macOS\n\n1.5.1 Download and install R\nIf you’re working on macOS, follow the steps below to download and install R:\n\nGo to cran.rstudio.com to access the R installation page. Then click the link for macOS:\n\nDownload and install the relevant R version for your Mac. For most people, the first option under “Latest release” will be the one to get.\n\nAfter the download is finished, click on the downloaded file, then follow the instructions on the installation pop-up window.\n\nWell done! You should now have R on your computer. But you likely won’t ever need to interact with R directly. Instead you’ll use the RStudio IDE to work with R. Follow the instructions in the next section to get RStudio.\n\n\n1.5.2 Download, install & run RStudio\nTo download RStudio, go to rstudio.com/products/rstudio/download/#download and download the version for macOS.\n\nAfter the download is finished, click on the downloaded file and follow the installation instructions.\nOnce installed, RStudio can be opened like any application on your computer: Press Command + Space to open Spotlight, then search for “rstudio”. Click to open the app.\n\nYou should see a window like this:\n\nThis is RStudio, your new home for a long time to come!\nYou can start using R by typing code into the “console” pane on the left:\n\nTry using R as a calculator here; type 2 + 2 and press Enter."
  },
  {
    "objectID": "foundations_ls01_setting_up.html#wrap-up",
    "href": "foundations_ls01_setting_up.html#wrap-up",
    "title": "1  Setting up R and RStudio",
    "section": "1.6 Wrap up",
    "text": "1.6 Wrap up\nYou should now have access to R and RStudio, so you’re all set to begin the journey of learning to use these immensely powerful tools. See you in the next session!"
  },
  {
    "objectID": "foundations_ls01_setting_up.html#references",
    "href": "foundations_ls01_setting_up.html#references",
    "title": "1  Setting up R and RStudio",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nNordmann, Emily, and Heather Cleland-Woods. Chapter 2 Programming Basics | Data Skills. psyteachr.github.io, https://psyteachr.github.io/data-skills-v1/programming-basics.html Accessed 23 Feb. 2022.\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  },
  {
    "objectID": "foundations_ls02_using_rstudio.html#learning-objectives",
    "href": "foundations_ls02_using_rstudio.html#learning-objectives",
    "title": "2  Using RStudio",
    "section": "2.1 Learning objectives",
    "text": "2.1 Learning objectives\n\nYou can identify and use the following tabs in RStudio: Source, Console, Environment, History, Files, Plots, Packages, Help and Viewer.\nYou can modify RStudio’s interface options to suit your needs."
  },
  {
    "objectID": "foundations_ls02_using_rstudio.html#introduction",
    "href": "foundations_ls02_using_rstudio.html#introduction",
    "title": "2  Using RStudio",
    "section": "2.2 Introduction",
    "text": "2.2 Introduction\nNow that you have access to R & RStudio, let’s go on a quick tour of the RStudio interface, your digital home for a long time to come.\nWe will cover a lot of territory quickly. Do not panic. You are not expected to remember it all this. Rather, you will see these topics again and again throughout the course, and you will naturally assimilate them that way.\nYou can also refer back to this lesson as you progress.\nThe goal here is simply to make you aware of the tools at your disposal within RStudio.\n\nTo get started, you need to open the RStudio application:\n\nIf you are working with RStudio Cloud, go to rstudio.cloud, log in, then click on the “r_intro” project that you created in the last lesson. (If you do not see this, simply create a new R project using the “New Project” icon at the top right).\nIf you are working on your local computer, go to your applications folder and double click on the RStudio icon. Or you search for this application from your Start Menu (Windows), or through Spotlight (Mac)."
  },
  {
    "objectID": "foundations_ls02_using_rstudio.html#the-rstudio-panes",
    "href": "foundations_ls02_using_rstudio.html#the-rstudio-panes",
    "title": "2  Using RStudio",
    "section": "2.3 The RStudio panes",
    "text": "2.3 The RStudio panes\nBy default, RStudio is arranged into four window panes.\nIf you only see three panes, open a new script with File &gt; New File &gt; R Script . This should reveal one more pane.\n\nBefore we go any further, we will rearrange these panes to improve the usability of the interface.\nTo do this, in the RStudio menu at the top of the screen, select Tools &gt; Global Options to bring up RStudio’s options. Then under Pane Layout, adjust the pane arrangement. The arrangement we recommend is shown below.\n\nAt the top left pane is the Source tab, and at the top right pane, you should have the Console tab.\nThen at the bottom left pane, no tab options should checked—this section should be left empty, with the drop-down saying just “TabSet”.\nFinally, at the bottom right pane, you should check the following tabs: Environment, History, Files, Plots, Packages, Help and Viewer.\n\nGreat, now you should have an RStudio window that looks something like this:\n\n\nThe top-left pane is where you will do most of the coding. Make this larger by clicking on its maximize icon:\n\n\nNote that you can drag the bar that separates the window panes to resize them.\n\n\nNow let’s look at each of the RStudio tabs one by one. Below is a summary image of what we will discuss:\n\n\n2.3.1 Source/Editor\n\nThe source or editor is where your R “scripts” go. A script is a text document where you write and save code.\nBecause this is where you will do most of your coding, it is important that you have a lot of visual space. That is why we rearranged the RStudio pane layout above—to give the Editor more space.\nNow let’s see how to use this Editor.\n\nFirst, open a new script under the File menu if one is not yet open: File &gt; New File &gt; R Script. In the script, type the following:\n\nprint(\"excited for R!\")\n\nTo run code, place your cursor anywhere in the code, then hit Command + Enter on macOS, or Control + Enter on Windows.\nThis should send the code to the Console and run it.\n\nYou can also run multiple lines at once. To try this, add a second line to your script, so that it now reads:\n\nprint(\"excited for R!\")\nprint(\"and RStudio!\")\n\nNow drag your cursor to highlight both lines and press Command/Control + Enter.\nTo run the entire script, you can use Command/Control + A to select all code, then press Command/Control + Enter. Try this now. Deselect your code, then try to the shortcut to select all.\n\n\n\n\n\n\nSide Note\n\n\n\nThere is also a ‘Run’ button at the top right of the source panel (  ), with which you can run code (either the current line, or all highlighted code). But you should try to use the keyboard shortcut instead.\n\n\n\nTo open the script in a new window, click on the third icon in the toolbar directly above the script.\n\nTo put the window back, click on the same button on the now-external window.\n\nNext, save the script. Hit Command/Control + S to bring up the Save dialog box. Give it a file name like “rstudio_intro”.\n\nIf you are working with RStudio cloud, the file will be saved in your project folder.\nIf you are working on your local computer, save the file in an easy-to-locate part of your computer, perhaps your desktop. (Later on we will think about the “proper” way to organize and store scripts).\n\n\nYou can view data frames (which are like spreadsheets in R) in the same pane. To observe this, type and run the code below on a new line in your script:\n\nView(women)\n\nNotice the uppercase “V” in View().\n\nwomen is the name of a dataset that comes loaded with R. It gives the average heights and weights for American women aged 30–39.\nYou can click on the “x” icon to the right of the “women” tab to close this data viewer.\n\n\n\n2.3.2 Console\nThe console, at the bottom left, is where code is executed. You can type code directly here, but it will not be saved.\nType a random piece of code (maybe a calculation like 3 + 3) and press ‘Enter’.\n\nIf you place your cursor on the last line of the console, and you press the up arrow, you can go back to the last code that was run. Keep pressing it to cycle to the previous lines.\nTo run any of these previous lines, press Enter.\n\n\n2.3.3 Environment\n\nAt the top right of the RStudio Window, you should see the Environment tab.\nThe Environment tab shows datasets and other objects that are loaded into R’s working memory, or “workspace”.\nTo explore this tab, let’s import a dataset into your environment from the web. Type the code below into your script and run it:\n\nebola_data &lt;- read.csv(\"https://tinyurl.com/ebola-data-sample\")\n\n\n\n\n\n\n\nSide Note\n\n\n\nYou don’t need to understand exactly what the code above is doing for now. We just want to quickly show you the basic features of the Environment pane; we’ll look at data importing in detail later.\nAlso, if you do not have active internet access, the code above will not run. You can skip this section and move to the “History” tab.\n\n\nYou have now imported the dataset and stored it in an object named ebola_data. (You could have named the object anything you want.)\nNow that the dataset is stored by R, you should be able to see it in the Environment pane. If you click on the blue drop-down icon beside the object’s name in the Environment tab to reveal a summary.\n\nTry clicking directly on the ebola_data dataset from the Environment tab. This opens it in a ‘View’ tab.\n\nYou can remove an object from the workspace with the rm() function. Type and run the following in a new line on your R script.\n\nrm(ebola_data)\n\nNotice that the ebola_data object no longer shows up in your environment after having run that code.\nThe broom icon, at the top of the Environment pane can also be used to clear your workspace.\n\nTo practice using it, try re-running the line above that imports the Ebola dataset, then clear the object using the broom icon.\n\n\n2.3.4 History\nNext, the History tab shows previous commands you have run.\n\nYou can click a line to highlight it, then send it to the console or to your script with the “To Console” and “To Source” icons at the top of this tab.\nTo select multiple lines, use the “Shift-click” method: click the first item you want to select, then hold down the “Shift” key and click the last item you want to select.\nFinally, notice that there is a search bar at the top right of the History pane where you can search for past commands that you have run.\n\n\n2.3.5 Files\nNext, the Files tab. This shows the files and folders in the folder you are working in.\n\nThe tab allows you to interact with your computer’s file system.\nTry playing with some of the buttons here, to see what they do. You should try at least the following:\n\nMake a new folder\nDelete that folder\nMake a new R Script\nRename that script\n\n\n\n2.3.6 Plots\nNext, the Plots tab. This is where figures that are generated by R will show up. Try creating a simple plot with the following code:\n\nplot(women)\n\n\nThat code creates a plot of the two variables in the women dataset. You should see this figure in the Plots tab.\nNow, test out the buttons at the top of this tab to explore what they do. In particular, try to export a plot to your computer.\n\n\n2.3.7 Packages\nNext, let’s look at the Packages tab.\n\nPackages are collections of R code that extend the functionality of R. We will discuss packages in detail in a future lesson.\nFor now, it is important to know that to use a package, you need to install then load it. Packages need to be installed only once, but must be loaded in each new R session.\nAll the package names you see (in blue font) are packages that are installed on your system. And packages with a checkmark are packages which are loaded in the current session.\nYou can install a package with the Install button of the Packages tab.\n\nBut it is better to install and load packages with R code, rather than the Install button. Let’s try this. Type and run the code below to install the {highcharter} package.\n\ninstall.packages(\"highcharter\")\nlibrary(highcharter)\n\nThe first line installs the package. The second line loads the package from your package library.\nBecause you only need to install a package once, you can now remove the installation line from your script.\n\nNow that the {highcharter} package has been installed and loaded, you can use the functions that come in the package. To try this, type and run the code below:\n\nhighcharter::hchart(women$weight)\n\nRegistered S3 method overwritten by 'quantmod':\n  method            from\n  as.zoo.data.frame zoo \n\n\n\n\n\n\n\nThis code uses the hchart() function from the {highcharter} package to plot an interactive histogram showing the distribution of weights in the women dataset.\n(Of course, you may not yet know what a function is. We’ll get to this soon.)\n\n\n2.3.8 Viewer\nNotice that the histogram above shows up in a Viewer tab. This tab allows you to preview HTML files and interactive objects.\n\n\n2.3.9 Help\nLastly, the Help tab shows the documentation for different R objects. Try typing out and running each line below to see what this documentation looks like.\n\n?hchart\n?women\n?read.csv\n\n\nHelp files are not always very easy to understand for beginners, but with time they will become more useful."
  },
  {
    "objectID": "foundations_ls02_using_rstudio.html#rstudio-options",
    "href": "foundations_ls02_using_rstudio.html#rstudio-options",
    "title": "2  Using RStudio",
    "section": "2.4 RStudio options",
    "text": "2.4 RStudio options\nRStudio has a number of useful options for changing it’s look and functionality. Let’s try these. You may not understand all the changes made for now. That’s fine.\nIn the RStudio menu at the top of the screen, select Tools &gt; Global Options to bring up RStudio’s options.\n\nNow, under Appearance, choose your ideal theme. (We like the “Crimson Editor” and “Tomorrow Night” themes.)\n\nUnder Code &gt; Display, check “Highlight R function calls”. What this does is give your R functions a unique color, improving readability. You will understand this later.\nAlso under Code &gt; Display, check “Rainbow parentheses”. What this does is make your “nested parentheses” easier to read by giving each pair a unique color.\n\n\n\nFinally under General &gt; Basic, uncheck the box that says “Restore .RData into workspace at startup”. You don’t want to restore any data to your workspace (or environment) when you start RStudio. Starting with a clean workspace each time is less likely to lead to errors.\nThis also means that you never want to “save your workspace to .RData on exit”, so set this to Never."
  },
  {
    "objectID": "foundations_ls02_using_rstudio.html#command-palette",
    "href": "foundations_ls02_using_rstudio.html#command-palette",
    "title": "2  Using RStudio",
    "section": "2.5 Command palette",
    "text": "2.5 Command palette\nThe Rstudio command palette gives instant, searchable access to many of the RStudio menu options and settings that we have seen so far.\nThe palette can be invoked with the keyboard shortcut Ctrl + Shift + P (Cmd + Shift + P on macOS).\nIt’s also available on the Tools menu (Tools -&gt; Show Command Palette).\n\nTry using it to:\n\nCreate a new script (Search “new script” and click on the relevant option)\nRename a script (Search “rename” and click on the relevant option)"
  },
  {
    "objectID": "foundations_ls02_using_rstudio.html#wrapping-up",
    "href": "foundations_ls02_using_rstudio.html#wrapping-up",
    "title": "2  Using RStudio",
    "section": "2.6 Wrapping up",
    "text": "2.6 Wrapping up\nCongratulations! You are now a new citizen of RStudio.\nOf course, you have only scratched the surface of RStudio functionality. As you advance in your R journey, you will discover new features, and you will hopefully grow to love the wonderful integrated development environment (IDE) that is RStudio. One good place to start is the official RStudio IDE cheatsheet.\nBelow is one section of that sheet:\n\nSee you in the next lesson!"
  },
  {
    "objectID": "foundations_ls02_using_rstudio.html#further-resources",
    "href": "foundations_ls02_using_rstudio.html#further-resources",
    "title": "2  Using RStudio",
    "section": "2.7 Further resources",
    "text": "2.7 Further resources\n\n23 RStudio Tips, Tricks, and Shortcuts"
  },
  {
    "objectID": "foundations_ls02_using_rstudio.html#references",
    "href": "foundations_ls02_using_rstudio.html#references",
    "title": "2  Using RStudio",
    "section": "2.8 References",
    "text": "2.8 References\nSome material in this lesson was adapted from the following sources:\n\n“Rstudio Cheatsheets.” RStudio, https://www.rstudio.com/resources/cheatsheets/.\n“Chapter 1 Getting Started: Data Skills for Reproducible Research.” Chapter 1 Getting Started | Data Skills for Reproducible Research, https://psyteachr.github.io/reprores-v2/intro.html.\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  },
  {
    "objectID": "foundations_ls03_coding_basics.html#learning-objectives",
    "href": "foundations_ls03_coding_basics.html#learning-objectives",
    "title": "3  Coding basics",
    "section": "Learning objectives",
    "text": "Learning objectives\n\nYou can write comments in R.\nYou can create section headers in RStudio.\nYou know how to use R as a calculator.\nYou can create, overwrite and manipulate R objects.\nYou understand the basic rules for naming R objects.\nYou understand the syntax for calling R functions.\nYou know how to nest multiple functions.\nYou can use install and load add-on R packages and call functions from these packages."
  },
  {
    "objectID": "foundations_ls03_coding_basics.html#introduction",
    "href": "foundations_ls03_coding_basics.html#introduction",
    "title": "3  Coding basics",
    "section": "3.1 Introduction",
    "text": "3.1 Introduction\nIn the last lesson, you learned how to use RStudio, the wonderful integrated development environment (IDE) that makes working with R much easier. In this lesson, you will learn the basics of using R itself.\nTo get started, open RStudio, and open a new script with File &gt; New File &gt; R Script on the RStudio menu.\n\nNext, save the script with File &gt; Save on the RStudio menu or by using the shortcut Command/Control + S . This should bring up the Save File dialog box. Save the file with a name like “coding_basics”.\nYou should now type all the code from this lesson into that script."
  },
  {
    "objectID": "foundations_ls03_coding_basics.html#comments",
    "href": "foundations_ls03_coding_basics.html#comments",
    "title": "3  Coding basics",
    "section": "3.2 Comments",
    "text": "3.2 Comments\nThere are two main types of text in an R script: commands and comments. A command is a line or lines of R code that instructs R to do something (e.g. 2 + 2)\nA comment is text that is ignored by the computer.\nAnything that follows a # symbol (pronounced “hash” or “pound”) on a given line is a comment. Try typing out and running the code below to see this:\n\n## A comment\n2 + 2 # Another comment\n## 2 + 2\n\nSince they are ignored by the computer, comments are meant for humans. They help you and others keep track of what your code is doing. Use them often! Like your mother always says, “too much everything is bad, except for R comments”.\n\n\n\n\n\n\nPractice\n\n\n\nQuestion 1\nTrue or False: both code chunks below are valid ways to comment code:?\n\n## add two numbers\n2 + 2\n\n\n2 + 2 # add two numbers\n\nNote: All question answers can be found at the end of the lesson.\n\n\nA fantastic use of comments is to separate your scripts into sections. If you put four dashes after a comment, RStudio will create a new section in your code:\n\n## New section ----\n\nThis has two nice benefits. Firstly, you can click on the little arrow beside the section header to fold, or collapse, that section of code:\n\nSecond, you can click on the “Outline” icon at the top right of the Editor to view and navigate through all the contents in your script:"
  },
  {
    "objectID": "foundations_ls03_coding_basics.html#r-s-a-calculator",
    "href": "foundations_ls03_coding_basics.html#r-s-a-calculator",
    "title": "3  Coding basics",
    "section": "3.3 R s a calculator",
    "text": "3.3 R s a calculator\nR works as a calculator, and obeys the correct order of operations. Type and run the following expressions and observe their output:\n\n2 + 2\n\n[1] 4\n\n2 - 2\n\n[1] 0\n\n2 * 2 # two times two \n\n[1] 4\n\n2 / 2 # two divided by two\n\n[1] 1\n\n2 ^ 2 # two raised to the power of two\n\n[1] 4\n\n2 + 2 * 2   # this is evaluated following the order of operations\n\n[1] 6\n\nsqrt(100)   # square root\n\n[1] 10\n\n\nThe square root command shown on the last line is a good example of an R function, where 100 is the argument to the function. You will see more functions soon.\n\n\n\n\n\n\nReminder\n\n\n\nWe hope you remember the shortcut to run code!\nTo run a single line of code, place your cursor anywhere on that line, then hit Command + Enter on macOS, or Control + Enter on Windows.\nTo run multiple lines, drag your cursor to highlight the relevant lines then again press Command/Control + Enter.\n\n\n\n\n\n\n\n\nPractice\n\n\n\nQuestion 2\nIn the following expression, which sign is evaluated first by R, the minus or the division?\n\n2 - 2 / 2\n\n[1] 1"
  },
  {
    "objectID": "foundations_ls03_coding_basics.html#formatting-code",
    "href": "foundations_ls03_coding_basics.html#formatting-code",
    "title": "3  Coding basics",
    "section": "3.4 Formatting code",
    "text": "3.4 Formatting code\nR does not care how you choose to space out your code.\nFor the math operations we did above, all the following would be valid code:\n\n2+2\n\n[1] 4\n\n2 + 2\n\n[1] 4\n\n2                +                   2\n\n[1] 4\n\n\nSimilarly, for the sqrt() function used above, any of these would be valid:\n\nsqrt(100)\n\n[1] 10\n\nsqrt(    100     )\n\n[1] 10\n\n## you can even space the command out over multiple lines\nsqrt(  \n  100\n    )\n\n[1] 10\n\n\nBut of course, you should try to space out your code in sensible ways. What exactly is “sensible”? Well, it may be hard for you to know at the moment. Over time, as you read other people’s code, you will learn that there are certain R conventions for code spacing and formatting.\nIn the meantime, you can ask RStudio to help format your code for you. To do this, highlight any section of code you want to reformat, and, on the RStudio menu, go to Code &gt; Reformat Code, or use the shortcut Shift + Command/Control + A.\n\n\n\n\n\n\nWatch Out\n\n\n\nStuck on the + sign\nIf you run an incomplete line of code, R will print a + sign to indicate that it is waiting for you to finish the code.\nFor example, if you run the following code:\n\nsqrt(100\n\nyou will not get the output you expect (10). Rather the console will sqrt( and a + sign:\n\nR is waiting for you complete the closing parenthesis. You can complete the code and get rid of the + by just entering the missing parenthesis:\n\n)\n\n\nAlternatively, press the escape key, ESC while your cursor is in the console to start over."
  },
  {
    "objectID": "foundations_ls03_coding_basics.html#objects-in-r",
    "href": "foundations_ls03_coding_basics.html#objects-in-r",
    "title": "3  Coding basics",
    "section": "3.5 Objects in R",
    "text": "3.5 Objects in R\n\n3.5.1 Create an object\nWhen you run code as we have been doing above, the result of the command (or its value) is simply displayed in the console—it is not stored anywhere.\n\n2 + 2 # R prints this result, 4, but does not store it \n\n[1] 4\n\n\nTo store a value for future use, assign it to an object with the assignment operator, &lt;- :\n\nmy_obj &lt;- 2 + 2 # assign the result of `2 + 2 ` to the object called `my_obj`\nmy_obj # print my_obj\n\n[1] 4\n\n\nThe assignment operator, &lt;- , is made of the ‘less than’ sign, &lt; , and a minus, -. You will use it thousands of times over your R lifetime, so please don’t type it manually! Instead, use RStudio’s shortcut, alt + - (alt AND minus) on Windows or option + - (option AND minus) on macOS.\n\n\n\n\n\n\nSide Note\n\n\n\nAlso note that you can use the equals sign, =, for assignment.\n\nmy_obj = 2 + 2 \n\nBut this is not commonly used by the R community (mostly for historical reasons), so we discourage it too. Follow the convention and use &lt;-.\n\n\nNow that you’ve created the object my_obj, R knows all about it and will keep track of it during this R session. You can view any created objects in the Environment tab of RStudio.\n\n\n\n3.5.2 What is an object?\nSo what exactly is an object? Think of it as a named bucket that can contain anything. When you run the code below:\n\nmy_obj &lt;- 20\n\nyou are telling R, “put the number 20 inside a bucket named ‘my_obj’”.\n\nOnce the code is run, we would say, in R terms, that “the value of object called my_obj is 20”.\n\nAnd if you run this code:\n\nfirst_name &lt;- \"Joanna\"\n\nyou are instructing R to “put the value ‘Joanna’ inside the bucket called ‘first_name’”.\n\nOnce the code is run, we would say, in R terms, that “the value of the first_name object is Joanna”.\n\nNote that R evaluates the code before putting it inside the bucket.\nSo, before when we ran this code,\n\nmy_obj &lt;- 2 + 2\n\nR firsts does the calculation of 2 + 2, then stores the result, 4, inside the object.\n\n\n\n\n\n\n\nPractice\n\n\n\nQuestion 3\nConsider the code chunk below:\n\nresult &lt;-  2 + 2 + 2\n\nWhat is the value of the result object created?\nA. 2 + 2 + 2\nB. numeric\nC. 6\n\n\n\n\n3.5.3 Datasets are objects too\nSo far, you have been working with very simple objects. You may be thinking “Where are the spreadsheets and datasets? Why are we writing my_obj &lt;- 2 + 2? Is this a primary school maths class?!”\nBe patient.\nWe want you to get familiar with the concept of an R object because once you start dealing with real datasets, these will also be stored as R objects.\nLet’s see a preview of this now. Type out the code below to download a dataset on Ebola cases that we stored on Google Drive and put it in the object ebola_sierra_leone_data.\n\nebola_sierra_leone_data &lt;- read.csv(\"https://tinyurl.com/ebola-data-sample\")\nebola_sierra_leone_data # print ebola_data\n\n   id age sex    status date_of_onset date_of_sample district\n1 167  55   M confirmed    2014-06-15     2014-06-21   Kenema\n2 129  41   M confirmed    2014-06-13     2014-06-18 Kailahun\n3 270  12   F confirmed    2014-06-28     2014-07-03 Kailahun\n4 187  NA   F confirmed    2014-06-19     2014-06-24 Kailahun\n5  85  20   M confirmed    2014-06-08     2014-06-24 Kailahun\n\n\nThis data contains a sample of patient information from the 2014-2016 Ebola outbreak in Sierra Leone.\n\nBecause you can store datasets as objects, its very easy to work with multiple datasets at the same time.\nBelow, we import and view another dataset from the web:\n\ndiabetes_china &lt;- read.csv(\"https://tinyurl.com/diabetes-china\")\n\nBecause the dataset above is quite large, it may be helpful to look at it in the data viewer:\n\nView(diabetes_china)\n\nNotice that both datasets now appear in your Environment tab.\n\n\n\n\n\n\nSide Note\n\n\n\nRather than reading data from an internet drive as we did above, it is more likely that you will have the data on your computer, and you will want to read it into R from your there. We will cover this in a future lesson.\nLater in the course, we will also show you how to store and read data from a web service like Google Drive, which is nice for easy portability.\n\n\n\n\n3.5.4 Rename an object\nYou sometimes want to rename an object. It is not possible to do this directly.\nTo rename an object, you make a copy of the object with a new name, and delete the original.\nFor example, maybe we decide that the name of the ebola_sierra_leone_data object is too long. To change it to the shorter “ebola_data” run:\n\nebola_data &lt;- ebola_sierra_leone_data\n\nThis has copied the contents from the ebola_sierra_leone_data bucket to a new ebola_data bucket.\nYou can now get rid of the old ebola_sierra_leone_data bucket with the rm() function, which stands for “remove”:\n\nrm(ebola_sierra_leone_data)\n\n\n\n3.5.5 Overwrite an object\nOverwriting an object is like changing the contents of a bucket.\nFor example, previously we ran this code to store the value “Joanna” inside the first_name object:\n\nfirst_name &lt;- \"Joanna\"\n\nTo change this to a different, simply re-run the line with a different value:\n\nfirst_name &lt;- \"Luigi\"\n\nYou can take a look at the Environment tab to observe the change.\n\n\n3.5.6 Working with objects\nMost of your time in R will be spent manipulating R objects. Let’s see some quick examples.\nYou can run simple commands on objects. For example, below we store the value 100 in an object and then take the square root of the object:\n\nmy_number &lt;- 100\nsqrt(my_number)\n\n[1] 10\n\n\nR “sees” my_number as the number 100, and so is able to evaluate it’s square root.\n\nYou can also combine existing objects to create new objects. For example, type out the code below to add my_number to itself, and store the result in a new object called my_sum:\n\nmy_sum &lt;- my_number + my_number\n\nWhat should be the value of my_sum? First take a guess, then check it.\n\n\n\n\n\n\nSide Note\n\n\n\nTo check the value of an object, such as my_sum, you can type and run just the code my_sum in the Console or the Editor. Alternatively, you can simply highlight the value my_sum in the existing code and press Command/Control + Enter.\n\n\n\nBut of course, most of your analysis will involve working with data objects, such as the ebola_data object we created previously.\nLet’s see a very simple example of how to interact with a data object; we will tackle it properly in the next lesson.\nTo get a table of the different sex distribution of patients in the ebola_data object, we can run the following:\n\ntable(ebola_data$sex)\n\n\n  F   M \n124  76 \n\n\nThe dollar sign symbol, $, above allowed us subset to a specific column.\n\n\n\n\n\n\nPractice\n\n\n\nQuestion 4\n\nConsider the code below. What is the value of the answer object?\n\n\neight &lt;- 9\nanswer &lt;- eight - 8\n\n\nUse table() to make a table with the distribution of patients across districts in the ebola_data object.\n\n\n\n\n\n3.5.7 Some errors with objects\n\nfirst_name &lt;- \"Luigi\"\nlast_name &lt;- \"Fenway\"\n\n\nfull_name &lt;- first_name + last_name\n\nError in first_name + last_name : non-numeric argument to binary operator\nThe error message tells you that these objects are not numbers and therefore cannot be added with +. This is a fairly common error type, caused by trying to do inappropriate things to your objects. Be careful about this.\nIn this particular case, we can use the function paste() to put these two objects together:\n\nfull_name &lt;- paste(first_name, last_name)\nfull_name\n\n[1] \"Luigi Fenway\"\n\n\n\nAnother error you’ll get a lot is Error: object 'XXX' not found. For example:\n\nmy_number &lt;- 48 # define `my_obj`\nMy_number + 2 # attempt to add 2 to `my_obj`\n\nError: object 'My_number' not found\nHere, R returns an error message because we haven’t created (or defined) the object My_obj yet. (Recall that R is case-sensitive.)\n\nWhen you first start learning R, dealing with errors can be frustrating. They’re often difficult to understand (e.g. what exactly does “non-numeric argument to binary operator” mean?).\nTry Googling any error messages you get and browsing through the first few results. This will lead you to forums (e.g. stackoverflow.com) where other R learners have complained about the same error. Here you may find explanations of, and solutions to, your problems.\n\n\n\n\n\n\nPractice\n\n\n\nQuestion 5\n\nThe code below returns an error. Why?\n\n\nmy_first_name &lt;- \"Kene\"\nmy_last_name &lt;- \"Nwosu\"\nmy_first_name + my_last_name\n\n\nThe code below returns an error. Why? (Look carefully)\n\n\nmy_1st_name &lt;- \"Kene\"\nmy_last_name &lt;- \"Nwosu\"\n\npaste(my_Ist_name, my_last_name)\n\n\n\n\n\n3.5.8 Naming objects\n\nThere are only two hard things in Computer Science: cache invalidation and naming things.\n— Phil Karlton.\n\nBecause much of your work in R involves interacting with objects you have created, picking intelligent names for these objects is important.\nNaming objects is difficult because names should be both short (so that you can type them quickly) and informative (so that you can easily remember what is inside the object), and these two goals are often in conflict.\nSo names that are too long, like the one below, are bad because they take forever to type.\n\nsample_of_the_ebola_outbreak_dataset_from_sierra_leone_in_2014\n\nAnd a name like data is bad because it is not informative; the name does not give a good idea of what the object is.\nAs you write more R code, you will learn how to write short and informative names.\n\nFor names with multiple words, there are a few conventions for how to separate the words:\n\nsnake_case &lt;- \"Snake case uses underscores\"\nperiod.case &lt;- \"Period case uses periods\"\ncamelCase &lt;- \"Camel case capitalizes new words (but not the first word)\"\n\nWe recommend snake_case, which uses all lower-case words, and separates words with _.\n\nNote too that there are some limitations on objects’ names:\n\nnames must start with a letter. So 2014_data is not a valid name (because it starts with a number).\nnames can only contain letters, numbers, periods (.) and underscores (_). So ebola-data or ebola~data or ebola data with a space are not valid names.\n\nIf you really want to use these characters in your object names, you can enclose the names in backticks:\n`ebola-data`\n`ebola~data`\n`ebola data`\nAll of the above are valid R object names. For example, type and run the following code:\n\n`ebola~data` &lt;- ebola_data\n`ebola~data`\n\nBut in general you should avoid using backticks to rescue bad object names. Just write proper names.\n\n\n\n\n\n\nPractice\n\n\n\nQuestion 6\nIn the code chunk below, we are attempting to take the top 20 rows of the ebola_data table. All but one of these lines has an error. Which line will run properly?\n\n20_top_rows &lt;- head(ebola_data, 20)\ntwenty-top-rows &lt;- head(ebola_data, 20)\ntop_20_rows &lt;- head(ebola_data, 20)"
  },
  {
    "objectID": "foundations_ls03_coding_basics.html#functions",
    "href": "foundations_ls03_coding_basics.html#functions",
    "title": "3  Coding basics",
    "section": "3.6 Functions",
    "text": "3.6 Functions\nMuch of your work in R will involve calling functions.\nYou can think of each function as a machine that takes in some input (or arguments) and returns some output.\n\nSo far you have already seen many functions, including, sqrt(), paste() and plot(). Run the lines below to refresh your memory:\n\nsqrt(100)\npaste(\"I am number\", 2 + 2)\nplot(women)\n\n\n3.6.1 Basic function syntax\nThe standard way to call a function is to provide a value for each argument:\n\nfunction_name(argument1 = \"value\", argument2 = \"value\")\n\nLet’s demonstrate this with the head() function, which returns the first few elements of an object.\nTo return the first three rows of the Ebola dataset, you run:\n\nhead(x = ebola_data, n = 3)\n\n   id age sex    status date_of_onset date_of_sample district\n1 167  55   M confirmed    2014-06-15     2014-06-21   Kenema\n2 129  41   M confirmed    2014-06-13     2014-06-18 Kailahun\n3 270  12   F confirmed    2014-06-28     2014-07-03 Kailahun\n\n\nIn the code above, head() takes in two arguments:\n\nx , the object of interest, and\nn, the number of elements to return.\n\nWe can also swap the order of the arguments:\n\nhead(n = 3, x = ebola_data)\n\n   id age sex    status date_of_onset date_of_sample district\n1 167  55   M confirmed    2014-06-15     2014-06-21   Kenema\n2 129  41   M confirmed    2014-06-13     2014-06-18 Kailahun\n3 270  12   F confirmed    2014-06-28     2014-07-03 Kailahun\n\n\n\nIf you put the argument values in the right order, you can skip typing their names. So the following two lines of code are equivalent and both run:\n\nhead(x = ebola_data, n = 3)\n\n   id age sex    status date_of_onset date_of_sample district\n1 167  55   M confirmed    2014-06-15     2014-06-21   Kenema\n2 129  41   M confirmed    2014-06-13     2014-06-18 Kailahun\n3 270  12   F confirmed    2014-06-28     2014-07-03 Kailahun\n\nhead(ebola_data, 3)\n\n   id age sex    status date_of_onset date_of_sample district\n1 167  55   M confirmed    2014-06-15     2014-06-21   Kenema\n2 129  41   M confirmed    2014-06-13     2014-06-18 Kailahun\n3 270  12   F confirmed    2014-06-28     2014-07-03 Kailahun\n\n\nBut if the argument values are in the wrong order, you will get an error if you do not type the argument names. Below, the first line runs but the second does not run:\n\nhead(n = 3, x = ebola_data)\nhead(3, ebola_data)\n\n(To see the “correct order” for the arguments, take a look at the help file for the head() function)\n\nSome function arguments can be skipped altogether, because they have default values.\nFor example, with head(), the default value of n is 6, so running just head(ebola_data) will return the first 6 rows.\n\nhead(ebola_data)\n\n   id age sex    status date_of_onset date_of_sample district\n1 167  55   M confirmed    2014-06-15     2014-06-21   Kenema\n2 129  41   M confirmed    2014-06-13     2014-06-18 Kailahun\n3 270  12   F confirmed    2014-06-28     2014-07-03 Kailahun\n4 187  NA   F confirmed    2014-06-19     2014-06-24 Kailahun\n5  85  20   M confirmed    2014-06-08     2014-06-24 Kailahun\n6 277  30   F confirmed    2014-06-29     2014-07-01   Kenema\n\n\nTo see the arguments to a function, press the Tab key when your cursor is inside the function’s parentheses:\n\n\n\n\n\n\n\nPractice\n\n\n\nQuestion 7\nIn the code lines below, we are attempting to take the top 6 rows of the women dataset (which is built into R). Which line is invalid?\n\nhead(women)\nhead(women, 6)\nhead(x = women, 6)\nhead(x = women, n = 6)\nhead(6, women)\n\n(If you are not sure, just try typing and running each line. Remember that the goal here is for you to gain some practice.)\n\n\n\nLet’s spend some time playing with another function, the paste() function, which we already saw above, This function is a bit special because it can take in any number of input arguments.\nSo you could have two arguments:\n\npaste(\"Luigi\", \"Fenway\")\n\n[1] \"Luigi Fenway\"\n\n\nOr four arguments:\n\npaste(\"Luigi\", \"Fenway\", \"Luigi\", \"Fenway\")\n\n[1] \"Luigi Fenway Luigi Fenway\"\n\n\nAnd so on up to infinity.\nAnd as you might recall, we can also paste() named objects:\n\nfirst_name &lt;- \"Luigi\"\npaste(\"My name is\", first_name, \"and my last name is\", last_name)\n\n[1] \"My name is Luigi and my last name is Fenway\"\n\n\n\n\n\n\n\n\nPro Tip\n\n\n\nFunctions like paste() can take in many values because they have a special argument, an ellipsis: … If you consult the help file for the paste function, you will see this:\n\n\n\nAnother useful argument for paste() is called sep. It tells R what character to use to separate the terms:\n\npaste(\"Luigi\", \"Fenway\", sep = \"-\")\n\n[1] \"Luigi-Fenway\"\n\n\n\n\n3.6.2 Nesting functions\nThe output of a function can be immediately taken in by another function. This is called function nesting.\nFor example, the function tolower() converts a string to lower case.\n\ntolower(\"LUIGI\")\n\n[1] \"luigi\"\n\n\nYou can take the output of this and pass it directly into another function:\n\npaste(tolower(\"LUIGI\"), \"is my name\")\n\n[1] \"luigi is my name\"\n\n\n\nWithout this option of nesting, you would have to assign an intermediate object:\n\nmy_lowercase_name &lt;- tolower(\"LUIGI\")\npaste(my_lowercase_name, \"is my name\")\n\n[1] \"luigi is my name\"\n\n\nFunction nesting will come in very handy soon.\n\n\n\n\n\n\nPractice\n\n\n\nQuestion 8\nThe code chunks below are all examples of function nesting. One of the lines has an error. Which line is it, and what is the error?\n\nsqrt(head(women))\n\n\npaste(sqrt(9), \"plus 1 is\", sqrt(16))\n\n\nsqrt(tolower(\"LUIGI\"))"
  },
  {
    "objectID": "foundations_ls03_coding_basics.html#packages",
    "href": "foundations_ls03_coding_basics.html#packages",
    "title": "3  Coding basics",
    "section": "3.7 Packages",
    "text": "3.7 Packages\nAs we mentioned previously, R is wonderful because it is user extensible: anyone can create a software package that adds new functionality. Most of R’s power comes from these packages.\nIn the previous lesson, you installed and loaded the {highcharter} package using the install.packages() and library() functions. Let’s learn a bit more about packages now.\n\n3.7.1 A first example: the {tableone} package\nLet’s now install and use another R package, called tableone:\n\ninstall.packages(\"tableone\")\n\n\nlibrary(tableone)\n\nNote that you only need to install a package once, but you have to load it with library() each time you want to use it. This means that you should generally run the install.packages() line directly from the console, rather than typing it into your script.\n\nThe package eases the construction of “Table 1”, i.e. a table with characteristics of the study sample that is commonly found in biomedical research papers.\nThe simplest use case is summarizing the whole dataset. You can just feed in the data frame to the data argument of the main workhorse function CreateTableOne().\n\nCreateTableOne(data = ebola_data)\n\n                        \n                         Overall       \n  n                         200        \n  id (mean (SD))         146.00 (82.28)\n  age (mean (SD))         33.12 (17.85)\n  sex = M (%)                76 (38.0) \n  status = suspected (%)     18 ( 9.0) \n  date_of_onset (%)                    \n     2014-05-18               1 ( 0.5) \n     2014-05-20               1 ( 0.5) \n     2014-05-21               1 ( 0.5) \n     2014-05-22               2 ( 1.0) \n     2014-05-23               1 ( 0.5) \n     2014-05-24               2 ( 1.0) \n     2014-05-26               8 ( 4.0) \n     2014-05-27               7 ( 3.5) \n     2014-05-28               1 ( 0.5) \n     2014-05-29               9 ( 4.5) \n     2014-05-30               4 ( 2.0) \n     2014-05-31               2 ( 1.0) \n     2014-06-01               2 ( 1.0) \n     2014-06-02               1 ( 0.5) \n     2014-06-03               1 ( 0.5) \n     2014-06-05               1 ( 0.5) \n     2014-06-06               5 ( 2.5) \n     2014-06-07               3 ( 1.5) \n     2014-06-08               4 ( 2.0) \n     2014-06-09               1 ( 0.5) \n     2014-06-10              22 (11.0) \n     2014-06-11               1 ( 0.5) \n     2014-06-12               7 ( 3.5) \n     2014-06-13              15 ( 7.5) \n     2014-06-14               8 ( 4.0) \n     2014-06-15               3 ( 1.5) \n     2014-06-16               1 ( 0.5) \n     2014-06-17               4 ( 2.0) \n     2014-06-18               5 ( 2.5) \n     2014-06-19               8 ( 4.0) \n     2014-06-20               7 ( 3.5) \n     2014-06-21               2 ( 1.0) \n     2014-06-22               1 ( 0.5) \n     2014-06-23               2 ( 1.0) \n     2014-06-24               8 ( 4.0) \n     2014-06-25               6 ( 3.0) \n     2014-06-26              10 ( 5.0) \n     2014-06-27               9 ( 4.5) \n     2014-06-28              17 ( 8.5) \n     2014-06-29               7 ( 3.5) \n  date_of_sample (%)                   \n     2014-05-23               1 ( 0.5) \n     2014-05-25               1 ( 0.5) \n     2014-05-26               1 ( 0.5) \n     2014-05-27               2 ( 1.0) \n     2014-05-28               1 ( 0.5) \n     2014-05-29               2 ( 1.0) \n     2014-05-31               9 ( 4.5) \n     2014-06-01               6 ( 3.0) \n     2014-06-02               1 ( 0.5) \n     2014-06-03               9 ( 4.5) \n     2014-06-04               4 ( 2.0) \n     2014-06-05               1 ( 0.5) \n     2014-06-06               2 ( 1.0) \n     2014-06-07               2 ( 1.0) \n     2014-06-10               2 ( 1.0) \n     2014-06-11               4 ( 2.0) \n     2014-06-12               3 ( 1.5) \n     2014-06-13               3 ( 1.5) \n     2014-06-14               1 ( 0.5) \n     2014-06-15              21 (10.5) \n     2014-06-16               1 ( 0.5) \n     2014-06-17               5 ( 2.5) \n     2014-06-18              13 ( 6.5) \n     2014-06-19               9 ( 4.5) \n     2014-06-21               8 ( 4.0) \n     2014-06-22               7 ( 3.5) \n     2014-06-23               6 ( 3.0) \n     2014-06-24               6 ( 3.0) \n     2014-06-25               3 ( 1.5) \n     2014-06-27               5 ( 2.5) \n     2014-06-28               2 ( 1.0) \n     2014-06-29               8 ( 4.0) \n     2014-06-30               6 ( 3.0) \n     2014-07-01               4 ( 2.0) \n     2014-07-02              16 ( 8.0) \n     2014-07-03              13 ( 6.5) \n     2014-07-04               2 ( 1.0) \n     2014-07-05               2 ( 1.0) \n     2014-07-06               1 ( 0.5) \n     2014-07-08               3 ( 1.5) \n     2014-07-12               1 ( 0.5) \n     2014-07-14               1 ( 0.5) \n     2014-07-17               1 ( 0.5) \n     2014-07-21               1 ( 0.5) \n  district (%)                         \n     Bo                       4 ( 2.0) \n     Kailahun               146 (73.0) \n     Kenema                  41 (20.5) \n     Kono                     2 ( 1.0) \n     Port Loko                2 ( 1.0) \n     Western Urban            5 ( 2.5) \n\n\nYou can see there are 200 patients in this dataset, the mean age is 33 and 38% of the sample of the sample is male, among other details.\nVery cool! (One problem is that the package is assuming that the date variables are categorical; because of this the output table is much too long!)\nThe point of this demonstration of {tableone} is to show you that there is a lot of power in external R packages. This is a big strength of working with R, an open-source language with a vibrant ecosystem of contributors. Thousands of people are working right now on packages that may be helpful to you one day.\nYou can Google search “Cool R packages” and browse through the answers if you are eager to learn about more R packages.\n\n\n\n\n\n\nSide Note\n\n\n\nYou may have noticed that we embrace package names in curly braces, e.g. {tableone}. This is just a styling convention among R users/teachers. The braces do not mean anything.\n\n\n\n\n3.7.2 Full signifiers\nThe full signifier of a function includes both the package name and the function name: package::function().\nSo for example, instead of writing:\n\nCreateTableOne(data = ebola_data)\n\nWe could write this function with its full signifier, package::function():\n\ntableone::CreateTableOne(data = ebola_data)\n\nYou usually do not need to use these full signifiers in your scripts. But there are some situations where it is helpful:\nThe most common reason is that you want to make it very clear which package a function comes from.\nSecondly, you sometimes want to avoid needing to run library(package) before accessing the functions in a package. That is, you want to use a function from a package without first loading that package from the library. In that case, you can use the full signifier syntax.\nSo the following:\n\ntableone::CreateTableOne(data = ebola_data)\n\nis equivalent to:\n\nlibrary(tableone)\nCreateTableOne(data = ebola_data)\n\n\n\n\n\n\n\nPractice\n\n\n\nQuestion 9\nConsider the code below:\n\ntableone::CreateTableOne(data = ebola_data)\n\nWhich of the following is a correct interpretation of what this code means:\nA. The code applies the CreateTableOne function from the {tableone} package on the ebola_data object.\nB. The code applies the CreateTableOne argument from the {tableone} function on the ebola_data package.\nC. The code applies the CreateTableOne function from the {tableone} package on the ebola_data package.\n\n\n\n\n3.7.3 pacman::p_load()\nRather than use two separate functions, install.packages() then library(), to install then load packages, you can use a single function, p_load(), from the {pacman} package to automatically install a package if it is not yet installed, and load the package. We encourage this approach in the rest of this course.\nInstall {pacman} now by running this in your console:\n\ninstall.packages(\"pacman\")\n\nFrom now on, when you are introduced to a new package, you can simply use, pacman::p_load(package_name) to both install and load the package:\nTry this now for the outbreaks package, which we will use soon:\n\npacman::p_load(outbreaks)\n\n\nNow we have a small problem. The wonderful function pacman::p_load() automatically installs and loads packages.\nBut it would be nice to have some code that automatically installs the {pacman} package itself, if it is missing on a user’s computer.\nBut if you put the install.packages() line in a script, like so:\n\ninstall.packages(\"pacman\")\npacman::p_load(here, rmarkdown)\n\nyou will waste a lot of time. Because every time a user opens and runs a script, it will reinstall {pacman}, which can take a while. Instead we need code that first checks whether pacman is not yet installed and installs it if this is not the case.\nWe can do this with the following code:\n\nif(!require(pacman)) install.packages(\"pacman\")\n\nYou do not have to understand it at the moment, as it uses some syntax that you have not yet learned. Just note that in future chapters, we will often start a script with code like this:\n\nif(!require(pacman)) install.packages(\"pacman\")\npacman::p_load(here, rmarkdown)\n\nThe first line will install {pacman} if it is not yet installed. The second line will use p_load() function from {pacman} to load the remaining packages (and pacman::p_load() installs any packages that are not yet installed).\nPhew! Hope your head is still intact.\n\n\n\n\n\n\nPractice\n\n\n\nQuestion 10\nAt the start of an R script, we would like to install and load the package called {janitor}. Which of the following code chunks do we recommend you have in your script?\n\n\n\n\nif(!require(pacman)) install.packages(\"pacman\")\npacman::p_load(janitor)\n\n\n\n\n\ninstall.packages(\"janitor\")\nlibrary(janitor)\n\n\n\n\n\ninstall.packages(\"janitor\")\npacman::p_load(janitor)"
  },
  {
    "objectID": "foundations_ls03_coding_basics.html#wrapping-up",
    "href": "foundations_ls03_coding_basics.html#wrapping-up",
    "title": "3  Coding basics",
    "section": "3.8 Wrapping up",
    "text": "3.8 Wrapping up\nWith your new knowledge of R objects, R functions and the packages that functions come from, you are ready, believe it or not, to do basic data analysis in R. We’ll jump into this head first in the next lesson. See you there!"
  },
  {
    "objectID": "foundations_ls03_coding_basics.html#answers",
    "href": "foundations_ls03_coding_basics.html#answers",
    "title": "3  Coding basics",
    "section": "3.9 Answers",
    "text": "3.9 Answers\n\nTrue.\nThe division sign is evaluated first.\nThe answer is C. The code 2 + 2 + 2 gets evaluated before it is stored in the object.\na. The value is 1. The code evaluates to 9-8.\nb. table(ebola_data$district)\na. You cannot add two character strings. Adding only works for numbers.\nb. my_1st_name is typed with the number 1 initially, but in the paste() command, it is typed with the letter “I”.\nThe third line is the only line with a valid object name: top_20_rows\nThe last line, head(6, women), is invalid because the arguments are in the wrong order and they are not named.\nThe third code chunk has a problem. It attempts to find the square root of a character, which is impossible.\nThe first line, A, is the correct interpretation.\nThe first code chunk is the recommended way to install and load the package {janitor}\n\n\nReferences\nSome material in this lesson was adapted from the following sources:\n\n“File:Apple slicing function.png.” Wikimedia Commons, the free media repository. 1 Oct 2021, 04:26 UTC. 20 Mar 2022, 17:27 &lt;https://commons.wikimedia.org/w/index.php?title=File:Apple_slicing_function.png&oldid=594767630&gt;.\n“PsyteachR | Data Skills for Reproducible Research.” 2021. Github.io. 2021. https://psyteachr.github.io/reprores-v2/index.html.\nDouglas, Alex, Deon Roos, Francesca Mancini, Ana Couto, and David Lusseau. 2022. “An Introduction to R.” Intro2r.com. January 27, 2022. https://intro2r.com/.\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#learning-objectives",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#learning-objectives",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "Learning objectives",
    "text": "Learning objectives\n\nYou can use RStudio’s graphic user interface to import CSV data into R.\nYou can explain the concept of reproducibility.\nYou can use the nrow(), ncol() and dim() functions to get the dimensions of a dataset, and the summary() function to get a summary of the dataset’s variables.\nYou can use vis_dat(), inspect_num() and inspect_cat() to obtain visual summaries of a dataset.\nYou can inspect a numeric variable:\n\nwith the summary functions mean() , median(), max(), min(), length() and sum();\nwith esquisse-generated ggplot2 code.\n\nYou can inspect a categorical variable:\n\nwith the summary functions table() and janitor::tabyl();\nwith the graphical functions barplot() and pie()."
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#introduction",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#introduction",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "4.1 Introduction",
    "text": "4.1 Introduction\nWith your newly-acquired knowledge of functions and objects, you now have the basic building blocks required to do simple data analysis in R. So let’s get started. The goal is to start working with data as quickly as possible, even before you feel ready.\nHere you will analyze a dataset of confirmed and suspected cases of Ebola hemorrhagic fever in Sierra Leone in May and June of 2014 (Fang et al., 2016). The data is shown below:\n\n\n# A tibble: 10 × 7\n      id   age sex   status    date_of_onset date_of_sample district\n   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;date&gt;        &lt;date&gt;         &lt;chr&gt;   \n 1    92     6 M     confirmed 2014-06-10    2014-06-15     Kailahun\n 2    51    46 F     confirmed 2014-05-30    2014-06-04     Kailahun\n 3   230    NA M     confirmed 2014-06-26    2014-06-30     Kenema  \n 4   139    25 F     confirmed 2014-06-13    2014-06-18     Kailahun\n 5     8     8 F     confirmed 2014-05-22    2014-05-27     Kailahun\n 6   215    49 M     confirmed 2014-06-24    2014-06-29     Kailahun\n 7   189    13 F     confirmed 2014-06-19    2014-06-24     Kailahun\n 8   115    50 M     confirmed 2014-06-10    2014-06-25     Kailahun\n 9   218    35 F     confirmed 2014-06-25    2014-06-28     Kenema  \n10   159    38 F     confirmed 2014-06-14    2014-06-22     Kailahun\n\n\nYou will import and explore this dataset, then use R to answer the following questions about the outbreak:\n\nWhen was the first case reported?\nWhat was the median age of those affected?\nHad there been more cases in men or women?\nWhat district had had the most reported cases?\nBy the end of June 2014, was the outbreak growing or receding?"
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#script-setup",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#script-setup",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "4.2 Script setup",
    "text": "4.2 Script setup\nFirst, open a new script in RStudio with File &gt; New File &gt; R Script. (If you are on RStudio, you can open up any of your previously-created projects.)\n\nNext, save the script with File &gt; Save As or press Command/Control + S to bring up the Save File dialog box. Save the file with the name “ebola_analysis” or something similar\n\n\n\n\n\n\nSide Note\n\n\n\nEmpty your environment at the start of the analysis\nWhen you start a new analysis, your R environment should usually be empty. Verify this by opening the Environment tab; it should say “Environment is empty”. If instead, it shows some previously-loaded objects, it is recommended to restart R by going to the menu option Session &gt; Restart R\n\n\n\n4.2.1 Header\nAdd a title, name and date to the start of the script, as code comments. This is generally good practice for writing R scripts, as it helps give you and your collaborators context about your script. Your header may look like this:\n\n## Ebola Sierra Leone analysis\n## John Sample-Name Doe\n## 2024-01-01\n\n\n\n4.2.2 Packages\nNext, use the p_load() function from {pacman} to load the packages you will be using. Put this under a section header called “Load packages”, with four hyphens, as shown below:\n\n## Load packages ----\nif(!require(pacman)) install.packages(\"pacman\")\npacman::p_load(\n  tidyverse, # meta-package\n  inspectdf,\n  plotly,\n  janitor,\n  visdat,\n  esquisse\n)\n\n\n\n\n\n\n\nReminder\n\n\n\nRemember that the full signifier of a function includes both the package name and the function name, package::function(). This full signifier is handy if you want to use a function before you have loaded its source package. This is the case in the code chunk above: we want use p_load() from {pacman} without formally loading the {pacman} package, so we type pacman::p_load()\nWe could also first load {pacman} before using the p_load function:\n\nlibrary(pacman) # first load {pacman}\np_load(tidyverse) # use `p_load` from {pacman} to load other packages\n\n(Also recall that the benefit of p_load() is that it automatically installs a package if it is not yet installed. Without p_load(), you have to first install the package with install.packages() before you can load it with library().)"
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#importing-data-into-r",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#importing-data-into-r",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "4.3 Importing data into R",
    "text": "4.3 Importing data into R\nNow that the needed packages are loaded, you should import the dataset.\n\n\n\n\n\n\nSide Note\n\n\n\nAbout the Ebola dataset\nThe data you will be working on contains a sample of patient information from the 2014-2016 Ebola outbreak in Sierra Leone. It comes from a research paper which analyzed the transmission dynamics of that outbreak. Key variables include the status of a case, whether the case was “confirmed” or “suspected”; the date_of_onset, when Ebola-like symptoms arose in a patient; and the date_of_sample, when the test sample was taken. To learn more about these data, visit the source publication here: bit.ly/ebola-data-source. Or search the following DOI on DOI.org: 10.1073/pnas.1518587113.\n\n\nGo to bit.ly/view-ebola-data to view the dataset you will be working on. Then click the download icon at the top to download it to your computer.\n\nYou can leave the dataset in your downloads folder, or move it to somewhere more respectable; the upcoming steps will work independent of where the data is stored. In the next lesson, you will learn how to organize your data analysis projects properly, and we will think about the ideal folder setup for storing data.\n\n\n\n\n\n\n\nRStudio Cloud\n\n\n\nNOTE: If you are using RStudio Cloud, you need to upload your dataset to the cloud. Do this in the “Files” tab by clicking on the “Upload” button.\n\n\n\n\nNext, on the RStudio menu, go to File &gt; Import Dataset &gt; From Text (readr). \nBrowse through the computer’s files and navigate to the downloaded dataset. Click to open it. You should see an import dialog box like this:\n\nLeave all the import settings at the default values; simply click on “Import” at the bottom; this should load the dataset into R. You can tell this by looking at your environment pane, which should now feature an object called “ebola_sierra_leone” or something similar:\n\nRStudio should also have called the View() function on your dataset, so you should see a familiar spreadsheet view of this data:\n\nNow take a look at your console. Do you observe that your actions in the graphical user interface actually triggered some R code to be run? Copy the line of code that includes the read_csv() function, leaving out the &gt; symbol.\n\nPaste the copied code into your R script, and label this section “Load data”. This may look something like the below (the file path inside quotes will differ from computer to computer.\n\n## Load data ----\nebola_sierra_leone &lt;- read_csv(\"~/Downloads/ebola_sierra_leone.csv\")\n\n\n\n\n\n\n\nRecap\n\n\n\nNice work so far!\nYour R script should look similar to this:\n\n## Ebola Sierra Leone analysis\n## John Sample-Name Doe\n## 2024-01-01\n\n## Load packages ----\nif(!require(pacman)) install.packages(\"pacman\")\npacman::p_load(\n  tidyverse,\n  inspectdf,\n  plotly,\n  janitor,\n  visdat\n)\n\n## Load data ----\nebola_sierra_leone &lt;- read_csv(\"~/Downloads/ebola_sierra_leone.csv\")"
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#intro-to-reproducibility",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#intro-to-reproducibility",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "4.4 Intro to reproducibility",
    "text": "4.4 Intro to reproducibility\nNow that the code for importing data is in your R script, you can easily rerun this script anytime to reimport the dataset; there will be no need to redo the manual point-and-click procedure for data import.\nTry restarting R and rerunning the script now. Save your script with Control/Command + s , then restart R with the RStudio Menu, at Session &gt; Restart R. On RStudio Cloud, the menu option looks like this:\n\nIf restarting is successful, your console should print this message:\n\nYou should also see the phrase “Environment is empty” in the Environment tab, indicating that the dataset you imported is no longer stored by R—you are starting with a fresh workspace.\n\nTo re-run your script, use Command/Control + a to highlight all the code, then Command/Control + Enter to run it.\nIf this worked, congratulations; you have the beginnings of your first “reproducible” analysis script!\n\n\n\n\n\n\nVocab\n\n\n\nWhat does “reproducible” mean?\nWhen you do things with code rather than by pointing and clicking, it is easy for anyone to re-run, or reproduce these steps, by simply re-running your script.\nWhile you can use RStudio’s graphical user interface to point-and-click your way through the data import process, you should always copy the relevant code to your script so that your script remains a reproducible record of all your analysis steps.\nOf course, your script so far is not yet entirely reproducible, because the file path for the dataset (the one that looks like this: “…intro-to-data-analysis-with-r/ch01_getting_started/data…”) is specific to just your computer. Later on we will see how to use relative file paths, so that the code for importing data can work on anyone’s computer.\n\n\n\n\n\n\n\n\nWatch Out\n\n\n\nIf your environment was not empty after restarting R, it means you skipped a step in a previous lesson. Do this now:\n\nIn the RStudio Menu, go to Tools &gt; Global Options to bring up RStudio’s options dialog box.\nThen go to General &gt; Basic, and uncheck the box that says “Restore .RData into workspace at startup”.\nFor the option, “save your workspace to .RData on exit”, set this to “Never”."
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#quick-data-exploration",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#quick-data-exploration",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "4.5 Quick data exploration",
    "text": "4.5 Quick data exploration\nNow let’s walk through some basic steps of data exploration—taking a broad, bird’s eye look at the dataset. You should put this section under a heading like “Explore data” in your script.\nTo view the top and bottom 6 rows of the dataset, you can use the head() and tail() functions:\n\n## Explore data ----\nhead(ebola_sierra_leone)\n\n# A tibble: 6 × 7\n     id   age sex   status    date_of_onset date_of_sample district\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;date&gt;        &lt;date&gt;         &lt;chr&gt;   \n1    92     6 M     confirmed 2014-06-10    2014-06-15     Kailahun\n2    51    46 F     confirmed 2014-05-30    2014-06-04     Kailahun\n3   230    NA M     confirmed 2014-06-26    2014-06-30     Kenema  \n4   139    25 F     confirmed 2014-06-13    2014-06-18     Kailahun\n5     8     8 F     confirmed 2014-05-22    2014-05-27     Kailahun\n6   215    49 M     confirmed 2014-06-24    2014-06-29     Kailahun\n\ntail(ebola_sierra_leone)\n\n# A tibble: 6 × 7\n     id   age sex   status    date_of_onset date_of_sample district\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;date&gt;        &lt;date&gt;         &lt;chr&gt;   \n1   214     6 F     confirmed 2014-06-24    2014-06-30     Kenema  \n2    28    45 F     confirmed 2014-05-27    2014-06-01     Kailahun\n3    12    27 F     confirmed 2014-05-22    2014-05-27     Kailahun\n4   110     6 M     confirmed 2014-06-10    2014-06-15     Kailahun\n5   209    40 F     confirmed 2014-06-24    2014-06-27     Kailahun\n6    35    29 M     suspected 2014-05-28    2014-06-01     Kenema  \n\n\nTo view the whole dataset, use the View() function.\n\nView(ebola_sierra_leone)\n\nThis will again open a familiar spreadsheet view of the data:\n\nYou can close this tab and return to your script.\n\nThe functions nrow(), ncol() and dim() give you the dimensions of your dataset:\n\nnrow(ebola_sierra_leone) # number of rows\n\n[1] 200\n\nncol(ebola_sierra_leone) # number of columns\n\n[1] 7\n\ndim(ebola_sierra_leone) # number of rows and columns\n\n[1] 200   7\n\n\n\n\n\n\n\n\nReminder\n\n\n\nIf you’re not sure what a function does, remember that you can get function help with the question mark symbol. For example, to get help on the ncol() function, run:\n\n?ncol\n\n\n\n\nAnother often-helpful function is summary():\n\nsummary(ebola_sierra_leone)\n\n       id              age            sex               status         \n Min.   :  1.00   Min.   : 1.80   Length:200         Length:200        \n 1st Qu.: 62.75   1st Qu.:20.00   Class :character   Class :character  \n Median :131.50   Median :35.00   Mode  :character   Mode  :character  \n Mean   :136.72   Mean   :33.85                                        \n 3rd Qu.:208.25   3rd Qu.:45.00                                        \n Max.   :285.00   Max.   :80.00                                        \n                  NA's   :4                                            \n date_of_onset        date_of_sample         district        \n Min.   :2014-05-18   Min.   :2014-05-23   Length:200        \n 1st Qu.:2014-06-01   1st Qu.:2014-06-07   Class :character  \n Median :2014-06-13   Median :2014-06-18   Mode  :character  \n Mean   :2014-06-12   Mean   :2014-06-17                     \n 3rd Qu.:2014-06-23   3rd Qu.:2014-06-29                     \n Max.   :2014-06-29   Max.   :2014-07-17                     \n                                                             \n\n\nAs you can see, for numeric columns in your dataset, summary() gives you the minimum value, the maximum value, the mean, median and the 1st and 3rd quartiles.\nFor character columns it gives you just the length of the column (the number of rows), the “class” and the “mode”. We will discuss what “class” and “mode” mean later.\n\n4.5.1 vis_dat()\nThe vis_dat() function from the {visdat} package is a wonderful way to quickly visualize the data types and the missing values in a dataset. Try this now:\n\nvis_dat(ebola_sierra_leone)\n\n\n\n\nFrom this figure, you can quickly see the character, date and numeric data types, and you can note that age is missing for some cases.\n\n\n4.5.2 inspect_cat() and inspect_num()\nNext, inspect_cat() and inspect_num() from the {inspectdf} package give you visual summaries of the distribution of variables in the dataset.\nIf you run inspect_cat() on the data object, you get a tabular summary of the categorical variables in the dataset, with some information hidden in the levels column (later you will learn how to extract this information).\n\ninspect_cat(ebola_sierra_leone)\n\n# A tibble: 5 × 5\n  col_name         cnt common     common_pcnt levels           \n  &lt;chr&gt;          &lt;int&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;named list&gt;     \n1 date_of_onset     39 2014-06-10        10   &lt;tibble [39 × 3]&gt;\n2 date_of_sample    45 2014-06-15         9.5 &lt;tibble [45 × 3]&gt;\n3 district           7 Kailahun          77.5 &lt;tibble [7 × 3]&gt; \n4 sex                2 F                 57   &lt;tibble [2 × 3]&gt; \n5 status             2 confirmed         91   &lt;tibble [2 × 3]&gt; \n\n\nBut the magic happens when you run show_plot() on the result from inspect_cat():\n\n## store the output of `inspect_cat()` in `cat_summary`\ncat_summary &lt;- inspect_cat(ebola_sierra_leone)\n\n## call the `show_plot()` function on that summmary.\nshow_plot(cat_summary)\n\n\n\n\nYou get a wonderful figure showing the distribution of all categorical and date variables!\n\n\n\n\n\n\nSide Note\n\n\n\nYou could also run:\n\nshow_plot(inspect_cat(ebola_sierra_leone))\n\n\n\n\n\n\nFrom this plot, you can quickly tell that most cases are in Kailahun, and that there are more cases in women than in men (“F” stands for “female”).\nOne problem is that in this plot, the smaller categories are not labelled. So, for example, we are not sure what value is represented by the white section for “status” at the bottom right. To see labels on these smaller categories, you can turn this into an interactive plot with the ggplotly() function from the {plotly} package.\n\ncat_summary_plot &lt;- show_plot(cat_summary)\nggplotly(cat_summary_plot)\n\nWonderful! Now you can hover over each of the bars to see the proportion of each bar section. For example you can now tell that 9% (0.090) of the cases have a suspected status:\n\n\n\n\n\n\n\nReminder\n\n\n\nThe assignment arrow, &lt;-, can be written with the RStudio shortcut alt + - (alt AND minus) on Windows or option + - (option AND minus) on macOS.\n\n\n\nYou can obtain a similar plot for the numerical (continuous) variables in the dataset with inspect_num(). Here, we show all three steps in one go.\n\nnum_summary &lt;- inspect_num(ebola_sierra_leone)\nnum_summary_plot &lt;- show_plot(num_summary)\nggplotly(num_summary_plot)\n\nThis gives you an overview of the numerical columns, age and id. (Of course, the distribution of the id variable is not meaningful.)\nYou can tell that individuals aged 35 to 40 (mid-point 37.5) are the largest age group, making up 13.8% (0.1377…) of the cases in the dataset."
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#analyzing-a-single-numeric-variable",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#analyzing-a-single-numeric-variable",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "4.6 Analyzing a single numeric variable",
    "text": "4.6 Analyzing a single numeric variable\nNow that you have a sense of what the entire dataset looks like, you can isolate and analyze single variables at a time—this is called univariate analysis.\nGo ahead and create a new section in your script for this univariate analysis.\n\n## Univariate analysis, numeric variables ----\n\nLet’s start by analyzing the numeric age variable.\n\n4.6.1 Extract a column vector with $\nTo extract a single variable/column from a dataset, use the dollar sign, $ operator:\n\nebola_sierra_leone$age # extract the age column in the dataset\n\n  [1]  6.0 46.0   NA 25.0  8.0 49.0 13.0 50.0 35.0 38.0 60.0 18.0 10.0 14.0 50.0\n [16] 35.0 43.0 17.0  3.0 60.0 38.0 41.0 49.0 12.0 74.0 21.0 27.0 41.0 42.0 60.0\n [31] 30.0 50.0 50.0 22.0 40.0 35.0 19.0  3.0 34.0 21.0 73.0 65.0 30.0 70.0 12.0\n [46] 15.0 42.0 60.0 14.0 40.0 33.0 43.0 45.0 14.0 14.0 40.0 35.0 30.0 17.0 39.0\n [61] 20.0  8.0 40.0 42.0 53.0 18.0 40.0 20.0 45.0 40.0 60.0 44.0 33.0 23.0 45.0\n [76]  7.0   NA 35.0 36.0 42.0 35.0 25.0 30.0 30.0 28.0 14.0 20.0 60.0 67.0 35.0\n [91] 50.0  4.0 28.0 38.0 30.0 26.0 37.0 30.0  3.0 56.0 32.0 35.0 54.0 42.0 48.0\n[106] 11.0  1.8 63.0 55.0 20.0 62.0 62.0 42.0 65.0 29.0 20.0 33.0 30.0 35.0   NA\n[121] 50.0 16.0  3.0 22.0  7.0 50.0 17.0 40.0 21.0  9.0 27.0 52.0 50.0 25.0 10.0\n[136] 30.0 32.0 38.0 30.0 50.0 26.0 35.0  3.0 50.0 60.0 40.0 34.0  4.0 42.0   NA\n[151] 54.0 18.0 45.0 30.0 35.0 35.0 16.0 26.0 23.0 45.0 45.0 45.0 38.0 45.0 35.0\n[166] 30.0 60.0  5.0 18.0  2.0 70.0 35.0  3.0 30.0 80.0 62.0 20.0 45.0 18.0 28.0\n[181] 48.0 38.0 39.0 26.0 60.0 35.0 20.0 50.0 11.0 36.0 29.0 57.0 35.0 26.0  6.0\n[196] 45.0 27.0  6.0 40.0 29.0\n\n\n\n\n\n\n\n\nVocab\n\n\n\nThis list of values is called a vector in R. A vector is a kind of data structure that has elements of one type. In this case, the type is “numeric”. We will formally introduce you to vectors and other data structures in a future chapter. In this lesson, you can take “vector” and “variable” to be synonyms.\n\n\n\n\n4.6.2 Basic operations on a numeric variable\nTo get the mean of these ages, you could run:\n\nmean(ebola_sierra_leone$age)\n\n[1] NA\n\n\nBut it seems we have a problem. R says the mean is NA, which means “not applicable” or “not available”. This is because there are some missing values in the vector of ages. (Did you notice this when you printed the vector?) By default, R cannot find the mean if there are missing values. To ignore these values, use the argument na.rm (which stands for “NA remove”) setting it to T, or TRUE:\n\nmean(ebola_sierra_leone$age, na.rm = T)\n\n[1] 33.84592\n\n\nGreat! This need to remove the NAs before computing a statistic applies to many functions. The median() function for example, will also return NA by default if it is called on a vector with any NAs:\n\nmedian(ebola_sierra_leone$age) # does not work\n\n[1] NA\n\n\n\nmedian(ebola_sierra_leone$age, na.rm = T) # works\n\n[1] 35\n\n\n\nmean and median are just two of many R functions that can be used to inspect a numerical variable. Let’s look at some others.\nBut first, we can assign the age vector to a new object, so you don’t have to keep typing ebola_sierra_leone$age each time.\n\nage_vec &lt;- ebola_sierra_leone$age # assign the vector to the object \"age_vec\"\n\nNow run these functions on age_vec and observe their outputs:\n\nsd(age_vec, na.rm = T) # standard deviation\n\n[1] 17.26864\n\nmax(age_vec, na.rm = T) # maximum age\n\n[1] 80\n\nmin(age_vec, na.rm = T) # minimum age\n\n[1] 1.8\n\nsummary(age_vec) # min, max, mean, quartiles and NAs\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   1.80   20.00   35.00   33.85   45.00   80.00       4 \n\nlength(age_vec) # number of elements in the vector\n\n[1] 200\n\nsum(age_vec, na.rm = T) # sum of all elements in the vector\n\n[1] 6633.8\n\n\nDo not feel intimidated by the long list of functions! You should not have to memorize them; rather you should feel free to Google the function for whatever operation you want to carry out. You might search something like “what is the function for standard deviation in R”. One of the first results should lead you to what you need.\n\n\n4.6.3 Visualizing a numeric variable\nNow let’s create a graph to visualize the age variable. The two most common graphics for inspecting the distribution of numerical variables are histograms (like the output of the inspect_num() function you saw earlier) and boxplots.\nR has built-in functions for these:\n\nhist(age_vec)\n\n\n\n\n\nboxplot(age_vec)\n\n\n\n\nNice and easy!\nGraphical functions like boxplot() and hist() are part of R’s base graphics package. These functions are quick and easy to use, but they do not offer a lot of flexibility, and it is difficult to make beautiful plots with them. So most people in the R community use an extension package, {ggplot2}, for their data visualization.\nIn this course, we’ll use ggplot indirectly; by using the {esquisse} package, which provides a user-friendly interface for creating ggplot2 plots.\nThe workhorse function of the {esquisse} package is esquisser(), and this function takes a single argument—the dataset you want to visualize. So we can run:\n\nesquisser(ebola_sierra_leone)\n\nThis should bring a graphic user interface that you can use to plot different variables. To visualize the age variable, simply drag age from the list of variables into the x axis box:\n\nWhen age is in the x axis box, you should automatically get a histogram of ages:\n\nYou can change the plot type by clicking on the “Histogram” button and selecting one of the other valid plot types. Try out the boxplot, violin plot and density plot and observe the outputs.\n\nWhen you are done creating a plot with {esquisse}, you should copy the code that was created by clicking on the “Code” button at the bottom right then “Copy to clipboard”:\n\nNow, paste that code into your script, and make sure you can run it from there. The code should look something like this:\n\nggplot(ebola_sierra_leone) +\n  aes(x = age) +\n  geom_histogram(bins = 30L, fill = \"#112446\") +\n  theme_minimal()\n\nBy copying the generated code into your script, you ensure that the data visualization you created is fully reproducible.\n\n\n\n\n\n\nPro Tip\n\n\n\n{esquisse} can only create fairly simple graphics, so when you want to make highly customized or complex plots, you will need to learn how to write {ggplot} code manually. This will be the focus of a later course.\n\n\nYou should also test out the other tabs on the bottom toolbar to see what they do: Labels & Title, Plot options, Appearance and Data.\n\n\n\n\n\n\nChallenge\n\n\n\nEasy bivariate and multivariate plots\nIn this lesson we are focusing on univariate analysis: exploring and visualizing one variable at a time. But with esquisse; it is so easy to make a bivariate or multivariate plot, so you can already get your feet wet with this.\nTry the following plots:\n\nDrag age to the X box and sex to the Y box.\nDrag age to the X box, sex to the Y box, and sex to the fill box.\nDrag age to the X box and district to the Y box."
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#analyzing-a-single-categorical-variable",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#analyzing-a-single-categorical-variable",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "4.7 Analyzing a single categorical variable",
    "text": "4.7 Analyzing a single categorical variable\nNext, let’s look at a categorical variable, the districts of reported cases:\n\n## Univariate analysis, categorical variables ----\nebola_sierra_leone$district\n\n  [1] \"Kailahun\"      \"Kailahun\"      \"Kenema\"        \"Kailahun\"     \n  [5] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n  [9] \"Kenema\"        \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n [13] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n [17] \"Kailahun\"      \"Kenema\"        \"Kono\"          \"Kailahun\"     \n [21] \"Kailahun\"      \"Kailahun\"      \"Kenema\"        \"Kailahun\"     \n [25] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n [29] \"Kenema\"        \"Kenema\"        \"Kenema\"        \"Kailahun\"     \n [33] \"Kailahun\"      \"Bo\"            \"Kailahun\"      \"Kailahun\"     \n [37] \"Kailahun\"      \"Kenema\"        \"Kenema\"        \"Kenema\"       \n [41] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n [45] \"Kailahun\"      \"Kailahun\"      \"Western Urban\" \"Kailahun\"     \n [49] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n [53] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n [57] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n [61] \"Kailahun\"      \"Kenema\"        \"Western Urban\" \"Kambia\"       \n [65] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n [69] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n [73] \"Kenema\"        \"Kailahun\"      \"Kailahun\"      \"Kenema\"       \n [77] \"Kailahun\"      \"Kailahun\"      \"Kenema\"        \"Kailahun\"     \n [81] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n [85] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n [89] \"Kailahun\"      \"Kenema\"        \"Kailahun\"      \"Kailahun\"     \n [93] \"Kailahun\"      \"Kono\"          \"Port Loko\"     \"Kenema\"       \n [97] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[101] \"Kenema\"        \"Kailahun\"      \"Kailahun\"      \"Kenema\"       \n[105] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[109] \"Kailahun\"      \"Kailahun\"      \"Kenema\"        \"Western Urban\"\n[113] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[117] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[121] \"Kailahun\"      \"Kailahun\"      \"Kenema\"        \"Kailahun\"     \n[125] \"Kailahun\"      \"Kenema\"        \"Kailahun\"      \"Port Loko\"    \n[129] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[133] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[137] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[141] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kenema\"       \n[145] \"Kenema\"        \"Kailahun\"      \"Kenema\"        \"Kailahun\"     \n[149] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[153] \"Kenema\"        \"Kailahun\"      \"Kailahun\"      \"Kenema\"       \n[157] \"Kailahun\"      \"Kenema\"        \"Kailahun\"      \"Kailahun\"     \n[161] \"Kenema\"        \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[165] \"Kailahun\"      \"Bo\"            \"Kailahun\"      \"Kailahun\"     \n[169] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[173] \"Kenema\"        \"Kailahun\"      \"Kailahun\"      \"Kenema\"       \n[177] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[181] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Western Urban\"\n[185] \"Kailahun\"      \"Kailahun\"      \"Kenema\"        \"Kailahun\"     \n[189] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kailahun\"     \n[193] \"Kailahun\"      \"Kenema\"        \"Kenema\"        \"Kailahun\"     \n[197] \"Kailahun\"      \"Kailahun\"      \"Kailahun\"      \"Kenema\"       \n\n\nSorry for printing that very long vector!\n\n4.7.1 Frequency tables\nYou can use the table() function to create a frequency table of a categorical variable:\n\ntable(ebola_sierra_leone$district)\n\n\n           Bo      Kailahun        Kambia        Kenema          Kono \n            2           155             1            34             2 \n    Port Loko Western Urban \n            2             4 \n\n\nYou can see that most cases are in Kailahun and Kenema.\n\ntable() is auseful “base” function. But there is a better function for creating frequency tables, called tabyl(), from the {janitor} package.\nTo use it, you supply the name of your data frame as the first argument, then the name of variable to be tabulated:\n\ntabyl(ebola_sierra_leone, district)\n\n      district   n percent\n            Bo   2   0.010\n      Kailahun 155   0.775\n        Kambia   1   0.005\n        Kenema  34   0.170\n          Kono   2   0.010\n     Port Loko   2   0.010\n Western Urban   4   0.020\n\n\nAs you can see, tabyl() gives you both the counts and the percentage proportions of each value. It also has some other attractive features you will see later.\n\n\n\n\n\n\nPro Tip\n\n\n\nYou can also easily make cross-tabulations with tabyl(). Simply add additional variables separated by a comma. For example, to create a cross-tabulation by district and sex, run:\n\ntabyl(ebola_sierra_leone, district, sex)\n\n      district  F  M\n            Bo  0  2\n      Kailahun 91 64\n        Kambia  0  1\n        Kenema 20 14\n          Kono  0  2\n     Port Loko  1  1\n Western Urban  2  2\n\n\nThe output shows us that there were 0 women in the Bo district, 2 men in the Bo district, 91 women in the Kailahun district, and so on.\n\n\n\n\n4.7.2 Visualizing a categorical variable\nNow, let’s try to visualize the district variable. As before, the best way to do this is with the esquisser() function from {esquisse}. Run this code again:\n\nesquisser(ebola_sierra_leone)\n\nThen drag the district variable to the X axis box:\n\nYou should get a bar chart showing the count of individuals across districts. Copy the generated code and paste it into your script."
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#answering-questions-about-the-outbreak",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#answering-questions-about-the-outbreak",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "4.8 Answering questions about the outbreak",
    "text": "4.8 Answering questions about the outbreak\nWith the functions you have just learned, you have the tools to answer the questions about the Ebola outbreak that were listed at the top. Give it a go. Attempt these questions on your own, then look at the solutions below.\n\nWhen was the first case reported? (Hint: look at the date of sample)\nAs at the end of June 2014, which 10-year age group had had the most cases?\nWhat was the median age of those affected?\nHad there been more cases in men or women?\nWhat district had had the most reported cases?\nBy the end of June 2014, was the outbreak growing or receding?\n\n\nSolutions\n\nWhen was the first case reported?\n\n\nmin(ebola_sierra_leone$date_of_sample)\n\n[1] \"2014-05-23\"\n\n\nWe don’t have the date of report, but the first “date_of_sample” (when the Ebola test sample was taken from the patient) is May 23rd. We can use this as a proxy for the date of first report.\n\nWhat was the median age of cases?\n\n\nmedian(ebola_sierra_leone$age, na.rm = T)\n\n[1] 35\n\n\nThe median age of cases was 35.\n\nAre there more cases in men or women?\n\n\ntabyl(ebola_sierra_leone$sex)\n\n ebola_sierra_leone$sex   n percent\n                      F 114    0.57\n                      M  86    0.43\n\n\nAs seen in the table, there were more cases in women. Specifically, 57% of cases are of women.\n\nWhat district has had the most reported cases?\n\n\ntabyl(ebola_sierra_leone$district)\n\n ebola_sierra_leone$district   n percent\n                          Bo   2   0.010\n                    Kailahun 155   0.775\n                      Kambia   1   0.005\n                      Kenema  34   0.170\n                        Kono   2   0.010\n                   Port Loko   2   0.010\n               Western Urban   4   0.020\n\n## We can also plot the following chart (generated with esquisse)\nggplot(ebola_sierra_leone) +\n  aes(x = district) +\n  geom_bar(fill = \"#112446\") +\n  theme_minimal()\n\n\n\n\nAs seen, the Kailahun district had the majority of cases.\n\nBy the end of June 2014, was the outbreak growing or receding?\n\nFor this, we can use esquisse to generate a bar chart that shows a count of cases in each day. Simply drag the date_of_onset variable to the x axis. The output code from esquisse should resemble the below:\n\nggplot(ebola_sierra_leone) +\n  aes(x = date_of_onset) +\n  geom_histogram(bins = 30L, fill = \"#112446\") +\n  theme_minimal()\n\n\n\n\nGreat! But it is debatable whether the outbreak was growing or receding at the end of June 2014; a precise trend is not really clear!"
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#havent-had-enough",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#havent-had-enough",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "4.9 Haven’t had enough?",
    "text": "4.9 Haven’t had enough?\nIf you would like to practice some of the methods and functions you learned on a similar dataset, try downloading the data that is stored on this page: https://bit.ly/view-yaounde-covid-data\nThat dataset is in the form of an Excel spreadsheet, so when you are importing the dataset with RStudio, you should use the “From Excel” option (File &gt; Import Dataset &gt; From Excel).\nThis dataset contains the results of a COVID-19 serological survey conducted in Yaounde, Cameroon in late 2020. The survey estimated how many people had been infected with COVID-19 in the region, by testing for IgG and IgM antibodies. The full dataset can be obtained from here: go.nature.com/3R866wx"
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#wrapping-up",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#wrapping-up",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "4.10 Wrapping up",
    "text": "4.10 Wrapping up\nCongratulations! You have now taken your first baby steps in analyzing data with R: you imported a dataset, explored its structure, performed basic univariate analysis and visualization on its numeric and categorical variables, and you were able to answer important questions about the outbreak based on this.\nOf course, this was only a sneak peek of the data analysis process—a lot was left out. Hopefully, though, this sneak peek has gotten you a bit excited about what you can do with R. And hopefully, you can already start to apply some of these to your own datasets. The journey is only beginning! See you soon."
  },
  {
    "objectID": "foundations_ls04_data_dive_ebola_sierra_leone.html#references",
    "href": "foundations_ls04_data_dive_ebola_sierra_leone.html#references",
    "title": "4  Data dive: Ebola in Sierra Leone",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nBarnier, Julien. “Introduction à R Et Au Tidyverse.” Partie 13 Diffuser et publier avec rmarkdown, May 24, 2022. https://juba.github.io/tidyverse/13-rmarkdown.html.\nYihui Xie, J. J. Allaire, and Garrett Grolemund. “R Markdown: The Definitive Guide.” Home, April 11, 2022. https://bookdown.org/yihui/rmarkdown/.\n\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  },
  {
    "objectID": "foundations_ls05_projects.html#learning-objectives",
    "href": "foundations_ls05_projects.html#learning-objectives",
    "title": "5  RStudio projects",
    "section": "5.1 Learning objectives",
    "text": "5.1 Learning objectives\n\nYou can set up an RStudio Project and create sub-directories for input data, scripts and analytic outputs.\nYou can import and export data within an RStudio Project.\nYou understand the difference between relative and absolute file paths.\nYou recognize the value of Projects for organizing and sharing your analyses."
  },
  {
    "objectID": "foundations_ls05_projects.html#introduction",
    "href": "foundations_ls05_projects.html#introduction",
    "title": "5  RStudio projects",
    "section": "5.2 Introduction",
    "text": "5.2 Introduction\nPreviously, you walked through some of the essential steps of data analysis, from importing data to calculating basic statistics. But you skipped over one crucial step: setting up a data analysis project.\nExperienced data analysts keep all the files associated with a specific analysis—input data, R scripts and analytic outputs—together in a single folder. These folders are called projects (small p), and RStudio has built-in support for them via RStudio Projects (capital P).\nIn this lesson you will learn how to use these RStudio Projects to organize your data analysis coherently, and improve the reproducibility of your work. You will replicate some of the analysis you did in the last data dive lesson, but in the context of an RStudio Project.\nLet’s get started."
  },
  {
    "objectID": "foundations_ls05_projects.html#creating-a-new-rstudio-project",
    "href": "foundations_ls05_projects.html#creating-a-new-rstudio-project",
    "title": "5  RStudio projects",
    "section": "5.3 Creating a new RStudio Project",
    "text": "5.3 Creating a new RStudio Project\nCreating a new RStudio Project looks different if you are on a local computer and if you are on RStudio Cloud. Jump to the section that is relevant for you.\n\n5.3.1 On RStudio Cloud\nIf you are using RStudio Cloud, you have probably already created a project, because you can’t do any analysis without projects.\nThe steps are pretty simple: go to your Cloud homepage, rstudio.cloud, and click on the “New Project” button.\n\nName your Project something like ebola_analysis or ebola_analysis_proj if you already have a project named ebola_analysis.\n\nThe RStudio Project you have now created is just a folder on a virtual computer, which has a .Rproj file within it (and maybe a .RHistory file). You should be able to see this .Rproj file in the Files pane of RStudio:\n\n\n\n\n\n\n\nKey Point\n\n\n\nThe .RProj file is what turns a regular computer folder into an “RStudio Project”.\n\n\n\n\n5.3.2 On a local computer\nIf you are on a local computer, open RStudio, then on the RStudio menu, go to File &gt; New Project. Your options may look a little different from the screenshots below depending on your operating system.\n\nChoose “New directory”\n\nThen choose “New Project”:\n\nYou can call your Project something like “ebola_analysis” and make it a “subdirectory” of a folder that is easy to find, such as your desktop. (The phrase “Create project as subdirectory of” sounds scary, but it’s not; RStudio is simply asking: “where should I put the project folder”?)\n\nThe RStudio Project you have created is just a folder with a .Rproj file within it (and maybe a .RHistory file). You should be able to see this .Rproj file in the Files pane of RStudio:\n\n\n\n\n\n\n\nKey Point\n\n\n\nClick on the .Rproj file to open your project\nThe .RProj file is what turns a regular computer folder into an “RStudio Project”.\nFrom now on, to open your project, you should double click on this .RProj file from your computer’s Finder/File Explorer.\nOn Windows, here is an example of what a .Rproj file will look like from the File Explorer:\n\nOn macOS, here is an example of what a .Rproj file will look like from Finder:\n\n\n\nNote also that there is a header at the top right of RStudio window that tells you which Project you currently have open. Clicking on this gives you some additional Project options. You can create a new project, close a project and open recent projects, among other options."
  },
  {
    "objectID": "foundations_ls05_projects.html#creating-project-subfolders",
    "href": "foundations_ls05_projects.html#creating-project-subfolders",
    "title": "5  RStudio projects",
    "section": "5.4 Creating Project subfolders",
    "text": "5.4 Creating Project subfolders\nData analysis projects usually have at least three sub-folders: one for data, another for scripts, and a third for outputs, as seen below:\n\nLet’s look at the sub-folders one by one:\n\ndata: This contains the source (raw) data files that you will use in the analysis. These could be CSV or Excel files, for example.\nscripts: This sub-folder is where you keep your R scripts. You can also save RMarkdown files in this folder. (You will learn about RMarkdown files soon.)\noutputs: Here, you save the outputs of your analysis, like plots and summary tables. These outputs should be disposable and reproducible. That is, you should be able to regenerate the outputs by running the code in your scripts. You will understand this better soon.\n\n\nNow go ahead and create these three sub-folders, “data”, “scripts” and “outputs”. within your RStudio Project folder. You should use the “New Folder” button on the RStudio Files pane to do this:"
  },
  {
    "objectID": "foundations_ls05_projects.html#adding-a-dataset-to-the-data-folder",
    "href": "foundations_ls05_projects.html#adding-a-dataset-to-the-data-folder",
    "title": "5  RStudio projects",
    "section": "5.5 Adding a dataset to the “data” folder",
    "text": "5.5 Adding a dataset to the “data” folder\nNext, you should move the Ebola dataset you downloaded in the previous lesson to the newly-created “data” sub-folder (you can re-download that dataset at bit.ly/ebola-data if you can’t find where you stored it).\nThe procedure for moving this dataset to the “data” folder is different for RStudio Cloud users and those using a local computer. Jump to the section that is relevant for you.\n\n5.5.1 On RStudio Cloud\nIf you are on RStudio Cloud, adding the dataset to your “data” folder is straightfoward. Simply navigate to the folder within the Files pane, then click the “Upload” button:\n\nThis will bring up a dialog box where you can select the file for upload.\n\n\n5.5.2 On a local computer\nOn a local computer, this step has to be done with your computer’s File Explorer/Finder.\n\nFirst, locate the Project folder with your computer’s File Explorer/Finder. If you’re having trouble locating this, RStudio can help: go to the “Files” tab, click on “More” (the gear icon), then click “Show Folder in New Window”.\n\nThis will bring you to the Project folder in your computer’s File Explorer/Finder.\nNow, move the Ebola dataset you downloaded in the previous lesson to the newly-created “data” sub-folder.\nHere is what moving the file might look like on macOS:"
  },
  {
    "objectID": "foundations_ls05_projects.html#creating-a-script-in-the-scripts-folder",
    "href": "foundations_ls05_projects.html#creating-a-script-in-the-scripts-folder",
    "title": "5  RStudio projects",
    "section": "5.6 Creating a script in the “scripts” folder",
    "text": "5.6 Creating a script in the “scripts” folder\nNext, create and save a new R script within the “scripts” folder. You can call this “main_analysis” or something similar. To create a new R script within a folder, first navigate to that folder in the Files pane, then click the “New Blank File” button and select “R script” in the dropdown:\n\n\n\n\n\n\n\nSide Note\n\n\n\nNote that this is different from what you have done so far when creating a new script (before, you used the menu option, File &gt; New File &gt; New Script). The old way is still valid; but this “New Blank File” button will probably be faster for you.\n\n\n\nGreat work so far! Now your Project folder should have the structure shown below, with the “ebola_sierra_leone.csv” dataset in the “data” folder and the “main_analysis.R” script (still empty) in the “scripts” folder:\n\nThis is a process you should go through at the start of every data analysis project: set up an RStudio Project, create the needed sub-folders, and put your datasets and scripts in the appropriate sub-folders. It can be a bit painful, but it will pay off in the long run.\n\nThe rest of this lesson will teach you how to conduct your analysis in the context of this folder setup. At the end, you will have an overall flow of data and outputs that resembles the diagram below:\n\n\n\nFigure: Data flow in an R project. Scripts in the “scripts” folder import data from “data” folder and export data and plots to the “outputs” folder\n\n\nYou should refer back to this diagram as you proceed through the sections below to help orient yourself."
  },
  {
    "objectID": "foundations_ls05_projects.html#importing-data-from-the-data-folder",
    "href": "foundations_ls05_projects.html#importing-data-from-the-data-folder",
    "title": "5  RStudio projects",
    "section": "5.7 Importing data from the “data” folder",
    "text": "5.7 Importing data from the “data” folder\nWe will use the code snippet below to demonstrate the flow of data through a Project. Copy and paste this snippet into your “main_analysis.R” script (but don’t run it yet). The code replicates parts of the analysis from the data dive lesson.\n\n## Ebola Sierra Leone analysis\n## John Sample-Name Doe\n## 2024-01-01\n\n\n## Load packages ----\nif(!require(pacman)) install.packages(\"pacman\")\npacman::p_load(\n  tidyverse,\n  janitor,\n  inspectdf,\n  here # new package we will use soon\n)\n\n\n## Load data ----\nebola_sierra_leone &lt;- read_csv(\"\") # DATA PENDING! WE WILL UPDATE THIS BELOW.\n\n## Cases by district ----\ndistrict_tab &lt;- tabyl(ebola_sierra_leone, district)\ndistrict_tab\n\n## Visualize categorical variables ----\ncateg_vars_plot&lt;- show_plot(inspect_cat(ebola_sierra_leone))\ncateg_vars_plot\n\n## Visualize numeric variables ----\nnum_vars_plot &lt;- show_plot(inspect_num(ebola_sierra_leone))\nnum_vars_plot\n\nFirst run the “Load packages” section to install and/or load any needed packages.\nThen proceed to the “Load data” section, which looks like this:\n\n## Load data ----\nebola_sierra_leone &lt;- read_csv(\"\") # DATA PENDING! WE WILL UPDATE THIS BELOW.\n\nHere you want to import the Ebola dataset that you previously placed inside the Project’s “data” folder. To do this, you need to supply the file path of that dataset as the first argument of read_csv().\nBecause you are using an RStudio Project, this path can be obtained very easily: place your cursor inside the quotation marks within the read_csv() function, and press the Tab key on your keyboard. You should see a list of the sub-folders available in your Project. Something like this:\n\nClick on the “data” folder, then press Tab again. Since you only have one file in the “data” folder, RStudio should automatically fill in it’s name. You should now see:\n\nebola_sierra_leone &lt;- read_csv(\"data/ebola_sierra_leone.csv\")\n\nWonderful! Run this line of code now to import the data.\nIf this is successful, you should see the data appear in the Environment tab of RStudio:\n\n\n\n\n\n\n\nKey Point\n\n\n\nRelative paths\nThe path you have used here, “data/ebola_sierra_leone.csv”, is called a relative path, because it is relative to the root (or the base) of your Project.\nHow does R know where the root of your Project is? That’s where the .RProj file comes in. This file, which lives in the “ebola_analysis” folder tells R “here! Here! I am in the ‘ebola_analysis’ folder so this must be the root!”. Thus, you only need to specify path components that are deeper than this root.\nRStudio Projects, and the relative paths they allow you to use, are important for reproducibility. Projects that use relative paths can be run on anyone’s computer, and the importing and exporting code should work without any hiccups. This means that you can send someone an RStudio Project folder and the code should run on their machine just as it ran on yours!\nThis would not be the case if you were to use an absolute path, something like “~/Desktop/my_data_analysis/learning_r/ebola_sierra_leone.csv”, in your script. Absolute paths give the full address of a file, and will not usually work on someone else’s computer, where files and folders will be arranged differently.\n\n\n\n\n\n\n\n\nRStudio Cloud\n\n\n\nNote that if you are using RStudio Cloud, you are forced to use relative paths, because you cannot access the general file system of the virtual computer; you can only work within specific Project folders.\n\n\n\n5.7.1 Using here::here()\nAs you have now seen, RStudio Projects simplify the data import process and improve the reproducibility of your analysis, primarily because they allow you to use relative paths.\nBut there is one more step we recommend when using relative paths: rather than leave your path naked, wrap it in the here() function from the {here} package.\nSo, in the data import section of your script, change read_csv()’s input from \"data/ebola_sierra_leone.csv\" to here(\"data/ebola_sierra_leone.csv\"):\n\nebola_sierra_leone &lt;- read_csv(here(\"data/ebola_sierra_leone.csv\"))\n\nWhat is the point of wrapping the path in here()? Well, technically, this is no real point in doing this in an R script; the importing code works fine without it. But it will be necessary when you start using RMarkdown scripts (which you will soon be introduced to), because paths not wrapped in here() are problematic in the RMarkdown context.\nSo to keep things consistent, we always recommend you use here() when pointing to paths, whether in an R script or an RMarkdown script"
  },
  {
    "objectID": "foundations_ls05_projects.html#exporting-data-to-the-outputs-folder",
    "href": "foundations_ls05_projects.html#exporting-data-to-the-outputs-folder",
    "title": "5  RStudio projects",
    "section": "5.8 Exporting data to the “outputs” folder",
    "text": "5.8 Exporting data to the “outputs” folder\nImporting data is not the only benefit of RStudio Projects; data export is also streamlined when you use Projects. Let’s look at this now.\nIn the “Cases by district” section of your script, you should have:\n\n## Cases by district ----\ndistrict_tab &lt;- tabyl(ebola_sierra_leone, district)\ndistrict_tab\n\nRun this code now; you should get the following tabular output:\n\n\n      district   n percent\n            Bo   2   0.010\n      Kailahun 155   0.775\n        Kambia   1   0.005\n        Kenema  34   0.170\n          Kono   2   0.010\n     Port Loko   2   0.010\n Western Urban   4   0.020\n\n\nNow, imagine that you want to export this table as a CSV. It would be nice if there was a specific folder designated for such exports. Well, there is! It’s the “outputs” folder you created earlier. Let’s export your table there now. Type out the code below (but don’t run it yet):\n\nwrite_csv(x = district_tab, file = \"\")\n\nWith the write_csv() function, you are going to “write” (or “save”) the district_tab table as a CSV file.\nThe x argument of write_csv() takes in the object to be saved (in this case district_tab). And the file argument takes in the target file path. This target file path can be a simple relative path: “outputs/district_table.csv”. (And, as mentioned before, we should wrap the path in here().) Type this up and run it now:\n\nwrite_csv(x = district_tab, file = here(\"outputs/district_table.csv\"))\n\nThe path “outputs/district_table.csv” tells write_csv() to save the plot as a CSV file named “districts_table” in the “outputs” folder of the Project.\n\n\n\n\n\n\nSide Note\n\n\n\nYou can replace “district_table.csv” with any other appropriate name, for example “freq table across districts.csv”:\n\nwrite_csv(x = district_tab, file = here(\"outputs/freq table across districts.csv\"))\n\n\n\n\nGreat work! Now, if you go to the Files tab and navigate to the outputs folder of your Project, you should see this newly created file:\n\nYou can click on the file to view it within RStudio as a raw CSV:\n\nThis should bring up an RStudio viewer window:\n\nIf you instead want to view the CSV in Microsoft Excel, you can navigate to the same file in your computer’s Finder/File Explorer and double-click on it from there.\n\n\n\n\n\n\nReminder\n\n\n\nTo locate your Project folder in your computer’s Finder/File Explorer, go the “Files” tab, click on the gear icon, then click “Show Folder in New Window”.\n\n\n\n\n\n\n\n\n\nRStudio Cloud\n\n\n\nIf you are on RStudio cloud, then you won’t be able to view the CSV in Microsoft Excel until you have “exported” it. Use the “Export” menu option in the Files tab. If this is not immediately visible, click on the gear icon to bring up “More” options, then scroll through to find the “Export” option.\n\n\n\n5.8.1 Overwriting data\nIf you need to update the output CSV, you can simply rerun the write_csv() function with the updated data object.\nTo test this, replace the “Cases by district” section of your script with the following code. It uses the arrange() function to arrange the table in order of the number of cases, n:\n\n## Cases by district ----\ndistrict_tab &lt;- tabyl(ebola_sierra_leone, district)\ndistrict_tab_arranged &lt;- arrange(district_tab, -n)\ndistrict_tab_arranged\n\n( -n means “sort in descending order of the n variable”; we will introduce you to the arrange function properly later on.)\nThe output should be:\n\n\n      district   n percent\n      Kailahun 155   0.775\n        Kenema  34   0.170\n Western Urban   4   0.020\n            Bo   2   0.010\n          Kono   2   0.010\n     Port Loko   2   0.010\n        Kambia   1   0.005\n\n\nYou can now overwrite the old “district_table.csv” file by re-running the write_csv function with the district_tab object:\n\nwrite_csv(x = district_tab_arranged, file = here(\"outputs/district_table.csv\"))\n\nTo verify that the dataset was actually updated, observe the “Modified” time stamp in the RStudio Files pane:"
  },
  {
    "objectID": "foundations_ls05_projects.html#exporting-plots-to-the-outputs-folder",
    "href": "foundations_ls05_projects.html#exporting-plots-to-the-outputs-folder",
    "title": "5  RStudio projects",
    "section": "5.9 Exporting plots to the “outputs” folder",
    "text": "5.9 Exporting plots to the “outputs” folder\nFinally, let’s look at plot exporting in the context of an RStudio Project.\nIn the “Visualize categorical variables” section of your script, you should have:\n\n## Visualize categorical variables ----\ncateg_vars_plot&lt;- show_plot(inspect_cat(ebola_sierra_leone))\ncateg_vars_plot\n\nRunning these code lines should give you this output:\n\n\n\n\n\nBelow these lines, type up the ggsave() command below (but don’t run it yet):\n\nggsave(filename = \"\", plot = categ_vars_plot)\n\nThis command uses the ggsave() function to export the categ_vars_plot figure. The plot argument of ggsave() takes in the object to be saved (in this case categ_vars_plot), and the filename argument takes in the target file path for the plot.\nAs you saw when exporting data, this target file path is quite simple because you are working in an RStudio Project. In this case, you have:\n\nggsave(filename = \"outputs/categorical_plot.png\", plot = categ_vars_plot)\n\nRun this ggsave() command now. The path “outputs/categorical_plot.png” tells ggsave() to save the plot as a PNG file named “categorical_plot” in the “outputs” folder of the Project.\nTo see this newly-saved plot, navigate to the Files tab. You can click on it to open it with your computer’s default image viewer:\n\nAlso note that the the ggsave() function lets you save plots to multiple image formats. For example, you could instead write:\n\nggsave(filename = \"outputs/categorical_plot.pdf\", plot = categ_vars_plot)\n\nto save the plot as a PDF. Run ?ggsave to see what other formats are possible.\n\nNow let’s export the second plot, the numerical summary. In the section of your script called “Visualize numeric variables”, you should have:\n\n## Visualize numeric variables ----\nnum_vars_plot &lt;- show_plot(inspect_num(ebola_sierra_leone))\nnum_vars_plot\n\nRunning these code lines should give you this output:\n\n\n\n\n\nTo export this plot, type up and run the following code:\n\nggsave(filename = \"outputs/numeric_plot.png\", plot = num_vars_plot)\n\nWonderful!"
  },
  {
    "objectID": "foundations_ls05_projects.html#sharing-a-project",
    "href": "foundations_ls05_projects.html#sharing-a-project",
    "title": "5  RStudio projects",
    "section": "5.10 Sharing a Project",
    "text": "5.10 Sharing a Project\nProjects are also great for sharing your analysis with collaborators.\nYou can zip up your Project folder and send it to a colleague through email or through a file sharing service like Dropbox. The colleague can then unzip the folder, click on the .Rproj file to open the Project in RStudio, and re-do and edit all your analysis steps.\nThis is a decent setup, but sending projects back and forth may not be ideal for long-term collaboration. So experienced analysts use a technology called git to collaborate on projects. But this topic is a bit too advanced for this course; we will cover it in detail in a future course. If you are impatient, you can check out this book chapter: https://intro2r.com/github_r.html"
  },
  {
    "objectID": "foundations_ls05_projects.html#wrapping-up",
    "href": "foundations_ls05_projects.html#wrapping-up",
    "title": "5  RStudio projects",
    "section": "5.11 Wrapping up",
    "text": "5.11 Wrapping up\nCongratulations! You now know how to set up and use RStudio Projects!\nHopefully you see the value of organizing your analysis scripts, data and outputs in this way. Projects are a coherent way to structure your analyses, and make it easy to revisit, revise and share your work. They will be the foundation for much of your work as a data analyst going forward.\nThat’s it for now. See you in the next lesson."
  },
  {
    "objectID": "foundations_ls05_projects.html#references",
    "href": "foundations_ls05_projects.html#references",
    "title": "5  RStudio projects",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nWickham, H., & Grolemund, G. (n.d.). R for data science. 8 Workflow: projects | R for Data Science. Retrieved May 31, 2022, from https://r4ds.had.co.nz/workflow-projects.html\n\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#introduction",
    "href": "foundations_ls06_rmarkdown.html#introduction",
    "title": "6  R Markdown",
    "section": "6.1 Introduction",
    "text": "6.1 Introduction\nThe {rmarkdown} package enables you to generate dynamic documents by combining formatted text and results produced by R code. With R Markdown, you can create documents in various formats such as HTML, PDF, Word, and many others, making it a versatile tool for exporting, communicating, and sharing your analysis results.\nThis document itself was created using R Markdown. While there is an entire book dedicated to R Markdown, we will cover some of the essential concepts here.\nNote that working with R Markdown requires using a lot of the graphical user interface (GUI) tools in RStudio. Because of this, the written notes in this lesson will not be as detailed as in other lessons. For deeper understanding, we recommend that you follow along with the accompanying video tutorial."
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#learning-objectives",
    "href": "foundations_ls06_rmarkdown.html#learning-objectives",
    "title": "6  R Markdown",
    "section": "Learning objectives",
    "text": "Learning objectives\n\nCreate and knit an R Markdown document that includes code and free text\nOutput documents in multiple formats, including HTML, PDF, Word, PowerPoint, and flexdashboards\nUnderstand basic Markdown syntax\nUse R chunk options, such as eval, echo, and message\nKnow the syntax for inline R code\nRecognize useful packages for table formatting in R Markdown\nUnderstand how to use the {here} package to set the project folder as the working directory in R Markdown files"
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#project-setup",
    "href": "foundations_ls06_rmarkdown.html#project-setup",
    "title": "6  R Markdown",
    "section": "6.2 Project setup",
    "text": "6.2 Project setup\nTo begin, open RStudio and click on the File menu. Select New Project… and then click on New Directory. Choose a name for your project and specify the directory where you want to store it. Remember the location for future reference. Once you have filled out these fields, click Create Project.\nNext, let’s set up some folders within the project. In the Files pane, click on New Folder and name it “data”. Click OK. This folder will store the project’s data. Create another folder called “rmd” to store your R Markdown documents."
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#create-a-new-document",
    "href": "foundations_ls06_rmarkdown.html#create-a-new-document",
    "title": "6  R Markdown",
    "section": "6.3 Create a new document",
    "text": "6.3 Create a new document\nAn R Markdown document is a simple text file with the .Rmd extension.\nTo create a new R Markdown document in RStudio, go to the File menu, choose New file, and then select R Markdown…. If prompted, install the necessary packages. Once RStudio has the required packages, the following dialog box will appear:\n\nFor now, keep the default values and click OK. A file with sample content will be displayed.\nExperiment with editing some of the text in the file. Notice that it consists of free text and code sections.\nSave your file using Cmd/Ctrl + S, and make sure to give it the “.Rmd” extension. For example, “ebola_analysis.Rmd”. Save it in the “rmd” folder you created earlier.\nTo render the document, click on the “knit” button at the top right:\n\nThis will generate an HTML output that looks like this:\n\nThe rendered file will be stored in the same directory as your Rmd file, with the same name but ending in “.html” instead of “.rmd”.\n\n\n\n\n\n\nVocab\n\n\n\nHTML stands for Hypertext Markup Language and is the standard format used for most documents on the web."
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#r-markdown-header-yaml",
    "href": "foundations_ls06_rmarkdown.html#r-markdown-header-yaml",
    "title": "6  R Markdown",
    "section": "6.4 R Markdown Header (YAML)",
    "text": "6.4 R Markdown Header (YAML)\nLet’s return to the rest of the Rmd file and examine it part by part.\nThe first part of the document is its header, also known as “YAML” (Yet Another Markup Language). The name is intended to be humorous.\n---\ntitle: \"Untitled\"\noutput: html_document\ndate: \"2022-10-09\"\n---\nThe YAML header must be located at the very beginning of the document, delimited by three dashes (---) before and after.\nThis header contains the document’s metadata, such as its title, author, date, and various options that allow you to configure and customize the entire document and its rendering. For example, the line output: html_document specifies that the generated document should be in HTML format.\nYou can change the html_document text to experiment with other formats.\n\n6.4.1 Word Document\nIf you set the output to “word_document”, and click to tknit the file, the rendered document will look like this:\n\n\n\nImage of the R Markdown document open in the Microsoft Word program\n\n\nA “.docx” version of your document will be created in the “rmd” folder.\n\n\n6.4.2 PowerPoint Document\nWhen the output is set to “powerpoint_document”, the result will be:\n\n\n\nImage of the R Markdown document open in the Microsoft PowerPoint program\n\n\n\n\n6.4.3 PDF Document\nIf you change the output setting to “pdf_document”, you can obtain the same document in PDF format (you may be prompted to install tinytex on your computer, see below):\n\n\n\n\n\n\n\nKey Point\n\n\n\nFor PDF generation, you must have a working LaTeX installation on your system. If not, Yihui Xie’s tinytex extension aims to simplify the installation of a minimal LaTeX distribution regardless of your machine’s operating system.\nTo use it, first install the extension with install.packages('tinytex'), then run the following command in the console (expect a download of about 200MB): tinytex::install_tinytex(). More information is available on the tinytex website.\n\n\n\n\n6.4.4 Prettydoc\nTo try the “prettydoc” format, type install.packages('prettydoc') into the console and press Enter. The output format for prettydoc is slightly different from the previous three. You need to use prettydoc::html_pretty in the output section. When you knit a prettydoc, you should see something like this:\n\n\n\nImage of the R Markdown document as a prettydoc\n\n\n\n\n6.4.5 Flexdashboard\nYou can even create a simple dashboard format. First, run install.packages('flexdashboard'). Then, set the output to flexdashboard::flex_dashboard and knit. The result will be similar to the following:\n\n\n\nImage of the R Markdown document as a flexdashboard\n\n\nNote that it does not yet have tabs. To create tabs in a flexdashboard, change some of your double hashtags ## to single hashtags #. This will modify the header style for those sections, and flexdashboard will render those headers as tabs.\nMany other formats are available, and we encourage you to explore them on your own!"
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#visual-vs-source-mode",
    "href": "foundations_ls06_rmarkdown.html#visual-vs-source-mode",
    "title": "6  R Markdown",
    "section": "6.5 Visual vs Source mode",
    "text": "6.5 Visual vs Source mode\nRmarkdown documents can be edited in either a “Source” mode or a “Visual” mode.\nYou can switch into visual mode for a given document using the toolbars. There is a pair of buttons to toggle between the modes:\n\nWhat’s the difference between these two modes?\nIn source mode, you see the raw markdown syntax.\n\n\n\n\n\n\nVocab\n\n\n\nMarkdown is a simple set of conventions for adding formatting to plain text. For example, to italicize text, you wrap it in asterisks *text here*, and to start a new header, you use the pound sign #. We will learn these in detail below.\n\n\nIn visual mode, you see a Microsoft Word-like view with a toolbar for easy formatting.\nThis means you don’t have to remember the syntax for markdown elements. For example, if you want to make a section of text bold, you can simply highlight that piece of text and click on the bold button in the toolbar.\nWhile visual mode is much easier to use, we will teach you markdown syntax here for three reasons:\n\nVisual mode can sometimes be buggy, and to debug this, you’ll need to switch to source mode.\nUnderstanding markdown syntax is useful outside of Rmarkdown.\nVisual mode is not available in RStudio’s collaborative mode, which you may want to use."
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#markdown-syntax",
    "href": "foundations_ls06_rmarkdown.html#markdown-syntax",
    "title": "6  R Markdown",
    "section": "6.6 Markdown syntax",
    "text": "6.6 Markdown syntax\nIn the “Help” tab of the top RStudio menu, if you look up “Markdown Quick Reference”, you will find a wide variety of RMD options available.\nYou can define titles of different levels by starting a line with one or more #:\n## Level 1 title\n### Level 2 Title\n#### Level 3 Title\nThe body of the document consists of text that follows the Markdown syntax. A Markdown file is a text file that contains lightweight markup to help set heading levels or format text. For example, the following text:\nThis is text with *italics* and **bold**.\n\nYou can define bulleted lists:\n\n- first element\n- second element\nWill generate the following formatted text:\n\nThis is text with italics and bold.\nYou can define bulleted lists:\n\nfirst element\nsecond element\n\n\nNote that you need spaces before and after lists, as well as keeping the listed items on separate lines. Otherwise, they will all crunch together rather than making a list.\nWe see that words placed between asterisks are italicized, and lines that begin with a dash are transformed into a bulleted list.\nThe Markdown syntax allows for other formatting, such as the ability to insert links or images. For example, the following code:\n[Example Link](https://example.com)\n… will give the following link:\n\nExample Link\n\nWe can also embed images. If you’re in Source mode, type:\n![what you want the subtitle to say](images/picture_name.jpg), replacing “what you want the subtitle to say” (it can also be blank), “images” with the name of the image folder in your project, and “picture_name.jpg” with the name of the image you want to use. In Visual mode, you can open the folder that holds your image on your computer and drag-and-drop the image from the folder onto the page you’re building. Alternatively, place the cursor where you want the image, click the button above marked with a “picture” icon, follow the prompts, and insert your image where the cursor is. This will also create an “images” folder in your project (if it doesn’t already exist) and put the image file into the “images” folder.\nWhen titles have been defined, clicking on the Show document outline icon on the far right of the toolbar associated with the R Markdown file will display a table of contents automatically generated from the titles, allowing for easy navigation within the document:\n\n\n\nDynamic TOC\n\n\n\n6.6.1 Customizing the generated document\nThe generated document can be customized by modifying options in the document’s preamble. RStudio offers a graphical interface to change these options more easily. To access it, click on the gear icon to the right of the Knit button and choose Output Options…\n\n\n\nR Markdown Output Options\n\n\nA dialog box will appear, allowing you to select the desired output format and various options depending on the format:\n\n\n\nR Markdown Output Options Dialog\n\n\nFor example, with the HTML format, the General tab allows you to specify if you want a table of contents, its depth, the themes to apply for the document and the syntax highlighting of the R blocks, etc. The Figures tab allows you to change the default dimensions of the generated graphics.\nWhen you change options, RStudio will modify the preamble of your document. For instance, if you choose to show a table of contents and change the syntax highlighting theme, your header will become something like:\n---\ntitle: \"R Markdown Review\"\noutput:\n   html_document:\n     highlight: kate\n     toc: yes\n---\nYou can also modify the options directly by editing the preamble.\nNote that it is possible to specify different options depending on the format, for example:\n---\ntitle: \"R Markdown Review\"\noutput:\n  html_document:\n    highlight: kate\n    toc: yes\n  pdf_document:\n    fig_caption: yes\n    highlight: kate\n---\nThe complete list of possible options is available on the official documentation site (which is very comprehensive and well-made) and on the cheat sheet and reference guide, accessible from RStudio via the Help menu, then Cheatsheets."
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#r-code-chunks",
    "href": "foundations_ls06_rmarkdown.html#r-code-chunks",
    "title": "6  R Markdown",
    "section": "6.7 R code chunks",
    "text": "6.7 R code chunks\nIn addition to free text in Markdown format, an R Markdown document contains, as its name suggests, R code. This is included in blocks (chunks) written the following way in Source mode:\n```{r}\nr_code &lt;- 2+2\n```\nWhich will produce the following in Visual mode:\n\nr_code &lt;- 2+2\n\nAs this sequence of characters is not very easy to enter, you can use the Insert menu of RStudio and choose R[^3], or use the keyboard shortcut Command+Option+i on Mac or Ctrl+Alt+i on Windows.\nNote that it is possible to use other languages in code chunks.\n\n\n\nCode block insertion menu\n\n\nIn RStudio blocks of R code are usually displayed with a slightly different background color to distinguish them from the rest of the document.\nWhen your cursor is in a block, you can enter the R code you want and execute it with Command + Enter. You can also execute all the code contained in a block by clicking on the green “play” button at the top right of the code chunk.\n\n6.7.1 Chunk output inline vs in condole\nIn RStudio, by default, the results of a block of code (text, table or graphic) are displayed directly in the document editing window, allowing them to be easily viewed and kept for the duration of the session.\nThis behavior can be changed by clicking the gear icon on the toolbar and choosing Chunk Output in Console.\n\n\n6.7.2 R code chunk options\nIt is also possible to pass options to each block of R code to modify its behavior.\nRemember that a block of code looks like this:\n\n\n```{r}\nx &lt;- 1:5\n\n\nThe options of a code block are to be placed inside the braces {r}, with a comma separating each option.\n\n\n6.7.3 Block name\nThe first possibility is to give a name to the block. This is indicated directly after the r:\n{r block_name}\nIt is not mandatory to name a block, but it can be useful in the event of a compilation error, to identify the block that caused the problem. Be careful, you cannot have two blocks with the same name.\n\n\n6.7.4 Options\nIn addition to a name, a block can be passed a series of options in the form option=value. Here is an example of a block with a name and options:\n\n\n```{r blockName, echo = FALSE, warning = TRUE}\nx &lt;- 1:5\n\n\nAnd an example of an unnamed block with options:\n\n\n```{r echo = FALSE, warning = FALSE}\nx &lt;- 1:5\n\n\nOne of the useful options is the echo option. By default echo is TRUE, and the block of R code is inserted into the generated document, like this:\n\nx &lt;- 1:5\nprint(x)\n\n[1] 1 2 3 4 5\n\n\nBut if we set the echo=FALSE option, then the R code is no longer inserted into the document, and only the result is visible:\n\n\n[1] 1 2 3 4 5\n\n\nHere is a list of some of the available options:\n\n\n\n\n\n\n\n\nOption\nValues\nDescription\n\n\n\n\necho\nTRUE/FALSE\nShow (or hide) this R code chunk in the resulting knitted document\n\n\neval\nTRUE/FALSE\nRun (or not) the code in this code chunk in the resulting knitted document\n\n\ninclude\nTRUE/FALSE\nCombines the options “echo and eval”; either show and run, or hide and don’t run\n\n\nmessage\nTRUE/FALSE\nShow (or hide) any system messages generated by running this code chunk in the resulting knitted document\n\n\nwarning\nTRUE/FALSE\nShow (or hide) any warnings generated by running this code chunk in the resulting knitted document\n\n\n\nThere are many other options described in particular in R Markdown reference guide{target = “_blank”} (PDF in English).\n\n\n6.7.5 Change options\nIt is possible to modify the options manually by editing the header of the code block, but you can also use a small graphical interface offered by RStudio. To do this, simply click on the gear icon located to the right of the header line of each block:\n\n\n\nCode Block Options Menu\n\n\nYou can then modify the most common options, and click on Apply to apply them.\n\n\n6.7.6 Global Options\nYou may want to apply an option to all the blocks in a document. For example, one may wish by default not to display the R code of each block in the final document.\nYou can set an option globally using the knitr::opts_chunk$set() function. For example, inserting knitr::opts_chunk$set(echo = FALSE) into a code block will set the echo = FALSE option to default for all subsequent blocks.\nIn general, we place all these global modifications in a special block called setup and which is the first block of the document:\n\n\n```{r, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE)"
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#inline-code",
    "href": "foundations_ls06_rmarkdown.html#inline-code",
    "title": "6  R Markdown",
    "section": "6.8 Inline Code",
    "text": "6.8 Inline Code\nIt is also possible to write code chunks embedded in the text. If you go to Source mode and type\n“The sum of a pair of 2s is ` r 2+2 `”\nand then knit the RMD, the resulting document will evaluate the r code between the backticks. Note that you have to include the “r” at the beginning of your inline code chunk to get it to recognize it as R code.\nYou could also pass variables around your document just like in a regular R program. For example, on one line you could run,\n``` {r} max_height &lt;- max(women$height) ```\n“The maximum height in the women data set is ` r max_height ` .”\nThe advantages of such a system are numerous:\n\na single document can show your entire analysis workflow, since the code, results and text explanations are included\nthe document can be very easily regenerated and updated, for example if the source data has been modified.\nthe variety of output formats (HTML, PDF, Word, slides, dashboards, etc.) makes it easy to present your work to others."
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#display-tables",
    "href": "foundations_ls06_rmarkdown.html#display-tables",
    "title": "6  R Markdown",
    "section": "6.9 Display tables",
    "text": "6.9 Display tables\nThere are a number of ways for R Markdown Documents to show data tables. To start, you can see how our RMD displays a table with no formatting:\n\nwomen\n\n   height weight\n1      58    115\n2      59    117\n3      60    120\n4      61    123\n5      62    126\n6      63    129\n7      64    132\n8      65    135\n9      66    139\n10     67    142\n11     68    146\n12     69    150\n13     70    154\n14     71    159\n15     72    164\n\n\nIt looks pretty basic. Next, to follow along you’ll want to load the following packages:\n\npacman::p_load(flextable, gt, reactable)\n\nFlextable is better for showing simple tables supported by many formats. GT is better for showing complex tables in HTML documents. Reactable is better for showing very large tables in HTML by giving your audience the option to scroll through the tables.\n\n\"This is a flextable\"\n\n[1] \"This is a flextable\"\n\nflextable::flextable(women)\n\n\nheightweight581155911760120611236212663129641326513566139671426814669150701547115972164\n\n\n\n\"This is a GT table\"\n\n[1] \"This is a GT table\"\n\ngt::gt(women)\n\n\n\n\n\n  \n    \n    \n      height\n      weight\n    \n  \n  \n    58\n115\n    59\n117\n    60\n120\n    61\n123\n    62\n126\n    63\n129\n    64\n132\n    65\n135\n    66\n139\n    67\n142\n    68\n146\n    69\n150\n    70\n154\n    71\n159\n    72\n164\n  \n  \n  \n\n\n\n\n\n\"This is a reactable\"\n\n[1] \"This is a reactable\"\n\nreactable::reactable(women)\n\n\n\n\n\n\nYou can see many other types of table formats people have created at https://www.rstudio.com/blog/rstudio-table-contest-2022/"
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#document-templates",
    "href": "foundations_ls06_rmarkdown.html#document-templates",
    "title": "6  R Markdown",
    "section": "6.10 Document Templates",
    "text": "6.10 Document Templates\nWe have seen here the production of “classic” documents, but R Markdown allows you to create many other things.\nThe extension’s documentation site offers a gallery of the different possible outputs. You can create slides, websites or even entire books, like this document.\n\n6.10.1 Slides\nAn interesting use is the creation of slideshows for presentations in the form of slides. The principle remains the same: we mix text in Markdown format and R code, and R Markdown transforms everything into presentations in HTML or PDF format. In general, the different slides are separated at certain heading levels.\nSome slide templates are included with R Markdown, including:\n\nioslides and Slidy for HTML presentations\nbeamer for PDF presentations via LaTeX\n\nWhen you create a new document in RStudio, these templates are accessible via the Presentation entry:\n\n\n\nCreate an R Markdown presentation\n\n\nOther extensions, which must be installed separately, also allow slideshows in various formats. These include in particular:\n\nxaringan for HTML presentations based on remark.js\nrevealjs for HTML presentations based on reveal.js\nrmdshower for HTML slideshows based on shower\n\nOnce the extension is installed, it generally offers a starting template when creating a new document in RStudio. These are accessible from the From Template entry.\n\n\n\nCreate a presentation from a template\n\n\n\n\n6.10.2 Templates\nThere are also different templates allowing you to change the format and presentation of the generated documents. A list of these formats and their associated documentation can be accessed from the formats documentation page.\nNote in particular:\n\nthe Distill format, suitable for scientific or technical publications on the Web\nthe Tufte Handouts format which allows you to produce PDF or HTML documents in a format similar to that used by Edward Tufte for some of his publications\nrticles, package that offers LaTeX templates for several scientific journals\n\nFinally, the rmdformats extension offers several HTML templates particularly suitable for long documents.\nAgain, most of the time, these document templates offer a starting template when creating a new document in RStudio (entry From Template):\n\n\n\nCreate a document from a template"
  },
  {
    "objectID": "foundations_ls06_rmarkdown.html#resources",
    "href": "foundations_ls06_rmarkdown.html#resources",
    "title": "6  R Markdown",
    "section": "6.11 Resources",
    "text": "6.11 Resources\nBelow are some resources to help you learn more about R Markdown:\nThe book R for data science, available online, contains a chapter dedicated to R Markdown.\nThe extension’s official site contains very complete documentation, both for beginners and for advanced users.\nFinally, the RStudio help (Help menu then Cheatsheets) provides access to two summary documents: a synthetic “cheat sheet” (R Markdown Cheat Sheet) and a more complete “reference guide” ( R Markdown Reference Guide)."
  },
  {
    "objectID": "foundations_ls07_data_structures.html#intros",
    "href": "foundations_ls07_data_structures.html#intros",
    "title": "7  Data structures",
    "section": "7.1 Intros",
    "text": "7.1 Intros\nIn this lesson, we’ll take a brief look at data structures in R. Understanding data structures is crucial for data manipulation and analysis. We will start by exploring vectors, the basic data structure in R. Then, we will learn how to combine vectors into data frames, the most common structure for organizing and analyzing data."
  },
  {
    "objectID": "foundations_ls07_data_structures.html#learning-objectives",
    "href": "foundations_ls07_data_structures.html#learning-objectives",
    "title": "7  Data structures",
    "section": "7.2 Learning objectives",
    "text": "7.2 Learning objectives\n\nYou can create vectors with the c() function.\nYou can combine vectors into data frames.\nYou understand the difference between a tibble and a data frame."
  },
  {
    "objectID": "foundations_ls07_data_structures.html#packages",
    "href": "foundations_ls07_data_structures.html#packages",
    "title": "7  Data structures",
    "section": "7.3 Packages",
    "text": "7.3 Packages\nPlease load the packages needed for this lesson with the code below:\n\nif(!require(pacman)) install.packages(\"pacman\")\npacman::p_load(tidyverse)"
  },
  {
    "objectID": "foundations_ls07_data_structures.html#introducing-vectors",
    "href": "foundations_ls07_data_structures.html#introducing-vectors",
    "title": "7  Data structures",
    "section": "7.4 Introducing vectors",
    "text": "7.4 Introducing vectors\nThe most basic data structures in R are vectors. Vectors are a collection of values that all share the same class (e.g., all numeric or all character). It may be helpful to think of a vector as a column in an Excel spreadsheet."
  },
  {
    "objectID": "foundations_ls07_data_structures.html#creating-vectors",
    "href": "foundations_ls07_data_structures.html#creating-vectors",
    "title": "7  Data structures",
    "section": "7.5 Creating vectors",
    "text": "7.5 Creating vectors\nVectors can be created using the c() function, with the components of the vector separated by commas. For example, the code c(1, 2, 3) defines a vector with the elements 1, 2 and 3.\nIn your script, define the following vectors:\n\nage &lt;- c(18, 25, 46)\nsex &lt;- c('M', 'F', 'F')\npositive_test &lt;- c(T, T, F)\nid &lt;- 1:3 # the colon creates a sequence of numbers\n\nYou can also check the classes of these vectors:\n\nclass(age)\n\n[1] \"numeric\"\n\nclass(sex)\n\n[1] \"character\"\n\nclass(positive_test)\n\n[1] \"logical\"\n\n\n\n\n\n\n\n\nPractice\n\n\n\nEach line of code below tries to define a vector with three elements but has a mistake. Fix the mistakes and perform the assignment.\n\nmy_vec_1 &lt;- (1,2,3)\nmy_vec_2 &lt;- c(\"Obi\", \"Chika\" \"Nonso\")\n\n\n\n\n\n\n\n\n\nVocab\n\n\n\nThe individual values within a vector are called components or elements. So the vector c(1, 2, 3) has three components/elements."
  },
  {
    "objectID": "foundations_ls07_data_structures.html#manipulating-vectors",
    "href": "foundations_ls07_data_structures.html#manipulating-vectors",
    "title": "7  Data structures",
    "section": "7.6 Manipulating vectors",
    "text": "7.6 Manipulating vectors\nMany of the functions and operations you have encountered so far in the course can be applied to vectors.\nFor example, we can multiply our age object by 2:\n\nage\n\n[1] 18 25 46\n\nage * 2\n\n[1] 36 50 92\n\n\nNotice that every element in the vector was multiplied by 2.\nOr, below we take the square root of age:\n\nage\n\n[1] 18 25 46\n\nsqrt(age)\n\n[1] 4.242641 5.000000 6.782330\n\n\n\nYou can also can add (numeric) vectors to each other:\n\nage + id\n\n[1] 19 27 49\n\n\nNote that the first element of age is added to the first element of id and the second element of age is added to the second element of id and so on."
  },
  {
    "objectID": "foundations_ls07_data_structures.html#from-vectors-to-data-frames",
    "href": "foundations_ls07_data_structures.html#from-vectors-to-data-frames",
    "title": "7  Data structures",
    "section": "7.7 From vectors to data frames",
    "text": "7.7 From vectors to data frames\nNow that we have a handle on creating vectors, let’s move on to the most commonly used object in R: data frames. A data frame is just a collection of vectors of the same length with some helpful metadata. We can create one using the data.frame() function.\nWe previously created vector variables (id, age, sex and positive_test) for three individuals:\nWe can now use the data.frame() function to combine these into a single tabular structure:\n\ndata_epi &lt;- data.frame(id, age, sex, positive_test)\ndata_epi\n\n  id age sex positive_test\n1  1  18   M          TRUE\n2  2  25   F          TRUE\n3  3  46   F         FALSE\n\n\nNote that instead of creating each vector separately, you can create your data frame defining each of the vectors inside the data.frame() function.\n\ndata_epi_2 &lt;- data.frame(age = c(18, 25, 46), \n                         sex = c('M', 'F', 'F'))\n\ndata_epi_2\n\n  age sex\n1  18   M\n2  25   F\n3  46   F\n\n\n\n\n\n\n\n\nSide Note\n\n\n\nMost of the time you work with data in R, you will be importing it from external contexts. But it is sometimes useful to create datasets within R itself. It is in such cases that the data.frame() function will come in handy.\n\n\nTo extract the vectors back out of the data frame, use the $ syntax. Run the following lines of code in your console to observe this.\n\ndata_epi$age\nis.vector(data_epi$age) # verify that this column is indeed a vector\nclass(data_epi$age) # check the class of the vector\n\n\n\n\n\n\n\nPractice\n\n\n\nCombine the vectors below into a data frame, with the following column names: “name” for the character vector, “number_of_children” for the numeric vector and “is_married” for the logical vector.\n\ncharacter_vec &lt;- c(\"Bob\", \"Jane\", \"Joe\")\nnumeric_vec &lt;- c(1, 2, 3)\nlogical_vec &lt;- c(T, F, F)\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUse the data.frame() function to define a data frame in R that resembles the following table:\n\n\n\nroom\nnum_windows\n\n\n\n\ndining\n3\n\n\nkitchen\n2\n\n\nbedroom\n5"
  },
  {
    "objectID": "foundations_ls07_data_structures.html#tibbles",
    "href": "foundations_ls07_data_structures.html#tibbles",
    "title": "7  Data structures",
    "section": "7.8 Tibbles",
    "text": "7.8 Tibbles\nThe default version of tabular data in R is called a data frame, but there is another representation of tabular data provided by the tidyverse package. It’s called a tibble, and it is an improved version of the data frame.\nYou can convert from a data frame to a tibble with the as_tibble() function:\n\ndata_epi\n\n  id age sex positive_test\n1  1  18   M          TRUE\n2  2  25   F          TRUE\n3  3  46   F         FALSE\n\ntibble_epi &lt;- as_tibble(data_epi)\ntibble_epi\n\n# A tibble: 3 × 4\n     id   age sex   positive_test\n  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt;        \n1     1    18 M     TRUE         \n2     2    25 F     TRUE         \n3     3    46 F     FALSE        \n\n\nNotice that the tibble gives the data dimensions in the first line:\n👉# A tibble: 3 × 4👈\n     id   age sex   positive_test\n  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt;        \n1     1    18 M     TRUE         \n2     2    25 F     TRUE         \n3     3    46 F     FALSE  \nAnd also tells you the data types, at the top of each column:\n## A tibble: 3 × 4\n     id   age sex   positive_test\n👉  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; 👈       \n1     1    18 M     TRUE         \n2     2    25 F     TRUE         \n3     3    46 F     FALSE  \nThere, “int” stands for integer, dbl” stands for double (which is a kind of numeric class), “chr” stands for character, and “lgl” for logical.\n\nThe other benefit of tibbles is they avoid flooding your console when you print a long table.\nConsider the console output of the lines below, for example:\n\n## print the infert data frame (a built in R dataset)\ninfert # Veryyy long print\nas_tibble(infert) # more manageable print\n\nFor your most of your data analysis needs, you should prefer tibbles over regular data frames.\n\n7.8.1 read_csv() creates tibbles\nWhen you import data with the read_csv() function from {readr}, you get a tibble:\n\nebola_tib &lt;- read_csv(\"https://tinyurl.com/ebola-data-sample\") # Needs internet to run\nclass(ebola_tib)\n\n[1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" \n\n\nBut when you import data with the base read.csv() function, you get a data.frame:\n\nebola_df &lt;- read.csv(\"https://tinyurl.com/ebola-data-sample\") # Needs internet to run\nclass(ebola_df)\n\n[1] \"data.frame\"\n\n\nTry printing ebola_tib and ebola_df to your console to observe the different printing behavior of tibbles and data frames.\nThis is one reason we recommend using read_csv() instead of read.csv()."
  },
  {
    "objectID": "foundations_ls07_data_structures.html#wrap-up",
    "href": "foundations_ls07_data_structures.html#wrap-up",
    "title": "7  Data structures",
    "section": "7.9 Wrap-up",
    "text": "7.9 Wrap-up\nWith your understanding of data classes and structures, you are now well-equipped to perform data manipulation tasks in R. In the upcoming lessons, we will explore the powerful data transformation capabilities of the dplyr package, which will further enhance your data analysis skills.\nCongratulations on making it this far! You have covered a lot and should be proud of yourself."
  },
  {
    "objectID": "foundations_ls07_data_structures.html#solutions",
    "href": "foundations_ls07_data_structures.html#solutions",
    "title": "7  Data structures",
    "section": "7.10 Solutions",
    "text": "7.10 Solutions\nSolution to the first r-practice block:\n\nmy_vec_1 &lt;- c(1,2,3) # Use 'c' function to create a vector\nmy_vec_2 &lt;- c(\"Obi\", \"Chika\", \"Nonso\") # Separate each string with a comma\n\nSolution to the second r-practice block:\n\ndf &lt;- data.frame(name = character_vec, \n                 number_of_children = numeric_vec, \n                 is_married = logical_vec)\n\nSolution to the third r-practice block:\n\n## Solution to the third r-practice block\nrooms &lt;- data.frame(room = c(\"dining\", \"kitchen\", \"bedroom\"), \n                    num_windows = c(3, 2, 5))\n\n\n\n\nReferences\nSome material in this lesson was adapted from the following sources:\n\nWickham, H., & Grolemund, G. (n.d.). R for data science. 15 Factors | R for Data Science. Accessed October 26, 2022. https://r4ds.had.co.nz/factors.html.\n\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#introduction",
    "href": "foundations_ls08_01_using_chatgpt.html#introduction",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.1 Introduction",
    "text": "8.1 Introduction\nChatGPT, developed by OpenAI, is a language model that can be used to assist data analysts in various tasks. It can:\n\nExplain unfamiliar code\nDebug simple errors\nAdd code comments\nReformat code\nGenerate plots\nPerform simple data wrangling\nTranslate languages\nTranslate programming languages\nPerform a fluid find and replace operation\n\nLet’s get started and see how it works!"
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#models",
    "href": "foundations_ls08_01_using_chatgpt.html#models",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.2 Models",
    "text": "8.2 Models\nAs at our last check, ChatGPT comes in two main versions, both available at chat.openai.com:\n\n\n\nModel\nAvailability\nSpeed\nTask Complexity\n\n\n\n\nGPT-3.5\nFree\nFast\nSimple tasks\n\n\nGPT-4\nPaid / Bing\nSlower\nComplex tasks\n\n\n\nBoth models have their advantages and use cases. GPT-3.5 is suitable for simple tasks and is free to use, while GPT-4, though slower and paid, can handle more complex tasks.\nBing’s AI chat service also uses GPT-4 under the hood (last checked in September 2023), so you can go to Bing if you want GPT-4 access without paying. The Bing interface is a bit clunky for data analysis tasks though, so if you can afford to pay for GPT-4, we highly recommend it."
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#explain-unfamiliar-code",
    "href": "foundations_ls08_01_using_chatgpt.html#explain-unfamiliar-code",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.3 1. Explain Unfamiliar Code",
    "text": "8.3 1. Explain Unfamiliar Code\nChatGPT can explain unfamiliar code. For instance, if you encounter the following code:\n\ntrees %&gt;%\n  select(Height) %&gt;% \n  filter(Height &gt; 80)\n\nYou can ask ChatGPT, “What is this code doing?” and paste in the code.\nHere is ChatGPT3.5’s response:\n\nThe code you’ve provided appears to be written in R and is likely using the dplyr package for data manipulation. Here’s a step-by-step explanation of what this code does:\n\ntrees %&gt;%: This part of the code uses the %&gt;% operator, also known as the pipe operator, which is used to chain together multiple data manipulation operations in a more readable and concise manner. It takes the data frame or tibble trees and passes it as the first argument to the next operation.\nselect(Height) %&gt;%: After the pipe operator, the select() function is used. It selects a subset of columns from the data frame. In this case, it selects only the “Height” column from the trees data frame.\nfilter(Height &gt; 80): Following the select() operation, the filter() function is used. This function filters rows based on a specified condition. In this case, it filters the data to keep only those rows where the “Height” column has a value greater than 80.\n\nSo, in summary, the code takes the trees data frame, selects only the “Height” column, and then filters the rows to retain only those where the height is greater than 80. The result will be a subset of the original data containing only rows where the tree height is above 80."
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#debug-simple-errors",
    "href": "foundations_ls08_01_using_chatgpt.html#debug-simple-errors",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.4 2. Debug Simple Errors",
    "text": "8.4 2. Debug Simple Errors\nChatGPT can assist in debugging straightforward errors. You can ask ChatGPT, “Please help me understand why the code is not working,” then paste in both your code and the error message.\nFor example:\n\ndata_subset_I &lt;- \n  trees %&gt;%\n  select(Height) %&gt;% \n  filter(Height &gt; 80)\n\nsummary(data_subset_l)\n\nError message:\nError in summary(data_subset_I) : object 'data_subset_I' not found\nChatGPT3.5 response:\n\nIt seems like you have a typo in your code. In the code snippet you provided, you are creating a subset of data and storing it in the variable data_subset_I, but then you are trying to summarize a different variable data_subset_l (note the lowercase “L” at the end). The variable names are not consistent, which is likely causing the issue.\nYou should use the correct variable name data_subset_I when summarizing the data. Here’s the corrected code:\n\ndata_subset_I &lt;- \n  trees %&gt;%\n  select(Height) %&gt;% \n  filter(Height &gt; 80)\n\nsummary(data_subset_I)\n\nWith this corrected code, it should work as expected and summarize the data_subset_I data frame, which contains the heights of trees greater than 80."
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#add-code-comments",
    "href": "foundations_ls08_01_using_chatgpt.html#add-code-comments",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.5 3. Add Code Comments",
    "text": "8.5 3. Add Code Comments\nChatGPT can also assist in adding comments to your code. For instance, you can say, “Add comments to the following code,” then paste in your code.\n\ndata_subset_2 &lt;- \n  trees %&gt;%\n  select(Height) %&gt;% \n  filter(Height &gt; 80)\n\nsummary(data_subset_2)\n\nChatGPT3.5 response:\n\nCertainly! Here’s the code with comments added to explain each step:\n\n## Select the 'Height' column from the 'trees' dataset \n## and create a new dataset 'data_subset_2'\ndata_subset_2 &lt;- \n  trees %&gt;%\n  select(Height) %&gt;%\n  \n## Filter 'data_subset_2' to retain only rows where 'Height' is greater than 80\n  filter(Height &gt; 80)\n\n## Display a summary of 'data_subset_2'\n## including statistics like mean, median, and quartiles\nsummary(data_subset_2)\n\nThese comments provide a clear explanation of what each line of code does, making it easier to understand the data manipulation and summary generation process."
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#reformat-code",
    "href": "foundations_ls08_01_using_chatgpt.html#reformat-code",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.6 4. Reformat Code",
    "text": "8.6 4. Reformat Code\nChatGPT can help in reformatting code. For example, consider the following code:\n\ntemp&lt;-    trees %&gt;% select(Height) %&gt;%filter(Height &gt; 80)\n\nYou can ask ChatGPT, “Help me reformat this code nicely,” then paste in the code.\nChatGPT3.5 response:\n\nCertainly, here’s the reformatted code:\ntemp &lt;- trees %&gt;%\n  select(Height) %&gt;%\n  filter(Height &gt; 80)\nI’ve added line breaks and indentation to make the code more readable and visually organized."
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#make-plots",
    "href": "foundations_ls08_01_using_chatgpt.html#make-plots",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.7 5. Make Plots",
    "text": "8.7 5. Make Plots\nChatGPT can assist in creating plots with ggplot2. For instance, you might ask:\n“Use ggplot2 to create a scatter plot of height against girth for the dataset shown” then paste in the head of the data.\n\nhead(trees)\n\n  Girth Height Volume\n1   8.3     70   10.3\n2   8.6     65   10.3\n3   8.8     63   10.2\n4  10.5     72   16.4\n5  10.7     81   18.8\n6  10.8     83   19.7\n\n\nChatGPT3.5 response:\n\nTo create a scatter plot of height against girth for the dataset you provided using ggplot2 in R, you can follow these steps:\n\nFirst, make sure you have the ggplot2 package installed. If you don’t have it installed, you can install it using the following command:\n\n\ninstall.packages(\"ggplot2\")\n\n\nLoad the ggplot2 library:\n\n\nlibrary(ggplot2)\n\n\nCreate the scatter plot using the ggplot() function and the geom_point() function to add the points:\n\n\n## Assuming you have already loaded the dataset\n## If not, you can load it using data(trees)\n\n## Create the scatter plot\nggplot(trees, aes(x = Girth, y = Height)) +\n  geom_point() +\n  labs(x = \"Girth\", y = \"Height\") +\n  ggtitle(\"Scatter Plot of Height vs. Girth\")\n\nThis code will create a scatter plot of height against girth using the trees dataset, with girth values on the x-axis and height values on the y-axis. Adjust the labels and title as needed for your specific requirements.\n\nYou can then ask ChatGPT a follow-up question like:\n\nAdd a best-fit line and write the equation of the line in the caption of the plot.\nMark the mean height and mean girth on the plot.\nCenter the plot title.\n\nHere we may see the difference between GPT3.5 and 4.\nChatGPT3.5 response:\n\n\nscatter_plot &lt;- ggplot(trees, aes(x = Girth, y = Height)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, color = \"blue\") +\n  labs(x = \"Girth\", y = \"Height\") +\n  ggtitle(\"Scatter Plot of Height vs Girth\") +\n  theme(plot.title = element_text(hjust = 0.5))\n\n## Calculate mean values\nmean_girth &lt;- mean(trees$Girth)\nmean_height &lt;- mean(trees$Height)\n\n## Add mean points\nscatter_plot &lt;- scatter_plot +\n  geom_point(data = data.frame(Girth = mean_girth, Height = mean_height), \n             color = \"red\", size = 3) +\n  annotate(\"text\", x = mean_girth, y = mean_height, label = \"Mean\", \n           color = \"red\", vjust = -1)\n\n## Print the scatter plot\nprint(scatter_plot)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nIn the ChatGPT3.5 response, the equation of the line is missing from the caption.\nHere is GPT4’s response:\n\n\nlibrary(tidyverse)\nlibrary(scales)\n\n## Calculate means\nmean_girth &lt;- mean(trees$Girth)\nmean_height &lt;- mean(trees$Height)\n\n## Fit a linear model to calculate the equation of the line\nfit &lt;- lm(Height ~ Girth, data = trees)\nslope &lt;- coef(fit)[2]\nintercept &lt;- coef(fit)[1]\neq &lt;- paste(\"y = \", round(slope, 2), \"x + \", round(intercept, 2))\n\n## Generate the plot\np &lt;- ggplot(trees, aes(x = Girth, y = Height)) +\n  geom_point() +\n  geom_smooth(method = 'lm', se = FALSE, color = \"red\", \n              formula = y ~ x) + # Add best-fit line (linear model)\n  geom_vline(xintercept = mean_girth, linetype=\"dashed\") + \n  geom_hline(yintercept = mean_height, linetype=\"dashed\") +\n  ggtitle(\"Scatter plot of Height vs Girth\") +\n  theme(plot.title = element_text(hjust = 0.5)) +  # Center title\n  scale_x_continuous(breaks = pretty_breaks(n = 10)) +\n  scale_y_continuous(breaks = pretty_breaks(n = 10)) +\n  labs(x = \"Girth\",\n       y = \"Height\",\n       caption = eq)   # Add equation to the caption\n\np\n\n\n\n\n\nWith GPT-4, you get exactly what you want, including the equation in the caption at the bottom right of the plot."
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#simple-data-wrangling",
    "href": "foundations_ls08_01_using_chatgpt.html#simple-data-wrangling",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.8 6. Simple Data Wrangling",
    "text": "8.8 6. Simple Data Wrangling\nChatGPT can help with simple data wrangling tasks. For instance:\nConsider the following dataset:\n\nhead(trees)\n\n  Girth Height Volume\n1   8.3     70   10.3\n2   8.6     65   10.3\n3   8.8     63   10.2\n4  10.5     72   16.4\n5  10.7     81   18.8\n6  10.8     83   19.7\n\n\nYou might ask, “Give me dplyr code to find the mean and median girth, height, and volume.”\nChatGPT3.5 gives us this code:\n\n\n## Use summarise_all to compute mean and median for each column\nresult &lt;- trees %&gt;%\n  summarise_all(\n    .funs = list(mean = mean, median = median),\n    na.rm = TRUE\n  )\n\nprint(result)"
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#translate-language",
    "href": "foundations_ls08_01_using_chatgpt.html#translate-language",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.9 7. Translate Language",
    "text": "8.9 7. Translate Language\nChatGPT can help translate text in your tutorial or documentation from one language to another, while preserving the code. If you use other translators, they often translate your code as well, which is undesirable.\nFor example, you can ask:\n“Translate the following section of a tutorial into Spanish”\n\ndplyr is part of the core of tidyverse, so it is automatically loaded with:\n\nlibrary(tidyverse)\n\nIt can also be loaded individually.\n\nlibrary(dplyr)\n\nChatGPT 3.5 response:\n\ndplyr forma parte del núcleo de tidyverse, por lo que se carga automáticamente con:\n\nlibrary(tidyverse)\n\nTambién se puede cargar de forma individual.\n\nlibrary(dplyr)\n\nYou can verify the validity of this translation by translating it back into English in a different session."
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#translate-programming-languages",
    "href": "foundations_ls08_01_using_chatgpt.html#translate-programming-languages",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.10 8. Translate Programming Languages",
    "text": "8.10 8. Translate Programming Languages\nChatGPT can help translate between different programming languages. For example, you can say:\n“Translate the following Stata code to R:”\nrecode age (18/35=1) (36/50=2), into(agegroup)\nChatGPT 3.5 response:\n\nIn R, you can achieve the same recoding of the “age” variable into an “agegroup” variable using the cut() function. Here’s the equivalent R code:\n\n## Assuming you have a dataframe called \"data\" with an \"age\" variable\ndata$agegroup &lt;- cut(data$age, breaks = c(18, 35, 50), labels = c(1, 2), \n                     include.lowest = TRUE)\n\nIn this code:\n\ndata$age refers to the “age” variable in your dataframe.\ncut() is used to create the “agegroup” variable.\nbreaks specifies the breakpoints for age groups (18, 35, and 50).\nlabels assigns labels 1 and 2 to the corresponding age groups.\ninclude.lowest = TRUE ensures that values exactly equal to the breakpoints are included in the specified group.\n\nThis code will create a new “agegroup” variable in your dataframe, similar to what the Stata code does."
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#fluid-find-and-replace",
    "href": "foundations_ls08_01_using_chatgpt.html#fluid-find-and-replace",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.11 9. Fluid Find and Replace",
    "text": "8.11 9. Fluid Find and Replace\nLastly, ChatGPT can help you refactor your code in situations where a simple find and replace with your IDE would be time-consuming. For example, if “Afghanistan” is written in three different ways (with a capital “A”, in lowercase letters, and as a country code inthe title, “AF”), you could replace all instances with “Ghana”.\nYou can ask ChatGPT:\n“Replace ‘afghanistan’ with ‘ghana’ for the code below:”\n\nafghanistan_2000 &lt;- population %&gt;%\n  filter(country == \"Afghanistan\", year == 2000) %&gt;%\n  pull(population)\n\nafghanistan_2010 &lt;- population %&gt;%\n  filter(country == \"Afghanistan\", year == 2010) %&gt;%\n  pull(population)\n\nafghanistan_population &lt;- data.frame(\n  year = c(2000, 2010),\n  population = c(afghanistan_2000, afghanistan_2010)\n)\n\npercent_change &lt;-\n  ((afghanistan_2010 - afghanistan_2000) / afghanistan_2000) * 100\n\nggplot(afghanistan_population,\n       aes(\n         x = factor(year),\n         y = population,\n         fill = factor(year)\n       )) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    x = \"Year\",\n    y = \"Population\",\n    fill = \"Year\",\n    title = paste0(\n      \"Change in Population in Afghanistan (AF) from 2000 to 2010 (\",\n      round(percent_change, 2),\n      \"%)\"\n    )\n  ) +\n  theme_classic()\n\n\n\n\nChatGPT 3.5 response:\n\n\nghana_2000 &lt;- population %&gt;%\n  filter(country == \"Ghana\", year == 2000) %&gt;%\n  pull(population)\n\nghana_2010 &lt;- population %&gt;%\n  filter(country == \"Ghana\", year == 2010) %&gt;%\n  pull(population)\n\nghana_population &lt;- data.frame(\n  year = c(2000, 2010),\n  population = c(ghana_2000, ghana_2010)\n)\n\npercent_change &lt;- ((ghana_2010 - ghana_2000) / ghana_2000) * 100\n\nggplot(ghana_population, aes(\n  x = factor(year),\n  y = population,\n  fill = factor(year)\n)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    x = \"Year\",\n    y = \"Population\",\n    fill = \"Year\",\n    title = paste0(\"Change in Population in Ghana (GH) from 2000 to 2010 (\",\n                   round(percent_change, 2),\n                   \"%)\")\n  ) +\n  theme_classic()\n\n\n\n\nThis refactored code now refers to “Ghana” instead of “Afghanistan”."
  },
  {
    "objectID": "foundations_ls08_01_using_chatgpt.html#limitations-of-chatgpt",
    "href": "foundations_ls08_01_using_chatgpt.html#limitations-of-chatgpt",
    "title": "8  Using ChatGPT for Data Analysis",
    "section": "8.12 Limitations of ChatGPT",
    "text": "8.12 Limitations of ChatGPT\nWhile ChatGPT is a powerful tool for data analysts, it has some limitations:\n\nLag in Learning: ChatGPT may struggle with newer software or libraries.\nHallucinations: Always verify the output of ChatGPT as it can sometimes generate outputs that are incorrect or nonsensical.\nLimited Input Length: ChatGPT cannot process very long prompts. To avoid this, start new conversations frequently.\nWeak Math Skills: At the moment, ChatGPT is not ideal for complex calculations or data analysis."
  },
  {
    "objectID": "untangled_ls01_select_rename.html#introduction",
    "href": "untangled_ls01_select_rename.html#introduction",
    "title": "9  Selecting and renaming columns",
    "section": "9.1 Introduction",
    "text": "9.1 Introduction\nToday we will begin our exploration of the {dplyr} package! Our first verb on the list is select which allows to keep or drop variables from your dataframe. Choosing your variables is the first step in cleaning your data.\n\n\n\nFig: the select() function.\n\n\nLet’s go !"
  },
  {
    "objectID": "untangled_ls01_select_rename.html#learning-objectives",
    "href": "untangled_ls01_select_rename.html#learning-objectives",
    "title": "9  Selecting and renaming columns",
    "section": "9.2 Learning objectives",
    "text": "9.2 Learning objectives\n\nYou can keep or drop columns from a dataframe using the dplyr::select() function from the {dplyr} package.\nYou can select a range or combination of columns using operators like the colon (:), the exclamation mark (!), and the c() function.\nYou can select columns based on patterns in their names with helper functions like starts_with(), ends_with(), contains(), and everything().\nYou can use rename() and select() to change column names."
  },
  {
    "objectID": "untangled_ls01_select_rename.html#the-yaounde-covid-19-dataset",
    "href": "untangled_ls01_select_rename.html#the-yaounde-covid-19-dataset",
    "title": "9  Selecting and renaming columns",
    "section": "9.3 The Yaounde COVID-19 dataset",
    "text": "9.3 The Yaounde COVID-19 dataset\nIn this lesson, we analyse results from a COVID-19 serological survey conducted in Yaounde, Cameroon in late 2020. The survey estimated how many people had been infected with COVID-19 in the region, by testing for IgG and IgM antibodies. The full dataset can be obtained from Zenodo, and the paper can be viewed here.\nSpend some time browsing through this dataset. Each line corresponds to one patient surveyed. There are some demographic, socio-economic and COVID-related variables. The results of the IgG and IgM antibody tests are in the columns igg_result and igm_result.\n\nyaounde &lt;- read_csv(here::here(\"data/yaounde_data.csv\"))\nyaounde  \n\n# A tibble: 5 × 53\n  id     date_surveyed   age age_category age_category_3 sex   highest_education\n  &lt;chr&gt;  &lt;date&gt;        &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt; &lt;chr&gt;            \n1 BRIQU… 2020-10-22       45 45 - 64      Adult          Fema… Secondary        \n2 BRIQU… 2020-10-24       55 45 - 64      Adult          Male  University       \n3 BRIQU… 2020-10-24       23 15 - 29      Adult          Male  University       \n4 BRIQU… 2020-10-22       20 15 - 29      Adult          Fema… Secondary        \n5 BRIQU… 2020-10-22       55 45 - 64      Adult          Fema… Primary          \n# ℹ 46 more variables: occupation &lt;chr&gt;, weight_kg &lt;dbl&gt;, height_cm &lt;dbl&gt;,\n#   is_smoker &lt;chr&gt;, is_pregnant &lt;chr&gt;, is_medicated &lt;chr&gt;, neighborhood &lt;chr&gt;,\n#   household_with_children &lt;chr&gt;, breadwinner &lt;chr&gt;, source_of_revenue &lt;chr&gt;,\n#   has_contact_covid &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;,\n#   symptoms &lt;chr&gt;, symp_fever &lt;chr&gt;, symp_headache &lt;chr&gt;, symp_cough &lt;chr&gt;,\n#   symp_rhinitis &lt;chr&gt;, symp_sneezing &lt;chr&gt;, symp_fatigue &lt;chr&gt;,\n#   symp_muscle_pain &lt;chr&gt;, symp_nausea_or_vomiting &lt;chr&gt;, …\n\n\n\n\n\nLeft: the Yaounde survey team. Right: an antibody test being administered."
  },
  {
    "objectID": "untangled_ls01_select_rename.html#introducing-select",
    "href": "untangled_ls01_select_rename.html#introducing-select",
    "title": "9  Selecting and renaming columns",
    "section": "9.4 Introducing select()",
    "text": "9.4 Introducing select()\n\n\n\nFig: the select() function. (Drawing adapted from Allison Horst).\n\n\ndplyr::select() lets us pick which columns (variables) to keep or drop.\nWe can select a column by name:\n\nyaounde %&gt;% select(age) \n\n# A tibble: 5 × 1\n    age\n  &lt;dbl&gt;\n1    45\n2    55\n3    23\n4    20\n5    55\n\n\nOr we can select a column by position:\n\nyaounde %&gt;% select(3) # `age` is the 3rd column\n\n# A tibble: 5 × 1\n    age\n  &lt;dbl&gt;\n1    45\n2    55\n3    23\n4    20\n5    55\n\n\nTo select multiple variables, we separate them with commas:\n\nyaounde %&gt;% select(age, sex, igg_result)\n\n# A tibble: 971 × 3\n     age sex    igg_result\n   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;     \n 1    45 Female Negative  \n 2    55 Male   Positive  \n 3    23 Male   Negative  \n 4    20 Female Positive  \n 5    55 Female Positive  \n 6    17 Female Negative  \n 7    13 Female Positive  \n 8    28 Male   Negative  \n 9    30 Male   Negative  \n10    13 Female Positive  \n# ℹ 961 more rows\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nSelect the weight and height variables in the yaounde data frame.\n\n\nSelect the 16th and 22nd columns in the yaounde data frame.\n\n\n\n\nFor the next part of the tutorial, let’s create a smaller subset of the data, called yao.\n\nyao &lt;-\n  yaounde %&gt;% select(age,\n                     sex,\n                     highest_education,\n                     occupation,\n                     is_smoker,\n                     is_pregnant,\n                     igg_result,\n                     igm_result)\nyao\n\n# A tibble: 5 × 8\n    age sex    highest_education occupation     is_smoker is_pregnant igg_result\n  &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;             &lt;chr&gt;          &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;     \n1    45 Female Secondary         Informal work… Non-smok… No          Negative  \n2    55 Male   University        Salaried work… Ex-smoker &lt;NA&gt;        Positive  \n3    23 Male   University        Student        Smoker    &lt;NA&gt;        Negative  \n4    20 Female Secondary         Student        Non-smok… No          Positive  \n5    55 Female Primary           Trader--Farmer Non-smok… No          Positive  \n# ℹ 1 more variable: igm_result &lt;chr&gt;\n\n\n\n9.4.1 Selecting column ranges with :\nThe : operator selects a range of consecutive variables:\n\nyao %&gt;% select(age:occupation) # Select all columns from `age` to `occupation`\n\n# A tibble: 5 × 4\n    age sex    highest_education occupation     \n  &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;             &lt;chr&gt;          \n1    45 Female Secondary         Informal worker\n2    55 Male   University        Salaried worker\n3    23 Male   University        Student        \n4    20 Female Secondary         Student        \n5    55 Female Primary           Trader--Farmer \n\n\nWe can also specify a range with column numbers:\n\nyao %&gt;% select(1:4) # Select columns 1 to 4\n\n# A tibble: 5 × 4\n    age sex    highest_education occupation     \n  &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;             &lt;chr&gt;          \n1    45 Female Secondary         Informal worker\n2    55 Male   University        Salaried worker\n3    23 Male   University        Student        \n4    20 Female Secondary         Student        \n5    55 Female Primary           Trader--Farmer \n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nWith the yaounde data frame, select the columns between symptoms and sequelae, inclusive. (“Inclusive” means you should also include symptoms and sequelae in the selection.)\n\n\n\n\n\n9.4.2 Excluding columns with !\nThe exclamation point negates a selection:\n\nyao %&gt;% select(!age) # Select all columns except `age`\n\n# A tibble: 5 × 7\n  sex   highest_education occupation is_smoker is_pregnant igg_result igm_result\n  &lt;chr&gt; &lt;chr&gt;             &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;     \n1 Fema… Secondary         Informal … Non-smok… No          Negative   Negative  \n2 Male  University        Salaried … Ex-smoker &lt;NA&gt;        Positive   Negative  \n3 Male  University        Student    Smoker    &lt;NA&gt;        Negative   Negative  \n4 Fema… Secondary         Student    Non-smok… No          Positive   Negative  \n5 Fema… Primary           Trader--F… Non-smok… No          Positive   Negative  \n\n\nTo drop a range of consecutive columns, we use, for example,!age:occupation:\n\nyao %&gt;% select(!age:occupation) # Drop columns from `age` to `occupation`\n\n# A tibble: 5 × 4\n  is_smoker  is_pregnant igg_result igm_result\n  &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;     \n1 Non-smoker No          Negative   Negative  \n2 Ex-smoker  &lt;NA&gt;        Positive   Negative  \n3 Smoker     &lt;NA&gt;        Negative   Negative  \n4 Non-smoker No          Positive   Negative  \n5 Non-smoker No          Positive   Negative  \n\n\nTo drop several non-consecutive columns, place them inside !c():\n\nyao %&gt;% select(!c(age, sex, igg_result))\n\n# A tibble: 5 × 5\n  highest_education occupation      is_smoker  is_pregnant igm_result\n  &lt;chr&gt;             &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;     \n1 Secondary         Informal worker Non-smoker No          Negative  \n2 University        Salaried worker Ex-smoker  &lt;NA&gt;        Negative  \n3 University        Student         Smoker     &lt;NA&gt;        Negative  \n4 Secondary         Student         Non-smoker No          Negative  \n5 Primary           Trader--Farmer  Non-smoker No          Negative  \n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nFrom the yaounde data frame, remove all columns between highest_education and consultation, inclusive."
  },
  {
    "objectID": "untangled_ls01_select_rename.html#helper-functions-for-select",
    "href": "untangled_ls01_select_rename.html#helper-functions-for-select",
    "title": "9  Selecting and renaming columns",
    "section": "9.5 Helper functions for select()",
    "text": "9.5 Helper functions for select()\ndplyr has a number of helper functions to make selecting easier by using patterns from the column names. Let’s take a look at some of these.\n\n9.5.1 starts_with() and ends_with()\nThese two helpers work exactly as their names suggest!\n\nyao %&gt;% select(starts_with(\"is_\")) # Columns that start with \"is\"\n\n# A tibble: 5 × 2\n  is_smoker  is_pregnant\n  &lt;chr&gt;      &lt;chr&gt;      \n1 Non-smoker No         \n2 Ex-smoker  &lt;NA&gt;       \n3 Smoker     &lt;NA&gt;       \n4 Non-smoker No         \n5 Non-smoker No         \n\nyao %&gt;% select(ends_with(\"_result\")) # Columns that end with \"result\"\n\n# A tibble: 5 × 2\n  igg_result igm_result\n  &lt;chr&gt;      &lt;chr&gt;     \n1 Negative   Negative  \n2 Positive   Negative  \n3 Negative   Negative  \n4 Positive   Negative  \n5 Positive   Negative  \n\n\n\n\n9.5.2 contains()\ncontains() helps select columns that contain a certain string:\n\nyaounde %&gt;% select(contains(\"drug\")) # Columns that contain the string \"drug\"\n\n# A tibble: 5 × 12\n  drugsource       is_drug_parac is_drug_antibio is_drug_hydrocortisone\n  &lt;chr&gt;                    &lt;dbl&gt;           &lt;dbl&gt;                  &lt;dbl&gt;\n1 Self or familial             1               0                      0\n2 &lt;NA&gt;                        NA              NA                     NA\n3 &lt;NA&gt;                        NA              NA                     NA\n4 Self or familial             0               1                      0\n5 &lt;NA&gt;                        NA              NA                     NA\n# ℹ 8 more variables: is_drug_other_anti_inflam &lt;dbl&gt;, is_drug_antiviral &lt;dbl&gt;,\n#   is_drug_chloro &lt;dbl&gt;, is_drug_tradn &lt;dbl&gt;, is_drug_oxygen &lt;dbl&gt;,\n#   is_drug_other &lt;dbl&gt;, is_drug_no_resp &lt;dbl&gt;, is_drug_none &lt;dbl&gt;\n\n\n\n\n9.5.3 everything()\nAnother helper function, everything(), matches all variables that have not yet been selected.\n\n## First, `is_pregnant`, then every other column.\nyao %&gt;% select(is_pregnant, everything())\n\n# A tibble: 5 × 8\n  is_pregnant   age sex    highest_education occupation     is_smoker igg_result\n  &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;             &lt;chr&gt;          &lt;chr&gt;     &lt;chr&gt;     \n1 No             45 Female Secondary         Informal work… Non-smok… Negative  \n2 &lt;NA&gt;           55 Male   University        Salaried work… Ex-smoker Positive  \n3 &lt;NA&gt;           23 Male   University        Student        Smoker    Negative  \n4 No             20 Female Secondary         Student        Non-smok… Positive  \n5 No             55 Female Primary           Trader--Farmer Non-smok… Positive  \n# ℹ 1 more variable: igm_result &lt;chr&gt;\n\n\nIt is often useful for establishing the order of columns.\nSay we wanted to bring the is_pregnant column to the start of the yao data frame, we could type out all the column names manually:\n\nyao %&gt;% select(is_pregnant, \n               age, \n               sex, \n               highest_education, \n               occupation, \n               is_smoker, \n               igg_result, \n               igm_result)\n\n# A tibble: 5 × 8\n  is_pregnant   age sex    highest_education occupation     is_smoker igg_result\n  &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;             &lt;chr&gt;          &lt;chr&gt;     &lt;chr&gt;     \n1 No             45 Female Secondary         Informal work… Non-smok… Negative  \n2 &lt;NA&gt;           55 Male   University        Salaried work… Ex-smoker Positive  \n3 &lt;NA&gt;           23 Male   University        Student        Smoker    Negative  \n4 No             20 Female Secondary         Student        Non-smok… Positive  \n5 No             55 Female Primary           Trader--Farmer Non-smok… Positive  \n# ℹ 1 more variable: igm_result &lt;chr&gt;\n\n\nBut this would be painful for larger data frames, such as our original yaounde data frame. In such a case, we can use everything():\n\n## Bring `is_pregnant` to the front of the data frame\nyaounde %&gt;% select(is_pregnant, everything())\n\n# A tibble: 5 × 53\n  is_pregnant id           date_surveyed   age age_category age_category_3 sex  \n  &lt;chr&gt;       &lt;chr&gt;        &lt;date&gt;        &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt;\n1 No          BRIQUETERIE… 2020-10-22       45 45 - 64      Adult          Fema…\n2 &lt;NA&gt;        BRIQUETERIE… 2020-10-24       55 45 - 64      Adult          Male \n3 &lt;NA&gt;        BRIQUETERIE… 2020-10-24       23 15 - 29      Adult          Male \n4 No          BRIQUETERIE… 2020-10-22       20 15 - 29      Adult          Fema…\n5 No          BRIQUETERIE… 2020-10-22       55 45 - 64      Adult          Fema…\n# ℹ 46 more variables: highest_education &lt;chr&gt;, occupation &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, height_cm &lt;dbl&gt;, is_smoker &lt;chr&gt;, is_medicated &lt;chr&gt;,\n#   neighborhood &lt;chr&gt;, household_with_children &lt;chr&gt;, breadwinner &lt;chr&gt;,\n#   source_of_revenue &lt;chr&gt;, has_contact_covid &lt;chr&gt;, igg_result &lt;chr&gt;,\n#   igm_result &lt;chr&gt;, symptoms &lt;chr&gt;, symp_fever &lt;chr&gt;, symp_headache &lt;chr&gt;,\n#   symp_cough &lt;chr&gt;, symp_rhinitis &lt;chr&gt;, symp_sneezing &lt;chr&gt;,\n#   symp_fatigue &lt;chr&gt;, symp_muscle_pain &lt;chr&gt;, …\n\n\nThis helper can be combined with many others.\n\n## Bring columns that end with \"result\" to the front of the data frame\nyaounde %&gt;% select(ends_with(\"result\"), everything())\n\n# A tibble: 5 × 53\n  igg_result igm_result id       date_surveyed   age age_category age_category_3\n  &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;    &lt;date&gt;        &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;         \n1 Negative   Negative   BRIQUET… 2020-10-22       45 45 - 64      Adult         \n2 Positive   Negative   BRIQUET… 2020-10-24       55 45 - 64      Adult         \n3 Negative   Negative   BRIQUET… 2020-10-24       23 15 - 29      Adult         \n4 Positive   Negative   BRIQUET… 2020-10-22       20 15 - 29      Adult         \n5 Positive   Negative   BRIQUET… 2020-10-22       55 45 - 64      Adult         \n# ℹ 46 more variables: sex &lt;chr&gt;, highest_education &lt;chr&gt;, occupation &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, height_cm &lt;dbl&gt;, is_smoker &lt;chr&gt;, is_pregnant &lt;chr&gt;,\n#   is_medicated &lt;chr&gt;, neighborhood &lt;chr&gt;, household_with_children &lt;chr&gt;,\n#   breadwinner &lt;chr&gt;, source_of_revenue &lt;chr&gt;, has_contact_covid &lt;chr&gt;,\n#   symptoms &lt;chr&gt;, symp_fever &lt;chr&gt;, symp_headache &lt;chr&gt;, symp_cough &lt;chr&gt;,\n#   symp_rhinitis &lt;chr&gt;, symp_sneezing &lt;chr&gt;, symp_fatigue &lt;chr&gt;,\n#   symp_muscle_pain &lt;chr&gt;, symp_nausea_or_vomiting &lt;chr&gt;, …\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nSelect all columns in the yaounde data frame that start with “is_”.\n\n\nMove the columns that start with “is_” to the beginning of the yaounde data frame."
  },
  {
    "objectID": "untangled_ls01_select_rename.html#change-column-names-with-rename",
    "href": "untangled_ls01_select_rename.html#change-column-names-with-rename",
    "title": "9  Selecting and renaming columns",
    "section": "9.6 Change column names with rename()",
    "text": "9.6 Change column names with rename()\n\n\n\nFig: the rename() function. (Drawing adapted from Allison Horst)\n\n\ndplyr::rename() is used to change column names:\n\n## Rename `age` and `sex` to `patient_age` and `patient_sex`\nyaounde %&gt;% \n  rename(patient_age = age, \n         patient_sex = sex)\n\n# A tibble: 5 × 53\n  id           date_surveyed patient_age age_category age_category_3 patient_sex\n  &lt;chr&gt;        &lt;date&gt;              &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt;      \n1 BRIQUETERIE… 2020-10-22             45 45 - 64      Adult          Female     \n2 BRIQUETERIE… 2020-10-24             55 45 - 64      Adult          Male       \n3 BRIQUETERIE… 2020-10-24             23 15 - 29      Adult          Male       \n4 BRIQUETERIE… 2020-10-22             20 15 - 29      Adult          Female     \n5 BRIQUETERIE… 2020-10-22             55 45 - 64      Adult          Female     \n# ℹ 47 more variables: highest_education &lt;chr&gt;, occupation &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, height_cm &lt;dbl&gt;, is_smoker &lt;chr&gt;, is_pregnant &lt;chr&gt;,\n#   is_medicated &lt;chr&gt;, neighborhood &lt;chr&gt;, household_with_children &lt;chr&gt;,\n#   breadwinner &lt;chr&gt;, source_of_revenue &lt;chr&gt;, has_contact_covid &lt;chr&gt;,\n#   igg_result &lt;chr&gt;, igm_result &lt;chr&gt;, symptoms &lt;chr&gt;, symp_fever &lt;chr&gt;,\n#   symp_headache &lt;chr&gt;, symp_cough &lt;chr&gt;, symp_rhinitis &lt;chr&gt;,\n#   symp_sneezing &lt;chr&gt;, symp_fatigue &lt;chr&gt;, symp_muscle_pain &lt;chr&gt;, …\n\n\n\n\n\n\n\n\nWatch Out\n\n\n\nThe fact that the new name comes first in the function (rename(NEWNAME = OLDNAME)) is sometimes confusing. You should get used to this with time.\n\n\n\n9.6.1 Rename within select()\nYou can also rename columns while selecting them:\n\n## Select `age` and `sex`, and rename them to `patient_age` and `patient_sex`\nyaounde %&gt;% \n  select(patient_age = age, \n         patient_sex = sex)\n\n# A tibble: 5 × 2\n  patient_age patient_sex\n        &lt;dbl&gt; &lt;chr&gt;      \n1          45 Female     \n2          55 Male       \n3          23 Male       \n4          20 Female     \n5          55 Female"
  },
  {
    "objectID": "untangled_ls01_select_rename.html#wrap-up",
    "href": "untangled_ls01_select_rename.html#wrap-up",
    "title": "9  Selecting and renaming columns",
    "section": "9.7 Wrap up",
    "text": "9.7 Wrap up\nI hope this first lesson has allowed you to see how intuitive and useful the {dplyr} verbs are! This is the first of a series of basic data wrangling verbs: see you in the next lesson to learn more.\n\n\n\nFig: Basic Data Wrangling Dplyr Verbs.\n\n\n LAURE VANCAUWENBERGHE    Data analyst, the GRAPH Network A firm believer in science for good, striving to ally programming, health and education  ANDREE VALLE CAMPOS    R Developer and Instructor, the GRAPH Network Motivated by reproducible science and education  KENE DAVID NWOSU    Data analyst, the GRAPH Network Passionate about world improvement"
  },
  {
    "objectID": "untangled_ls01_select_rename.html#references",
    "href": "untangled_ls01_select_rename.html#references",
    "title": "9  Selecting and renaming columns",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nHorst, A. (2021). Dplyr-learnr. https://github.com/allisonhorst/dplyr-learnr (Original work published 2020)\nSubset columns using their names and types—Select. (n.d.). Retrieved 31 December 2021, from https://dplyr.tidyverse.org/reference/select.html\n\nArtwork was adapted from:\n\nHorst, A. (2021). R & stats illustrations by Allison Horst. https://github.com/allisonhorst/stats-illustrations (Original work published 2018)"
  },
  {
    "objectID": "untangled_ls01_select_rename.html#solutions",
    "href": "untangled_ls01_select_rename.html#solutions",
    "title": "9  Selecting and renaming columns",
    "section": "9.8 Solutions",
    "text": "9.8 Solutions\n\n.SOLUTION_Q_weight_height()\n\n \n  yaounde %&gt;% select(weight_kg, height_cm)\n\n.SOLUTION_Q_cols_16_22()\n\n \n  yaounde %&gt;% select(16, 22)\n\n.SOLUTION_Q_symp_to_sequel()\n\n \n  yaounde %&gt;% select(symptoms:sequelae)\n\n.SOLUTION_Q_educ_consult()\n\n \n  yaounde %&gt;% select(!c(highest_education:consultation))\n\n.SOLUTION_Q_starts_with_is()\n\n \n  yaounde %&gt;% select(starts_with(\"is\"))\n\n.SOLUTION_Q_rearrange()\n\n \n  yaounde %&gt;% select(starts_with(\"is_\"), everything())"
  },
  {
    "objectID": "untangled_ls02_filter.html#intro",
    "href": "untangled_ls02_filter.html#intro",
    "title": "10  Filtering rows",
    "section": "10.1 Intro",
    "text": "10.1 Intro\nOnward with the {dplyr} package, discovering the filter verb. Last time we saw how to select variables (columns) and today we will see how to keep or drop data entries, rows, using filter. Dropping abnormal data entries or keeping subsets of your data points is another essential aspect of data wrangling.\nLet’s go !"
  },
  {
    "objectID": "untangled_ls02_filter.html#learning-objectives",
    "href": "untangled_ls02_filter.html#learning-objectives",
    "title": "10  Filtering rows",
    "section": "10.2 Learning objectives",
    "text": "10.2 Learning objectives\n\nYou can use dplyr::filter() to keep or drop rows from a dataframe.\n\nYou can filter rows by specifying conditions on numbers or strings using relational operators like greater than (&gt;), less than (&lt;), equal to (==), and not equal to (!=).\nYou can filter rows by combining conditions using logical operators like the ampersand (&) and the vertical bar (|).\nYou can filter rows by negating conditions using the exclamation mark (!) logical operator.\n\nYou can filter rows with missing values using the is.na() function."
  },
  {
    "objectID": "untangled_ls02_filter.html#the-yaounde-covid-19-dataset",
    "href": "untangled_ls02_filter.html#the-yaounde-covid-19-dataset",
    "title": "10  Filtering rows",
    "section": "10.3 The Yaounde COVID-19 dataset",
    "text": "10.3 The Yaounde COVID-19 dataset\nIn this lesson, we will again use the data from the COVID-19 serological survey conducted in Yaounde, Cameroon.\n\nyaounde &lt;- read_csv(here::here('data/yaounde_data.csv'))\n### a smaller subset of variables\nyao &lt;- yaounde %&gt;% \n  select(age, sex, weight_kg, highest_education, neighborhood, \n         occupation, is_smoker, is_pregnant, \n         igg_result, igm_result)\nyao\n\n# A tibble: 5 × 10\n    age sex    weight_kg highest_education neighborhood occupation     is_smoker\n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt;    \n1    45 Female        95 Secondary         Briqueterie  Informal work… Non-smok…\n2    55 Male          96 University        Briqueterie  Salaried work… Ex-smoker\n3    23 Male          74 University        Briqueterie  Student        Smoker   \n4    20 Female        70 Secondary         Briqueterie  Student        Non-smok…\n5    55 Female        67 Primary           Briqueterie  Trader--Farmer Non-smok…\n# ℹ 3 more variables: is_pregnant &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;"
  },
  {
    "objectID": "untangled_ls02_filter.html#introducing-filter",
    "href": "untangled_ls02_filter.html#introducing-filter",
    "title": "10  Filtering rows",
    "section": "10.4 Introducing filter()",
    "text": "10.4 Introducing filter()\nWe use filter() to keep rows that satisfy a set of conditions. Let’s take a look at a simple example. If we want to keep just the male records, we run:\n\nyao %&gt;% filter(sex == \"Male\")\n\n# A tibble: 5 × 10\n    age sex   weight_kg highest_education neighborhood occupation      is_smoker\n  &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;           &lt;chr&gt;    \n1    55 Male         96 University        Briqueterie  Salaried worker Ex-smoker\n2    23 Male         74 University        Briqueterie  Student         Smoker   \n3    28 Male         62 Doctorate         Briqueterie  Student         Non-smok…\n4    30 Male         73 Secondary         Briqueterie  Trader          Non-smok…\n5    42 Male         71 Secondary         Briqueterie  Trader          Ex-smoker\n# ℹ 3 more variables: is_pregnant &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;\n\n\nNote the use of the double equal sign == rather than the single equal sign =. The == sign tests for equality, as demonstrated below:\n\n### create the object `sex_vector` with three elements\nsex_vector &lt;- c(\"Male\", \"Female\", \"Female\")\n### test which elements are equal to \"Male\"\nsex_vector == \"Male\"\n\n[1]  TRUE FALSE FALSE\n\n\nSo the code yao %&gt;% filter(sex == \"Male\") will keep all rows where the equality test sex == \"Male\" evaluates to TRUE.\n\nIt is often useful to chain filter() with nrow() to get the number of rows fulfilling a condition.\n\n### how many respondents were male?\nyao %&gt;% \n  filter(sex == \"Male\") %&gt;% \n  nrow()\n\n[1] 422\n\n\n\n\n\n\n\n\nKey Point\n\n\n\nThe double equal sign, ==, tests for equality, while the single equals sign, =, is used for specifying values to arguments inside functions.\n\n\n\n\n\n\n\n\nPractice\n\n\n\nFilter the yao data frame to respondents who were pregnant during the survey.\nHow many respondents were female? (Use filter() and nrow())"
  },
  {
    "objectID": "untangled_ls02_filter.html#relational-operators",
    "href": "untangled_ls02_filter.html#relational-operators",
    "title": "10  Filtering rows",
    "section": "10.5 Relational operators",
    "text": "10.5 Relational operators\nThe == operator introduced above is an example of a “relational” operator, as it tests the relation between two values. Here is a list of some of these operators:\n\n\n\nOperator\nis TRUE if\n\n\nA &lt; B\nA is less than B\n\n\nA &lt;= B\nA is less than or equal to B\n\n\nA &gt; B\nA is greater than B\n\n\nA &gt;= B\nA is greater than or equal to B\n\n\nA == B\nA is equal to B\n\n\nA != B\nA is not equal to B\n\n\nA %in% B\nA is an element of B\n\n\n\n\n\n\nFig: AND and OR operators visualized.\n\n\nLet’s see how to use these within filter():\n\nyao %&gt;% filter(sex != \"Male\") ## keep rows where `sex` is not \"Male\"\n\n# A tibble: 5 × 10\n    age sex    weight_kg highest_education neighborhood occupation     is_smoker\n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt;    \n1    45 Female        95 Secondary         Briqueterie  Informal work… Non-smok…\n2    20 Female        70 Secondary         Briqueterie  Student        Non-smok…\n3    55 Female        67 Primary           Briqueterie  Trader--Farmer Non-smok…\n4    17 Female        65 Secondary         Briqueterie  Student        Non-smok…\n5    13 Female        65 Secondary         Briqueterie  Student        Non-smok…\n# ℹ 3 more variables: is_pregnant &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;\n\nyao %&gt;% filter(age &lt; 6) ## keep respondents under 6\n\n# A tibble: 5 × 10\n    age sex    weight_kg highest_education neighborhood occupation  is_smoker \n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;       &lt;chr&gt;     \n1     5 Female        19 Primary           Carriere     Student     Non-smoker\n2     5 Female        26 Primary           Carriere     No response Non-smoker\n3     5 Male          16 Primary           Cité Verte   Student     Non-smoker\n4     5 Female        21 Primary           Ekoudou      Student     Non-smoker\n5     5 Male          15 Primary           Ekoudou      Student     Non-smoker\n# ℹ 3 more variables: is_pregnant &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;\n\nyao %&gt;% filter(age &gt;= 70) ## keep respondents aged at least 70\n\n# A tibble: 5 × 10\n    age sex    weight_kg highest_education neighborhood occupation     is_smoker\n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt;    \n1    78 Male          95 Secondary         Briqueterie  Retired--Info… Ex-smoker\n2    79 Female        40 Primary           Briqueterie  Retired        Non-smok…\n3    78 Female        60 Primary           Briqueterie  Unemployed     Non-smok…\n4    75 Male          74 Primary           Briqueterie  Informal work… Non-smok…\n5    72 Male          65 Secondary         Carriere     Retired        Non-smok…\n# ℹ 3 more variables: is_pregnant &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;\n\n### keep respondents whose highest education is \"Primary\" or \"Secondary\"\nyao %&gt;% filter(highest_education %in% c(\"Primary\", \"Secondary\"))\n\n# A tibble: 5 × 10\n    age sex    weight_kg highest_education neighborhood occupation     is_smoker\n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt;    \n1    45 Female        95 Secondary         Briqueterie  Informal work… Non-smok…\n2    20 Female        70 Secondary         Briqueterie  Student        Non-smok…\n3    55 Female        67 Primary           Briqueterie  Trader--Farmer Non-smok…\n4    17 Female        65 Secondary         Briqueterie  Student        Non-smok…\n5    13 Female        65 Secondary         Briqueterie  Student        Non-smok…\n# ℹ 3 more variables: is_pregnant &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;\n\n\n\n\n\n\n\n\nPractice\n\n\n\nFrom yao, keep only respondents who were children (under 18).\nWith %in%, keep only respondents who live in the “Tsinga” or “Messa” neighborhoods."
  },
  {
    "objectID": "untangled_ls02_filter.html#combining-conditions-with-and",
    "href": "untangled_ls02_filter.html#combining-conditions-with-and",
    "title": "10  Filtering rows",
    "section": "10.6 Combining conditions with & and |",
    "text": "10.6 Combining conditions with & and |\nWe can pass multiple conditions to a single filter() statement separated by commas:\n\n### keep respondents who are pregnant and are ex-smokers\nyao %&gt;% filter(is_pregnant == \"Yes\", is_smoker == \"Ex-smoker\") ## only one row\n\n# A tibble: 1 × 10\n    age sex    weight_kg highest_education neighborhood occupation is_smoker\n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;    \n1    25 Female        90 Secondary         Carriere     Home-maker Ex-smoker\n# ℹ 3 more variables: is_pregnant &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;\n\n\nWhen multiple conditions are separated by a comma, they are implicitly combined with an and (&).\nIt is best to replace the comma with & to make this more explicit.\n\n### same result as before, but `&` is more explicit\nyao %&gt;% filter(is_pregnant == \"Yes\" & is_smoker == \"Ex-smoker\")\n\n# A tibble: 1 × 10\n    age sex    weight_kg highest_education neighborhood occupation is_smoker\n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;    \n1    25 Female        90 Secondary         Carriere     Home-maker Ex-smoker\n# ℹ 3 more variables: is_pregnant &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;\n\n\n\n\n\n\n\n\nSide Note\n\n\n\nDon’t confuse:\n\nthe “,” in listing several conditions in filter filter(A,B) i.e. filter based on condition A and (&) condition B\nthe “,” in lists c(A,B) which is listing different components of the list (and has nothing to do with the & operator)\n\n\n\nIf we want to combine conditions with an or, we use the vertical bar symbol, |.\n\n### respondents who are pregnant OR who are ex-smokers\nyao %&gt;% filter(is_pregnant == \"Yes\" | is_smoker == \"Ex-smoker\")\n\n# A tibble: 5 × 10\n    age sex   weight_kg highest_education neighborhood occupation      is_smoker\n  &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;           &lt;chr&gt;    \n1    55 Male         96 University        Briqueterie  Salaried worker Ex-smoker\n2    42 Male         71 Secondary         Briqueterie  Trader          Ex-smoker\n3    38 Male         71 University        Briqueterie  Informal worker Ex-smoker\n4    69 Male        108 University        Briqueterie  Retired         Ex-smoker\n5    65 Male         93 Secondary         Briqueterie  Retired         Ex-smoker\n# ℹ 3 more variables: is_pregnant &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;\n\n\n\n\n\n\n\n\nPractice\n\n\n\nFilter yao to only keep men who tested IgG positive.\nFilter yao to keep both children (under 18) and anyone whose highest education is primary school."
  },
  {
    "objectID": "untangled_ls02_filter.html#negating-conditions-with",
    "href": "untangled_ls02_filter.html#negating-conditions-with",
    "title": "10  Filtering rows",
    "section": "10.7 Negating conditions with !",
    "text": "10.7 Negating conditions with !\nTo negate conditions, we wrap them in !().\nBelow, we drop respondents who are children (less than 18 years) or who weigh less than 30kg:\n\n### drop respondents &lt; 18 years OR &lt; 30 kg\nyao %&gt;% filter(!(age &lt; 18 | weight_kg &lt; 30))\n\n# A tibble: 5 × 10\n    age sex    weight_kg highest_education neighborhood occupation     is_smoker\n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt;    \n1    45 Female        95 Secondary         Briqueterie  Informal work… Non-smok…\n2    55 Male          96 University        Briqueterie  Salaried work… Ex-smoker\n3    23 Male          74 University        Briqueterie  Student        Smoker   \n4    20 Female        70 Secondary         Briqueterie  Student        Non-smok…\n5    55 Female        67 Primary           Briqueterie  Trader--Farmer Non-smok…\n# ℹ 3 more variables: is_pregnant &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;\n\n\nThe ! operator is also used to negate %in% since R does not have an operator for NOT in.\n\n### drop respondents whose highest education is NOT \"Primary\" or \"Secondary\"\nyao %&gt;% filter(!(highest_education %in% c(\"Primary\", \"Secondary\")))\n\n# A tibble: 5 × 10\n    age sex   weight_kg highest_education neighborhood occupation      is_smoker\n  &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;           &lt;chr&gt;    \n1    55 Male         96 University        Briqueterie  Salaried worker Ex-smoker\n2    23 Male         74 University        Briqueterie  Student         Smoker   \n3    28 Male         62 Doctorate         Briqueterie  Student         Non-smok…\n4    38 Male         71 University        Briqueterie  Informal worker Ex-smoker\n5    54 Male         71 University        Briqueterie  Salaried worker Smoker   \n# ℹ 3 more variables: is_pregnant &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;\n\n\n\n\n\n\n\n\nKey Point\n\n\n\nIt is easier to read filter() statements as keep statements, to avoid confusion over whether we are filtering in or filtering out!\nSo the code below would read: “keep respondents who are under 18 or who weigh less than 30kg”.\n\nyao %&gt;% filter(age &lt; 18 | weight_kg &lt; 30)\n\nAnd when we wrap conditions in !(), we can then read filter() statements as drop statements.\nSo the code below would read: “drop respondents who are under 18 or who weigh less than 30kg”.\n\nyao %&gt;% filter(!(age &lt; 18 | weight_kg &lt; 30))\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nFrom yao, drop respondents who live in the Tsinga or Messa neighborhoods."
  },
  {
    "objectID": "untangled_ls02_filter.html#na-values",
    "href": "untangled_ls02_filter.html#na-values",
    "title": "10  Filtering rows",
    "section": "10.8 NA values",
    "text": "10.8 NA values\nThe relational operators introduced so far do not work with NA.\nLet’s make a data subset to illustrate this.\n\nyao_mini &lt;- yao %&gt;% \n  select(sex, is_pregnant) %&gt;% \n  slice(1,11,50,2) ## custom row order\n\nyao_mini\n\n# A tibble: 4 × 2\n  sex    is_pregnant\n  &lt;chr&gt;  &lt;chr&gt;      \n1 Female No         \n2 Female No response\n3 Female Yes        \n4 Male   &lt;NA&gt;       \n\n\nIn yao_mini, the last respondent has an NA for the is_pregnant column, because he is male.\nTrying to select this row using == NA will not work.\n\nyao_mini %&gt;% filter(is_pregnant == NA) ## does not work\n\n# A tibble: 0 × 2\n# ℹ 2 variables: sex &lt;chr&gt;, is_pregnant &lt;chr&gt;\n\nyao_mini %&gt;% filter(is_pregnant == \"NA\") ## does not work\n\n# A tibble: 0 × 2\n# ℹ 2 variables: sex &lt;chr&gt;, is_pregnant &lt;chr&gt;\n\n\nThis is because NA is a non-existent value. So R cannot evaluate whether it is “equal to” or “not equal to” anything.\nThe special function is.na() is therefore necessary:\n\n### keep rows where `is_pregnant` is NA\nyao_mini %&gt;% filter(is.na(is_pregnant)) \n\n# A tibble: 1 × 2\n  sex   is_pregnant\n  &lt;chr&gt; &lt;chr&gt;      \n1 Male  &lt;NA&gt;       \n\n\nThis function can be negated with !:\n\n### drop rows where `is_pregnant` is NA\nyao_mini %&gt;% filter(!is.na(is_pregnant))\n\n# A tibble: 3 × 2\n  sex    is_pregnant\n  &lt;chr&gt;  &lt;chr&gt;      \n1 Female No         \n2 Female No response\n3 Female Yes        \n\n\n\n\n\n\n\n\nSide Note\n\n\n\nFor tibbles, RStudio will highlight NA values bright red to distinguish them from other values:\n\n\n\nA common error with NA\n\n\n\n\n\n\n\n\n\n\nSide Note\n\n\n\nNA values can be identified but any other encoding such as \"NA\" or \"NaN\", which are encoded as strings, will be imperceptible to the functions (they are strings, like any others).\n\n\n\n\n\n\n\n\nPractice\n\n\n\nFrom the yao dataset, keep all the respondents who had missing records for the report of their smoking status.\n\n\n\n\n\n\n\n\nPractice\n\n\n\nFor some respondents the respiration rate, in breaths per minute, was recorded in the respiration_frequency column.\nFrom yaounde, drop those with a respiration frequency under 20. Think about NAs while doing this! You should avoid also dropping the NA values."
  },
  {
    "objectID": "untangled_ls02_filter.html#wrap-up",
    "href": "untangled_ls02_filter.html#wrap-up",
    "title": "10  Filtering rows",
    "section": "10.9 Wrap up",
    "text": "10.9 Wrap up\nNow you know the two essential verbs to select() columns and to filter() rows. This way you keep the variables you are interested in by selecting your columns and you keep the data entries you judge relevant by filtering your rows.\nBut what about modifying, transforming your data? We will learn about this in the next lesson. See you there!\n\n\n\nFig: Basic Data Wrangling: select() and filter().\n\n\n LAURE VANCAUWENBERGHE    Data analyst, the GRAPH Network A firm believer in science for good, striving to ally programming, health and education  ANDREE VALLE CAMPOS    R Developer and Instructor, the GRAPH Network Motivated by reproducible science and education  KENE DAVID NWOSU    Data analyst, the GRAPH Network Passionate about world improvement"
  },
  {
    "objectID": "untangled_ls02_filter.html#references",
    "href": "untangled_ls02_filter.html#references",
    "title": "10  Filtering rows",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nHorst, A. (2021). Dplyr-learnr. https://github.com/allisonhorst/dplyr-learnr (Original work published 2020)\nSubset rows using column values—Filter. (n.d.). Retrieved 12 January 2022, from https://dplyr.tidyverse.org/reference/filter.html\n\nArtwork was adapted from:\n\nHorst, A. (2021). R & stats illustrations by Allison Horst. https://github.com/allisonhorst/stats-illustrations (Original work published 2018)"
  },
  {
    "objectID": "untangled_ls02_filter.html#solutions",
    "href": "untangled_ls02_filter.html#solutions",
    "title": "10  Filtering rows",
    "section": "10.10 Solutions",
    "text": "10.10 Solutions\n\n.SOLUTION_Q_is_pregnant()\n\n \n  yao %&gt;% filter(is_pregnant == 'Yes')\n\n.SOLUTION_Q_female_nrow()\n\n \n      yao %&gt;%\n      filter(sex == 'Female') %&gt;%\n      nrow()\n\n.SOLUTION_Q_under_18()\n\n \n  yao %&gt;% filter(age &lt; 18)\n\n.SOLUTION_Q_tsinga_messa()\n\n \n  yao %&gt;%\n  filter(neighborhood %in% c(\"Tsinga\", \"Messa\"))\n\n.SOLUTION_Q_male_positive()\n\n \n  yao %&gt;%\n  filter(sex == \"Male\" & igg_result == \"Positive\")\n\n.SOLUTION_Q_child_primary()\n\n \n  yao %&gt;% filter(age &lt; 18 | highest_education == \"Primary\")\n\n.SOLUTION_Q_not_tsinga_messa()\n\n \n  yao %&gt;%\n  filter(!(neighborhood %in% c(\"Tsinga\", \"Messa\")))\n\n.SOLUTION_Q_na_smoker()\n\n \n  yao %&gt;% filter(is.na(is_smoker))"
  },
  {
    "objectID": "untangled_ls03_mutate.html#intro",
    "href": "untangled_ls03_mutate.html#intro",
    "title": "11  Mutating columns",
    "section": "11.1 Intro",
    "text": "11.1 Intro\nYou now know how to keep or drop columns and rows from your dataset. Today you will learn how to modify existing variables or create new ones, using the mutate() verb from {dplyr}. This is an essential step in most data analysis projects.\nLet’s go!\n\n\n\nFig: the mutate() verb."
  },
  {
    "objectID": "untangled_ls03_mutate.html#learning-objectives",
    "href": "untangled_ls03_mutate.html#learning-objectives",
    "title": "11  Mutating columns",
    "section": "11.2 Learning objectives",
    "text": "11.2 Learning objectives\n\nYou can use the mutate() function from the {dplyr} package to create new variables or modify existing variables.\nYou can create new numeric, character, factor, and boolean variables"
  },
  {
    "objectID": "untangled_ls03_mutate.html#packages",
    "href": "untangled_ls03_mutate.html#packages",
    "title": "11  Mutating columns",
    "section": "11.3 Packages",
    "text": "11.3 Packages\nThis lesson will require the packages loaded below:\n\nif(!require(pacman)) install.packages(\"pacman\")\npacman::p_load(here, \n               janitor,\n               tidyverse)"
  },
  {
    "objectID": "untangled_ls03_mutate.html#datasets",
    "href": "untangled_ls03_mutate.html#datasets",
    "title": "11  Mutating columns",
    "section": "11.4 Datasets",
    "text": "11.4 Datasets\nIn this lesson, we will again use the data from the COVID-19 serological survey conducted in Yaounde, Cameroon. Below, we import the dataset yaounde and create a smaller subset called yao. Note that this dataset is slightly different from the one used in the previous lesson.\n\nyaounde &lt;- read_csv(here::here('data/yaounde_data.csv'))\n\n### a smaller subset of variables\nyao &lt;- yaounde %&gt;% select(date_surveyed, \n                          age, \n                          weight_kg, height_cm, \n                          symptoms, is_smoker)\n\nyao\n\n# A tibble: 10 × 6\n   date_surveyed   age weight_kg height_cm symptoms                    is_smoker\n   &lt;date&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                       &lt;chr&gt;    \n 1 2020-10-22       45        95       169 Muscle pain                 Non-smok…\n 2 2020-10-24       55        96       185 No symptoms                 Ex-smoker\n 3 2020-10-24       23        74       180 No symptoms                 Smoker   \n 4 2020-10-22       20        70       164 Rhinitis--Sneezing--Anosmi… Non-smok…\n 5 2020-10-22       55        67       147 No symptoms                 Non-smok…\n 6 2020-10-25       17        65       162 Fever--Cough--Rhinitis--Na… Non-smok…\n 7 2020-10-25       13        65       150 Sneezing                    Non-smok…\n 8 2020-10-24       28        62       173 Headache                    Non-smok…\n 9 2020-10-24       30        73       170 Fever--Rhinitis--Anosmia o… Non-smok…\n10 2020-10-24       13        56       153 No symptoms                 Non-smok…\n\n\nWe will also use a dataset from a cross-sectional study that aimed to determine the prevalence of sarcopenia in the elderly population (&gt;60 years) in in Karnataka, India. Sarcopenia is a condition that is common in elderly people and is characterized by progressive and generalized loss of skeletal muscle mass and strength. The data was obtained from Zenodo here, and the source publication can be found here.\nBelow, we import and view this dataset:\n\nsarcopenia &lt;- read_csv(here::here('data/sarcopenia_elderly.csv'))\n\nsarcopenia\n\n# A tibble: 10 × 9\n   number   age age_group sex_male_1_female_0 marital_status height_meters\n    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                   &lt;dbl&gt; &lt;chr&gt;                  &lt;dbl&gt;\n 1      7  60.8 Sixties                     0 married                 1.57\n 2      8  72.3 Seventies                   1 married                 1.65\n 3      9  62.6 Sixties                     0 married                 1.59\n 4     12  72   Seventies                   0 widow                   1.47\n 5     13  60.1 Sixties                     0 married                 1.55\n 6     19  60.6 Sixties                     0 married                 1.42\n 7     45  60.1 Sixties                     1 widower                 1.68\n 8     46  60.2 Sixties                     0 married                 1.8 \n 9     51  63   Sixties                     0 married                 1.6 \n10     56  60.4 Sixties                     0 married                 1.6 \n# ℹ 3 more variables: weight_kg &lt;dbl&gt;, grip_strength_kg &lt;dbl&gt;,\n#   skeletal_muscle_index &lt;dbl&gt;"
  },
  {
    "objectID": "untangled_ls03_mutate.html#introducing-mutate",
    "href": "untangled_ls03_mutate.html#introducing-mutate",
    "title": "11  Mutating columns",
    "section": "11.5 Introducing mutate()",
    "text": "11.5 Introducing mutate()\n\n\n\nThe mutate() function. (Drawing adapted from Allison Horst)\n\n\nWe use dplyr::mutate() to create new variables or modify existing variables. The syntax is quite intuitive, and generally looks like df %&gt;% mutate(new_column_name = what_it_contains).\nLet’s see a quick example.\nThe yaounde dataset currently contains a column called height_cm, which shows the height, in centimeters, of survey respondents. Let’s create a data frame, yao_height, with just this column, for easy illustration:\n\nyao_height &lt;- yaounde %&gt;% select(height_cm)\nyao_height\n\n# A tibble: 5 × 1\n  height_cm\n      &lt;dbl&gt;\n1       169\n2       185\n3       180\n4       164\n5       147\n\n\nWhat if you wanted to create a new variable, called height_meters where heights are converted to meters? You can use mutate() for this, with the argument height_meters = height_cm/100:\n\nyao_height %&gt;% \n  mutate(height_meters = height_cm/100)\n\n# A tibble: 5 × 2\n  height_cm height_meters\n      &lt;dbl&gt;         &lt;dbl&gt;\n1       169          1.69\n2       185          1.85\n3       180          1.8 \n4       164          1.64\n5       147          1.47\n\n\nGreat. The syntax is beautifully simple, isn’t it?\nNow, imagine there was a small error in the equipment used to measure respondent heights, and all heights are 5cm too small. You therefore like to add 5cm to all heights in the dataset. To do this, rather than creating a new variable as you did before, you can modify the existing variable with mutate:\n\nyao_height %&gt;% \n  mutate(height_cm = height_cm + 5)\n\n# A tibble: 5 × 1\n  height_cm\n      &lt;dbl&gt;\n1       174\n2       190\n3       185\n4       169\n5       152\n\n\nAgain, very easy to do!\n\n\n\n\n\n\nPractice\n\n\n\nThe sarcopenia data frame has a variable weight_kg, which contains respondents’ weights in kilograms. Create a new column, called weight_grams, with respondents’ weights in grams. Store your answer in the Q_weight_to_g object. (1 kg equals 1000 grams.)\n\n## Complete the code with your answer:\nQ_weight_to_g &lt;- \n  sarcopenia %&gt;% \n  _____________________\n\n\n\nHopefully you now see that the mutate function is quite user-friendly. In theory, we could end the lesson here, because you now know how to use mutate() 😃. But of course, the devil will be in the details—the interesting thing is not mutate() itself but what goes inside the mutate() call.\nThe rest of the lesson will go through a few use cases for the mutate() verb. In the process, we’ll touch on several new functions you have not yet encountered."
  },
  {
    "objectID": "untangled_ls03_mutate.html#creating-a-boolean-variable",
    "href": "untangled_ls03_mutate.html#creating-a-boolean-variable",
    "title": "11  Mutating columns",
    "section": "11.6 Creating a Boolean variable",
    "text": "11.6 Creating a Boolean variable\nYou can use mutate() to create a Boolean variable to categorize part of your population.\nBelow we create a Boolean variable, is_child which is either TRUE if the subject is a child or FALSE if the subject is an adult (first, we select just the age variable so it’s easy to see what is being done; you will likely not need this pre-selection for your own analyses).\n\nyao %&gt;%\n  select(age) %&gt;% \n  mutate(is_child = age &lt;= 18)\n\n# A tibble: 5 × 2\n    age is_child\n  &lt;dbl&gt; &lt;lgl&gt;   \n1    45 FALSE   \n2    55 FALSE   \n3    23 FALSE   \n4    20 FALSE   \n5    55 FALSE   \n\n\nThe code age &lt;= 18 evaluates whether each age is less than or equal to 18. Ages that match that condition (ages 18 and under) are TRUE and those that fail the condition are FALSE.\nSuch a variable is useful to, for example, count the number of children in the dataset. The code below does this with the janitor::tabyl() function:\n\nyao %&gt;%\n  mutate(is_child = age &lt;= 18) %&gt;% \n  tabyl(is_child)\n\n is_child   n   percent\n    FALSE 662 0.6817714\n     TRUE 309 0.3182286\n\n\nYou can observe that 31.8% (0.318…) of respondents in the dataset are children.\nLet’s see one more example, since the concept of Boolean variables can be a bit confusing. The symptoms variable reports any respiratory symptoms experienced by the patient:\n\nyao %&gt;% \n  select(symptoms)\n\n# A tibble: 5 × 1\n  symptoms                              \n  &lt;chr&gt;                                 \n1 Muscle pain                           \n2 No symptoms                           \n3 No symptoms                           \n4 Rhinitis--Sneezing--Anosmia or ageusia\n5 No symptoms                           \n\n\nYou could create a Boolean variable, called has_no_symptoms, that is set to TRUE if the respondent reported no symptoms:\n\nyao %&gt;% \n  select(symptoms) %&gt;% \n  mutate(has_no_symptoms = symptoms == \"No symptoms\")\n\n# A tibble: 5 × 2\n  symptoms                               has_no_symptoms\n  &lt;chr&gt;                                  &lt;lgl&gt;          \n1 Muscle pain                            FALSE          \n2 No symptoms                            TRUE           \n3 No symptoms                            TRUE           \n4 Rhinitis--Sneezing--Anosmia or ageusia FALSE          \n5 No symptoms                            TRUE           \n\n\nSimilarly, you could create a Boolean variable called has_any_symptoms that is set to TRUE if the respondent reported any symptoms. For this, you’d simply swap the symptoms == \"No symptoms\" code for symptoms != \"No symptoms\":\n\nyao %&gt;% \n  select(symptoms) %&gt;% \n  mutate(has_any_symptoms = symptoms != \"No symptoms\")\n\n# A tibble: 5 × 2\n  symptoms                               has_any_symptoms\n  &lt;chr&gt;                                  &lt;lgl&gt;           \n1 Muscle pain                            TRUE            \n2 No symptoms                            FALSE           \n3 No symptoms                            FALSE           \n4 Rhinitis--Sneezing--Anosmia or ageusia TRUE            \n5 No symptoms                            FALSE           \n\n\nStill confused by the Boolean examples? That’s normal. Pause and play with the code above a little. Then try the practice question below\n\n\n\n\n\n\nPractice\n\n\n\nWomen with a grip strength below 20kg are considered to have low grip strength. With a female subset of the sarcopenia data frame, add a variable called low_grip_strength that is TRUE for women with a grip strength &lt; 20 kg and FALSE for other women.\n\n## Complete the code with your answer:\nQ_women_low_grip_strength &lt;- \n  sarcopenia %&gt;% \n  filter(sex_male_1_female_0 == 0) # first we filter the dataset to only women\n  # mutate code here\n\nWhat percentage of women surveyed have a low grip strength according to the definition above? Enter your answer as a number without quotes (e.g. 43.3 or 12.2), to one decimal place.\n\nQ_prop_women_low_grip_strength &lt;- YOUR_ANSWER_HERE"
  },
  {
    "objectID": "untangled_ls03_mutate.html#creating-a-numeric-variable-based-on-a-formula",
    "href": "untangled_ls03_mutate.html#creating-a-numeric-variable-based-on-a-formula",
    "title": "11  Mutating columns",
    "section": "11.7 Creating a numeric variable based on a formula",
    "text": "11.7 Creating a numeric variable based on a formula\nNow, let’s look at an example of creating a numeric variable, the body mass index (BMI), which a commonly used health indicator. The formula for the body mass index can be written as:\n\\[\nBMI = \\frac{weight (kilograms)}{height (meters)^2}\n\\] You can use mutate() to calculate BMI in the yao dataset as follows:\n\nyao %&gt;%\n  select(weight_kg,  height_cm) %&gt;% \n  \n  # first obtain the height in meters  \n  mutate(height_meters = height_cm/100) %&gt;% \n  \n  # then use the BMI formula\n  mutate(bmi = weight_kg / (height_meters)^2)\n\n# A tibble: 5 × 4\n  weight_kg height_cm height_meters   bmi\n      &lt;dbl&gt;     &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;\n1        95       169          1.69  33.3\n2        96       185          1.85  28.0\n3        74       180          1.8   22.8\n4        70       164          1.64  26.0\n5        67       147          1.47  31.0\n\n\nLet’s save the data frame with BMIs for later. We will use it in the next section.\n\nyao_bmi &lt;- \n  yao %&gt;%\n  select(weight_kg,  height_cm) %&gt;% \n  # first obtain the height in meters  \n  mutate(height_meters = height_cm/100) %&gt;% \n  # then use the BMI formula\n  mutate(bmi = weight_kg / (height_meters)^2)\n\n\n\n\n\n\n\nPractice\n\n\n\nAppendicular muscle mass (ASM), a useful health indicator, is the sum of muscle mass in all 4 limbs. It can predicted with the following formula, called Lee’s equation:\n\\[ASM(kg)= (0.244 \\times weight(kg)) + (7.8 \\times height(m)) + (6.6 \\times sex) - (0.098 \\times age) - 4.5\\]\nThe sex variable in the formula assumes that men are coded as 1 and women are coded as 0 (which is already the case for our sarcopenia dataset.) The - 4.5 at the end is a constant used for Asians.\nCalculate the ASM value for all individuals in the sarcopenia dataset. This value should be in a new column called asm\n\n## Complete the code with your answer:\nQ_asm_calculation &lt;- \n  sarcopenia #_____\n  #________________"
  },
  {
    "objectID": "untangled_ls03_mutate.html#changing-a-variables-type",
    "href": "untangled_ls03_mutate.html#changing-a-variables-type",
    "title": "11  Mutating columns",
    "section": "11.8 Changing a variable’s type",
    "text": "11.8 Changing a variable’s type\nIn your data analysis workflow, you often need to redefine variable types. You can do so with functions like as.integer(), as.factor(), as.character() and as.Date() within your mutate() call. Let’s see one example of this.\n\n11.8.1 Integer: as.integer\nas.integer() converts any numeric values to integers:\n\nyao_bmi %&gt;% \n  mutate(bmi_integer = as.integer(bmi))\n\n# A tibble: 5 × 5\n  weight_kg height_cm height_meters   bmi bmi_integer\n      &lt;dbl&gt;     &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;       &lt;int&gt;\n1        95       169          1.69  33.3          33\n2        96       185          1.85  28.0          28\n3        74       180          1.8   22.8          22\n4        70       164          1.64  26.0          26\n5        67       147          1.47  31.0          31\n\n\nNote that this truncates integers rather than rounding them up or down, as you might expect. For example the BMI 22.8 in the third row is truncated to 22. If you want rounded numbers, you can use the round function from base R\n\n\n\n\n\n\nPro Tip\n\n\n\nUsing as.integer() on a factor variable is a fast way of encoding strings into numbers. It can be essential to do so for some machine learning data processing.\n\n\n\nyao_bmi %&gt;% \n  mutate(bmi_integer = as.integer(bmi), \n         bmi_rounded = round(bmi)) \n\n# A tibble: 5 × 6\n  weight_kg height_cm height_meters   bmi bmi_integer bmi_rounded\n      &lt;dbl&gt;     &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;       &lt;int&gt;       &lt;dbl&gt;\n1        95       169          1.69  33.3          33          33\n2        96       185          1.85  28.0          28          28\n3        74       180          1.8   22.8          22          23\n4        70       164          1.64  26.0          26          26\n5        67       147          1.47  31.0          31          31\n\n\n\n\n\n\n\n\nSide Note\n\n\n\nThe base R round() function rounds “half down”. That is, the number 3.5, for example, is rounded down to 3 by round(). This is weird. Most people expect 3.5 to be rounded up to 4, not down to 3. So most of the time, you’ll actually want to use the round_half_up() function from janitor.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIn future lessons, you will discover how to manipulate dates and how to convert to a date type using as.Date().\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUse as_integer() to convert the ages of respondents in the sarcopenia dataset to integers (truncating them in the process). This should go in a new column called age_integer\n\n## Complete the code with your answer:\nQ_age_integer &lt;- \n  sarcopenia #_____\n  #________________"
  },
  {
    "objectID": "untangled_ls03_mutate.html#wrap-up",
    "href": "untangled_ls03_mutate.html#wrap-up",
    "title": "11  Mutating columns",
    "section": "11.9 Wrap up",
    "text": "11.9 Wrap up\nAs you can imagine, transforming data is an essential step in any data analysis workflow. It is often required to clean data and to prepare it for further statistical analysis or for making plots. And as you have seen, it is quite simple to transform data with dplyr’s mutate() function, although certain transformations are trickier to achieve than others.\nCongrats on making it through.\nBut your data wrangling journey isn’t over yet! In our next lessons, we will learn how to create complex data summaries and how to create and work with data frame groups. Intrigued? See you in the next lesson.\n\n\n\nFig: Basic Data Wrangling with select(), filter(), and mutate().\n\n\n LAURE VANCAUWENBERGHE    Data analyst, the GRAPH Network A firm believer in science for good, striving to ally programming, health and education  ANDREE VALLE CAMPOS    R Developer and Instructor, the GRAPH Network Motivated by reproducible science and education  KENE DAVID NWOSU    Data analyst, the GRAPH Network Passionate about world improvement"
  },
  {
    "objectID": "untangled_ls03_mutate.html#references",
    "href": "untangled_ls03_mutate.html#references",
    "title": "11  Mutating columns",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nHorst, A. (2022). Dplyr-learnr. https://github.com/allisonhorst/dplyr-learnr (Original work published 2020)\nCreate, modify, and delete columns — Mutate. (n.d.). Retrieved 21 February 2022, from https://dplyr.tidyverse.org/reference/mutate.html\nApply a function (or functions) across multiple columns — Across. (n.d.). Retrieved 21 February 2022, from https://dplyr.tidyverse.org/reference/across.html\n\nArtwork was adapted from:\n\nHorst, A. (2022). R & stats illustrations by Allison Horst. https://github.com/allisonhorst/stats-illustrations (Original work published 2018)\n\nOther references:\n\nLee, Robert C, ZiMian Wang, Moonseong Heo, Robert Ross, Ian Janssen, and Steven B Heymsfield. “Total-Body Skeletal Muscle Mass: Development and Cross-Validation of Anthropometric Prediction Models.” The American Journal of Clinical Nutrition 72, no. 3 (2000): 796–803. https://doi.org/10.1093/ajcn/72.3.796."
  },
  {
    "objectID": "untangled_ls03_mutate.html#solutions",
    "href": "untangled_ls03_mutate.html#solutions",
    "title": "11  Mutating columns",
    "section": "11.10 Solutions",
    "text": "11.10 Solutions\n\n.SOLUTION_Q_weight_to_g()\n\n\n\nQ_weight_to_g &lt;- \n  sarcopenia %&gt;% \n  mutate(weight_grams = weight_kg*1000)\n\n.SOLUTION_Q_sarcopenia_resp_id()\n\n\n\nQ_sarcopenia_resp_id &lt;-\n  sarcopenia %&gt;%\n  mutate(respondent_id = 1:n())\n\n.SOLUTION_Q_women_low_grip_strength()\n\n\n\n\nQ_women_low_grip_strength &lt;-\n  sarcopenia %&gt;%\n  filter(sex_male_1_female_0 == 0) %&gt;%\n  mutate(low_grip_strength = grip_strength_kg &lt; 20)\n  \n\n.SOLUTION_Q_prop_women_low_grip_strength()\n\n\n\n\nQ_prop_women_low_grip_strength &lt;- \n  sarcopenia %&gt;% \n  filter(sex_male_1_female_0 == 0) %&gt;% \n  mutate(low_grip_strength = grip_strength_kg &lt; 20) %&gt;% \n  tabyl(low_grip_strength) %&gt;% \n  .[2,3] * 100\n  \n\n.SOLUTION_Q_asm_calculation()\n\n\n\n\nQ_asm_calculation &lt;-\n   sarcopenia %&gt;%\n   mutate(asm = 0.244 * weight_kg + 7.8 * height_meters + 6.6 * sex_male_1_female_0 - 0.098 * age - 4.5)\n  \n\n.SOLUTION_Q_age_integer()\n\n\n\n\nQ_age_integer &lt;-\n   sarcopenia %&gt;%\n   mutate(age_integer = as.integer(age))"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#introduction",
    "href": "untangled_ls04_conditional_mutate.html#introduction",
    "title": "12  Conditional mutating",
    "section": "12.1 Introduction",
    "text": "12.1 Introduction\nIn the last lesson, you learned the basics of data transformation using the {dplyr} function mutate().\nIn that lesson, we mostly looked at global transformations; that is, transformations that did the same thing to an entire variable. In this lesson, we will look at how to conditionally manipulate certain rows based on whether or not they meet defined criteria.\nFor this, we will mostly use the case_when() function, which you will likely come to see as one of the most important functions in {dplyr} for data wrangling tasks.\nLet’s get started.\n\n\n\nFig: the case_when() conditions."
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#learning-objectives",
    "href": "untangled_ls04_conditional_mutate.html#learning-objectives",
    "title": "12  Conditional mutating",
    "section": "12.2 Learning objectives",
    "text": "12.2 Learning objectives\n\nYou can transform or create new variables based on conditions using dplyr::case_when()\nYou know how to use the TRUE condition in case_when() to match unmatched cases.\nYou can handle NA values in case_when() transformations.\nYou understand how to keep the default values of a variable in a case_when() formula\nYou can write case_when() conditions involving multiple comparators and multiple variables.\nYou understand case_when() conditions priority order.\nYou can use dplyr::if_else() for binary conditional assignment."
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#packages",
    "href": "untangled_ls04_conditional_mutate.html#packages",
    "title": "12  Conditional mutating",
    "section": "12.3 Packages",
    "text": "12.3 Packages\nThis lesson will require the tidyverse suite of packages:\n\nif(!require(pacman)) install.packages(\"pacman\")\npacman::p_load(tidyverse)"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#datasets",
    "href": "untangled_ls04_conditional_mutate.html#datasets",
    "title": "12  Conditional mutating",
    "section": "12.4 Datasets",
    "text": "12.4 Datasets\nIn this lesson, we will again use data from the COVID-19 serological survey conducted in Yaounde, Cameroon.\n\n## Import and view the dataset\nyaounde &lt;- \n  read_csv(here::here('data/yaounde_data.csv')) %&gt;% \n  ## make every 5th age missing\n  mutate(age = case_when(row_number() %in% seq(5, 900, by = 5) ~ NA_real_,\n                         TRUE ~ age)) %&gt;% \n  ## rename the age variable \n  rename(age_years = age) %&gt;%\n  # drop the age category column\n  select(-age_category)\n\nyaounde\n\n# A tibble: 10 × 52\n   id             date_surveyed age_years age_category_3 sex   highest_education\n   &lt;chr&gt;          &lt;date&gt;            &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt; &lt;chr&gt;            \n 1 BRIQUETERIE_0… 2020-10-22           45 Adult          Fema… Secondary        \n 2 BRIQUETERIE_0… 2020-10-24           55 Adult          Male  University       \n 3 BRIQUETERIE_0… 2020-10-24           23 Adult          Male  University       \n 4 BRIQUETERIE_0… 2020-10-22           20 Adult          Fema… Secondary        \n 5 BRIQUETERIE_0… 2020-10-22           NA Adult          Fema… Primary          \n 6 BRIQUETERIE_0… 2020-10-25           17 Child          Fema… Secondary        \n 7 BRIQUETERIE_0… 2020-10-25           13 Child          Fema… Secondary        \n 8 BRIQUETERIE_0… 2020-10-24           28 Adult          Male  Doctorate        \n 9 BRIQUETERIE_0… 2020-10-24           30 Adult          Male  Secondary        \n10 BRIQUETERIE_0… 2020-10-24           NA Child          Fema… Secondary        \n# ℹ 46 more variables: occupation &lt;chr&gt;, weight_kg &lt;dbl&gt;, height_cm &lt;dbl&gt;,\n#   is_smoker &lt;chr&gt;, is_pregnant &lt;chr&gt;, is_medicated &lt;chr&gt;, neighborhood &lt;chr&gt;,\n#   household_with_children &lt;chr&gt;, breadwinner &lt;chr&gt;, source_of_revenue &lt;chr&gt;,\n#   has_contact_covid &lt;chr&gt;, igg_result &lt;chr&gt;, igm_result &lt;chr&gt;,\n#   symptoms &lt;chr&gt;, symp_fever &lt;chr&gt;, symp_headache &lt;chr&gt;, symp_cough &lt;chr&gt;,\n#   symp_rhinitis &lt;chr&gt;, symp_sneezing &lt;chr&gt;, symp_fatigue &lt;chr&gt;,\n#   symp_muscle_pain &lt;chr&gt;, symp_nausea_or_vomiting &lt;chr&gt;, …\n\n\nNote that in the code chunk above, we slightly modified the age column, artificially introducing some missing values, and we also dropped the age_category column. This is to help illustrate some key points in the tutorial.\n\nFor practice questions, we will also use an outbreak linelist of 136 cases of influenza A H7N9 from a 2013 outbreak in China. This is a modified version of a dataset compiled by Kucharski et al. (2014).\n\n## Import and view the dataset\nflu_linelist &lt;- read_csv(here::here('data/flu_h7n9_china_2013.csv'))\nflu_linelist\n\n# A tibble: 10 × 8\n   case_id date_of_onset date_of_hospitalisation date_of_outcome outcome gender\n     &lt;dbl&gt; &lt;date&gt;        &lt;date&gt;                  &lt;date&gt;          &lt;chr&gt;   &lt;chr&gt; \n 1       1 2013-02-19    NA                      2013-03-04      Death   m     \n 2       2 2013-02-27    2013-03-03              2013-03-10      Death   m     \n 3       3 2013-03-09    2013-03-19              2013-04-09      Death   f     \n 4       4 2013-03-19    2013-03-27              NA              &lt;NA&gt;    f     \n 5       5 2013-03-19    2013-03-30              2013-05-15      Recover f     \n 6       6 2013-03-21    2013-03-28              2013-04-26      Death   f     \n 7       7 2013-03-20    2013-03-29              2013-04-09      Death   m     \n 8       8 2013-03-07    2013-03-18              2013-03-27      Death   m     \n 9       9 2013-03-25    2013-03-25              NA              &lt;NA&gt;    m     \n10      10 2013-03-28    2013-04-01              2013-04-03      Death   m     \n# ℹ 2 more variables: age &lt;dbl&gt;, province &lt;chr&gt;"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#reminder-relational-operators-comparators-in-r",
    "href": "untangled_ls04_conditional_mutate.html#reminder-relational-operators-comparators-in-r",
    "title": "12  Conditional mutating",
    "section": "12.5 Reminder: relational operators (comparators) in R",
    "text": "12.5 Reminder: relational operators (comparators) in R\nThroughout this lesson, you will use a lot of relational operators in R. Recall that relational operators, sometimes called “comparators”, test the relation between two values, and return TRUE, FALSE or NA.\nA list of the most common operators is given below:\n\n\n\nOperator\nis TRUE if\n\n\nA &lt; B\nA is less than B\n\n\nA &lt;= B\nA is less than or equal to B\n\n\nA &gt; B\nA is greater than B\n\n\nA &gt;= B\nA is greater than or equal to B\n\n\nA == B\nA is equal to B\n\n\nA != B\nA is not equal to B\n\n\nA %in% B\nA is an element of B"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#introduction-to-case_when",
    "href": "untangled_ls04_conditional_mutate.html#introduction-to-case_when",
    "title": "12  Conditional mutating",
    "section": "12.6 Introduction to case_when()",
    "text": "12.6 Introduction to case_when()\nTo get familiar with case_when(), let’s begin with a simple conditional transformation on the age_years column of the yaounde dataset. First we subset the data frame to just the age_years column for easy illustration:\n\nyaounde_age &lt;- \n  yaounde %&gt;% \n  select(age_years)\n\nyaounde_age\n\n# A tibble: 10 × 1\n   age_years\n       &lt;dbl&gt;\n 1        45\n 2        55\n 3        23\n 4        20\n 5        NA\n 6        17\n 7        13\n 8        28\n 9        30\n10        NA\n\n\nNow, using case_when(), we can make a new column, called “age_group”, that has the value “Child” if the person is below 18, and “Adult” if the person is 18 and up:\n\nyaounde_age %&gt;%  \n  mutate(age_group = case_when(age_years &lt; 18 ~ \"Child\", \n                               age_years &gt;= 18 ~ \"Adult\"))\n\n# A tibble: 10 × 2\n   age_years age_group\n       &lt;dbl&gt; &lt;chr&gt;    \n 1        45 Adult    \n 2        55 Adult    \n 3        23 Adult    \n 4        20 Adult    \n 5        NA &lt;NA&gt;     \n 6        17 Child    \n 7        13 Child    \n 8        28 Adult    \n 9        30 Adult    \n10        NA &lt;NA&gt;     \n\n\nThe case_when() syntax may seem a bit foreign, but it is quite simple: on the left-hand side (LHS) of the ~ sign (called a “tilde”), you provide the condition(s) you want to evaluate, and on the right-hand side (RHS), you provide a value to put in if the condition is true.\nSo the statement case_when(age_years &lt; 18 ~ \"Child\", age_years &gt;= 18 ~ \"Adult\") can be read as: “if age_years is below 18, input ‘Child’, else if age_years is greater than or equal to 18, input ‘Adult’”.\n\n\n\n\n\n\nVocab\n\n\n\nFormulas, LHS and RHS\nEach line of a case_when() call is termed a “formula” or, sometimes, a “two-sided formula”. And each formula has a left-hand side (abbreviated LHS) and right-hand side (abbreviated RHS).\nFor example, the code age_years &lt; 18 ~ \"Child\" is a “formula”, its LHS is age_years &lt; 18 while its RHS is \"Child\".\nYou are likely to come across these terms when reading the documentation for the case_when() function, and we will also refer to them in this lesson.\n\n\n\nAfter creating a new variable with case_when(), it is a good idea to inspect it thoroughly to make sure it worked as intended.\nTo inspect the variable, you can pipe your data frame into the View() function to view it in spreadsheet form:\n\nyaounde_age %&gt;%  \n  mutate(age_group = case_when(age_years &lt; 18 ~ \"Child\", \n                               age_years &gt;= 18 ~ \"Adult\")) %&gt;% \n  View()\n\nThis would open up a new tab in RStudio where you should manually scan through the new column, age_group and the referenced column age_years to make sure your case_when() statement did what you wanted it to do.\nYou could also pass the new column into the tabyl() function to ensure that the proportions “make sense”:\n\nyaounde_age %&gt;%  \n  mutate(age_group = case_when(age_years &lt; 18 ~ \"Child\", \n                               age_years &gt;= 18 ~ \"Adult\")) %&gt;% \n  tabyl(age_group)\n\n age_group   n   percent valid_percent\n     Adult 558 0.5746653     0.7054362\n     Child 233 0.2399588     0.2945638\n      &lt;NA&gt; 180 0.1853759            NA\n\n\n\n\n\n\n\n\nPractice\n\n\n\nWith the flu_linelist data, make a new column, called age_group, that has the value “Below 50” for people under 50 and “50 and above” for people aged 50 and up. Use the case_when() function.\n\n## Complete the code with your answer:\nQ_age_group &lt;- \n  flu_linelist %&gt;% \n  mutate(age_group = ______________________________)\n\nOut of the entire sample of individuals in the flu_linelist dataset, what percentage are confirmed to be below 60? (Repeat the above procedure but with the 60 cutoff, then call tabyl() on the age group variable. Use the percent column, not the valid_percent column.)\n\n## Enter your answer as a WHOLE number without quotes:\nQ_age_group_percentage &lt;- YOUR_ANSWER_HERE"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#the-true-default-argument",
    "href": "untangled_ls04_conditional_mutate.html#the-true-default-argument",
    "title": "12  Conditional mutating",
    "section": "12.7 The TRUE default argument",
    "text": "12.7 The TRUE default argument\nIn a case_when() statement, you can use a literal TRUE condition to match any rows not yet matched with provided conditions.\nFor example, if we only keep only the first condition from the previous example, age_years &lt; 18, and define the default value to be TRUE ~ \"Not child\" then all adults and NA values in the data set will be labeled \"Not child\" by default.\n\nyaounde_age %&gt;%  \n  mutate(age_group = case_when(age_years &lt; 18 ~ \"Child\",\n                               TRUE ~ \"Not child\"))\n\n# A tibble: 10 × 2\n   age_years age_group\n       &lt;dbl&gt; &lt;chr&gt;    \n 1        45 Not child\n 2        55 Not child\n 3        23 Not child\n 4        20 Not child\n 5        NA Not child\n 6        17 Child    \n 7        13 Child    \n 8        28 Not child\n 9        30 Not child\n10        NA Not child\n\n\nThis TRUE condition can be read as “for everything else…”.\nSo the full case_when() statement used above, age_years &lt; 18 ~ \"Child\", TRUE ~ \"Not child\", would then be read as: “if age is below 18, input ‘Child’ and for everyone else not yet matched, input ‘Not child’”.\n\n\n\n\n\n\nWatch Out\n\n\n\nIt is important to use TRUE as the final condition in case_when(). If you use it as the first condition, it will take precedence over all others, as seen here:\n\nyaounde_age %&gt;%\n  mutate(age_group = case_when(TRUE ~ \"Not child\",\n                               age_years &lt; 18 ~ \"Child\"))\n\n# A tibble: 10 × 2\n   age_years age_group\n       &lt;dbl&gt; &lt;chr&gt;    \n 1        45 Not child\n 2        55 Not child\n 3        23 Not child\n 4        20 Not child\n 5        NA Not child\n 6        17 Not child\n 7        13 Not child\n 8        28 Not child\n 9        30 Not child\n10        NA Not child\n\n\nAs you can observe, all individuals are now coded with “Not child”, because the TRUE condition was placed first, and therefore took precedence. We will explore the issue of precedence further below."
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#matching-nas-with-is.na",
    "href": "untangled_ls04_conditional_mutate.html#matching-nas-with-is.na",
    "title": "12  Conditional mutating",
    "section": "12.8 Matching NA’s with is.na()",
    "text": "12.8 Matching NA’s with is.na()\nWe can match missing values manually with is.na(). Below we match NA ages with is.na() and set their age group to “Missing age”:\n\nyaounde_age %&gt;%  \n  mutate(age_group = case_when(age_years &lt; 18 ~ \"Child\", \n                               age_years &gt;= 18 ~ \"Adult\", \n                               is.na(age_years) ~ \"Missing age\"))\n\n# A tibble: 10 × 2\n   age_years age_group  \n       &lt;dbl&gt; &lt;chr&gt;      \n 1        45 Adult      \n 2        55 Adult      \n 3        23 Adult      \n 4        20 Adult      \n 5        NA Missing age\n 6        17 Child      \n 7        13 Child      \n 8        28 Adult      \n 9        30 Adult      \n10        NA Missing age\n\n\n\n\n\n\n\n\nPractice\n\n\n\nAs before, using the flu_linelist data, make a new column, called age_group, that has the value “Below 60” for people under 60 and “60 and above” for people aged 60 and up. But this time, also set those with missing ages to “Missing age”.\n\n## Complete the code with your answer:\nQ_age_group_nas &lt;- \n  flu_linelist %&gt;% \n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nThe gender column of the flu_linelist dataset contains the values “f”, “m” and NA:\n\nflu_linelist %&gt;% \n  tabyl(gender)\n\n gender  n    percent valid_percent\n      f 39 0.28676471     0.2910448\n      m 95 0.69852941     0.7089552\n   &lt;NA&gt;  2 0.01470588            NA\n\n\nRecode “f”, “m” and NA to “Female”, “Male” and “Missing gender” respectively. You should modify the existing gender column, not create a new column.\n\n## Complete the code with your answer:\nQ_gender_recode &lt;- \n  flu_linelist %&gt;%"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#keeping-default-values-of-a-variable",
    "href": "untangled_ls04_conditional_mutate.html#keeping-default-values-of-a-variable",
    "title": "12  Conditional mutating",
    "section": "12.9 Keeping default values of a variable",
    "text": "12.9 Keeping default values of a variable\nThe right-hand side (RHS) of a case_when() formula can also take in a variable from your data frame. This is often useful when you want to change just a few values in a column.\nLet’s see an example with the highest_education column, which contains the highest education level attained by a respondent:\n\nyaounde_educ &lt;- \n  yaounde %&gt;% \n  select(highest_education)\nyaounde_educ\n\n# A tibble: 10 × 1\n   highest_education\n   &lt;chr&gt;            \n 1 Secondary        \n 2 University       \n 3 University       \n 4 Secondary        \n 5 Primary          \n 6 Secondary        \n 7 Secondary        \n 8 Doctorate        \n 9 Secondary        \n10 Secondary        \n\n\nBelow, we create a new column, highest_educ_recode, where we recode both “University” and “Doctorate” to the value “Post-secondary”:\n\nyaounde_educ %&gt;%\n  mutate(\n    highest_educ_recode =\n      case_when(\n        highest_education %in% c(\"University\", \"Doctorate\") ~ \"Post-secondary\"\n      )\n  )\n\n# A tibble: 10 × 2\n   highest_education highest_educ_recode\n   &lt;chr&gt;             &lt;chr&gt;              \n 1 Secondary         &lt;NA&gt;               \n 2 University        Post-secondary     \n 3 University        Post-secondary     \n 4 Secondary         &lt;NA&gt;               \n 5 Primary           &lt;NA&gt;               \n 6 Secondary         &lt;NA&gt;               \n 7 Secondary         &lt;NA&gt;               \n 8 Doctorate         Post-secondary     \n 9 Secondary         &lt;NA&gt;               \n10 Secondary         &lt;NA&gt;               \n\n\nIt worked, but now we have NAs for all other rows. To keep these other rows at their default values, we can add the line TRUE ~ highest_education (with a variable, highest_education, on the right-hand side of a formula):\n\nyaounde_educ %&gt;%\n  mutate(\n    highest_educ_recode =\n      case_when(\n        highest_education %in% c(\"University\", \"Doctorate\") ~ \"Post-secondary\",\n        TRUE ~ highest_education\n      )\n  )\n\n# A tibble: 10 × 2\n   highest_education highest_educ_recode\n   &lt;chr&gt;             &lt;chr&gt;              \n 1 Secondary         Secondary          \n 2 University        Post-secondary     \n 3 University        Post-secondary     \n 4 Secondary         Secondary          \n 5 Primary           Primary            \n 6 Secondary         Secondary          \n 7 Secondary         Secondary          \n 8 Doctorate         Post-secondary     \n 9 Secondary         Secondary          \n10 Secondary         Secondary          \n\n\nNow the case_when() statement reads: ‘If highest education is “University” or “Doctorate”, input “Post-secondary”. For everyone else, input the value from highest_education’.\n\nAbove we have been putting the recoded values in a separate column, highest_educ_recode, but for this kind of replacement, it is more common to simply overwrite the existing column:\n\nyaounde_educ %&gt;%\n  mutate(\n    highest_education =\n      case_when(\n        highest_education %in% c(\"University\", \"Doctorate\") ~ \"Post-secondary\",\n        TRUE ~ highest_education\n      )\n  )\n\n# A tibble: 10 × 1\n   highest_education\n   &lt;chr&gt;            \n 1 Secondary        \n 2 Post-secondary   \n 3 Post-secondary   \n 4 Secondary        \n 5 Primary          \n 6 Secondary        \n 7 Secondary        \n 8 Post-secondary   \n 9 Secondary        \n10 Secondary        \n\n\nWe can read this last case_when() statement as: ‘If highest education is “University” or “Doctorate”, change the value to “Post-secondary”. For everyone else, leave in the value from highest_education’.\n\n\n\n\n\n\nPractice\n\n\n\nUsing the flu_linelist data, modify the existing column outcome by replacing the value “Recover” with “Recovery”.\n\n## Complete the code with your answer:\nQ_recode_recovery &lt;- \n  flu_linelist \n\n(We know it’s a lot of code for such a simple change. Later you will see easier ways to do this.)\n\n\n\n\n\n\n\n\nPro Tip\n\n\n\nAvoiding long code lines As you start to write increasingly complex case_when() statements, it will become helpful to use line breaks to avoid long lines of code.\nTo assist with creating line breaks, you can use the {styler} package. Install it with pacman::p_load(styler). Then to reformat any piece of code, highlight the code, click the “Addins” button in RStudio, then click on “Style selection”:\n\nAlternatively, you could highlight the code and use the shortcut Shift + Command/Control + A to use RStudio’s built-in code reformatter.\nSometimes {styler} does a better job at reformatting. Sometimes the built-in reformatter does a better job."
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#multiple-conditions-on-a-single-variable",
    "href": "untangled_ls04_conditional_mutate.html#multiple-conditions-on-a-single-variable",
    "title": "12  Conditional mutating",
    "section": "12.10 Multiple conditions on a single variable",
    "text": "12.10 Multiple conditions on a single variable\nLHS conditions in case_when() formulas can have multiple parts. Let’s see an example of this.\nBut first, we will inspire ourselves from what we learnt in the mutate() lesson and recreate the BMI variable. This involves first converting the height_cm variable to meters, then calculating BMI.\n\nyaounde_BMI &lt;-\n  yaounde %&gt;%\n  mutate(height_m = height_cm/100,\n         BMI = (weight_kg / (height_m)^2)) %&gt;%\n  select(BMI)\n\nyaounde_BMI\n\n# A tibble: 10 × 1\n     BMI\n   &lt;dbl&gt;\n 1  33.3\n 2  28.0\n 3  22.8\n 4  26.0\n 5  31.0\n 6  24.8\n 7  28.9\n 8  20.7\n 9  25.3\n10  23.9\n\n\nRecall the following BMI categories:\n\nIf the BMI is inferior to 18.5, the person is considered underweight.\nA normal BMI is greater than or equal to 18.5 and less than 25.\nAn overweight BMI is greater than or equal to 25 and less than 30.\nAn obese BMI is BMI is greater than or equal to 30.\n\nThe condition BMI &gt;= 18.5 & BMI &lt; 25 to define Normal weight is a compound condition because it has two comparators: &gt;= and &lt;.\n\nyaounde_BMI &lt;-\n  yaounde_BMI %&gt;%\n  mutate(BMI_classification = case_when(\n    BMI &lt; 18.5 ~'Underweight',\n    BMI &gt;= 18.5 & BMI &lt; 25 ~ 'Normal weight',\n    BMI &gt;= 25 & BMI &lt; 30 ~ 'Overweight',\n    BMI &gt;= 30 ~ 'Obese'))\n\nyaounde_BMI\n\n# A tibble: 10 × 2\n     BMI BMI_classification\n   &lt;dbl&gt; &lt;chr&gt;             \n 1  33.3 Obese             \n 2  28.0 Overweight        \n 3  22.8 Normal weight     \n 4  26.0 Overweight        \n 5  31.0 Obese             \n 6  24.8 Normal weight     \n 7  28.9 Overweight        \n 8  20.7 Normal weight     \n 9  25.3 Overweight        \n10  23.9 Normal weight     \n\n\nLet’s use tabyl() to have a look at our data:\n\nyaounde_BMI %&gt;%\n  tabyl(BMI_classification)\n\nBut you can see that the levels of BMI are defined in alphabetical order from Normal weight to Underweight, instead of from lightest (Underweight) to heaviest (Obese). Remember that if you want to have a certain order you can make BMI_classification a factor using mutate() and define its levels.\n\nyaounde_BMI %&gt;%\n  mutate(BMI_classification = factor(\n    BMI_classification,\n    levels = c(\"Obese\",\n               \"Overweight\",\n               \"Normal weight\",\n               \"Underweight\")\n  )) %&gt;%\n  tabyl(BMI_classification)\n\n\n\n\n\n\n\nWatch Out\n\n\n\nWith compound conditions, you should remember to input the variable name everytime there is a comparator. R learners often forget this and will try to run code that looks like this:\n\nyaounde_BMI %&gt;%\n  mutate(BMI_classification = case_when(BMI &lt; 18.5 ~'Underweight',\n                                        BMI &gt;= 18.5 & &lt; 25 ~ 'Normal weight',\n                                        BMI &gt;= 25 & &lt; 30 ~ 'Overweight',\n                                        BMI &gt;= 30 ~ 'Obese'))\n\nThe definitions for the “Normal weight” and “Overweight” categories are mistaken. Do you see the problem? Try to run the code to spot the error.\n\n\n\n\n\n\n\n\nPractice\n\n\n\nWith the flu_linelist data, make a new column, called adolescent, that has the value “Yes” for people in the 10-19 (at least 10 and less than 20) age group, and “No” for everyone else.\n\n## Complete the code with your answer:\nQ_adolescent_grouping &lt;- \n  flu_linelist %&gt;%"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#multiple-conditions-on-multiple-variables",
    "href": "untangled_ls04_conditional_mutate.html#multiple-conditions-on-multiple-variables",
    "title": "12  Conditional mutating",
    "section": "12.11 Multiple conditions on multiple variables",
    "text": "12.11 Multiple conditions on multiple variables\nIn all examples seen so far, you have only used conditions involving a single variable at a time. But LHS conditions often refer to multiple variables at once.\nLet’s see a simple example with age and sex in the yaounde data frame. First, we select just these two variables for easy illustration:\n\nyaounde_age_sex &lt;- \n  yaounde %&gt;% \n  select(age_years, sex)\n\nyaounde_age_sex\n\n# A tibble: 10 × 2\n   age_years sex   \n       &lt;dbl&gt; &lt;chr&gt; \n 1        45 Female\n 2        55 Male  \n 3        23 Male  \n 4        20 Female\n 5        NA Female\n 6        17 Female\n 7        13 Female\n 8        28 Male  \n 9        30 Male  \n10        NA Female\n\n\nNow, imagine we want to recruit women and men in the 20-29 age group into two studies. For this we’d like to create a column, called recruit, with the following schema:\n\nWomen aged 20-29 should have the value “Recruit to female study”\nMen aged 20-29 should have the value “Recruit to male study”\nEveryone else should have the value “Do not recruit”\n\nTo do this, we run the following case_when statement:\n\nyaounde_age_sex %&gt;%\n  mutate(recruit = case_when(\n    sex == \"Female\" & age_years &gt;= 20 & age_years &lt;= 29 ~ \"Recruit to female study\",\n    sex == \"Male\" & age_years &gt;= 20 & age_years &lt;= 29 ~ \"Recruit to male study\",\n    TRUE ~ \"Do not recruit\"\n  ))\n\n# A tibble: 10 × 3\n   age_years sex    recruit                \n       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;                  \n 1        45 Female Do not recruit         \n 2        55 Male   Do not recruit         \n 3        23 Male   Recruit to male study  \n 4        20 Female Recruit to female study\n 5        NA Female Do not recruit         \n 6        17 Female Do not recruit         \n 7        13 Female Do not recruit         \n 8        28 Male   Recruit to male study  \n 9        30 Male   Do not recruit         \n10        NA Female Do not recruit         \n\n\nYou could also add extra pairs of parentheses around the age criteria within each condition:\n\nyaounde_age_sex %&gt;%\n  mutate(recruit = case_when(\n    sex == \"Female\" & (age_years &gt;= 20 & age_years &lt;= 29) ~ \"Recruit to female study\",\n    sex == \"Male\" & (age_years &gt;= 20 & age_years &lt;= 29) ~ \"Recruit to male study\",\n    TRUE ~ \"Do not recruit\"\n  ))\n\nThis extra pair of parentheses does not change the code output, but it improves coherence because the reader can visually see that your condition is made of two parts, one for gender, sex == \"Female\", and another for age, (age_years &gt;= 20 & age_years &lt;= 29).\n\n\n\n\n\n\nPractice\n\n\n\nWith the flu_linelist data, make a new column, called recruit with the following schema:\n\nIndividuals aged 30-59 (at least 30, younger than 60) from the Jiangsu province should have the value “Recruit to Jiangsu study”\nIndividuals aged 30-59 from the Zhejiang province should have the value “Recruit to Zhejiang study”\nEveryone else should have the value “Do not recruit”\n\n\n## Complete the code with your answer:\nQ_age_province_grouping &lt;- \n  flu_linelist %&gt;% \n  mutate(recruit = ______________________________)"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#order-of-priority-of-conditions-in-case_when",
    "href": "untangled_ls04_conditional_mutate.html#order-of-priority-of-conditions-in-case_when",
    "title": "12  Conditional mutating",
    "section": "12.12 Order of priority of conditions in case_when()",
    "text": "12.12 Order of priority of conditions in case_when()\nNote that the order of conditions is important, because conditions listed at the top of your case_when() statement take priority over others.\nTo understand this, run the example below:\n\nyaounde_age_sex %&gt;% \n  mutate(age_group = case_when(age_years &lt; 18 ~ \"Child\", \n                               age_years &lt; 30 ~ \"Young adult\",\n                               age_years &lt; 120 ~ \"Older adult\"))\n\n# A tibble: 10 × 3\n   age_years sex    age_group  \n       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;      \n 1        45 Female Older adult\n 2        55 Male   Older adult\n 3        23 Male   Young adult\n 4        20 Female Young adult\n 5        NA Female &lt;NA&gt;       \n 6        17 Female Child      \n 7        13 Female Child      \n 8        28 Male   Young adult\n 9        30 Male   Older adult\n10        NA Female &lt;NA&gt;       \n\n\nThis initially looks like a faulty case_when() statement because the age conditions overlap. For example, the statement age_years &lt; 120 ~ \"Older adult\" (which reads “if age is below 120, input ‘Older adult’”) suggests that anyone between ages 0 and 120 (even a 1-year old baby!, would be coded as “Older adult”.\nBut as you saw, the code actually works fine! People under 18 are still coded as “Child”.\nWhat’s going on? Essentially, the case_when() statement is interpreted as a series of branching logical steps, starting with the first condition. So this particular statement can be read as: “If age is below 18, input ‘Child’, and otherwise, if age is below 30, input ‘Young adult’, and otherwise, if age is below 120, input”Older adult”.\nThis is illustrated in the schematic below:\n\nThis means that if you swap the order of the conditions, you will end up with a faulty case_when() statement:\n\nyaounde_age %&gt;% \n  mutate(age_group = case_when(age_years &lt; 120 ~ \"Older adult\", \n                               age_years &lt; 30 ~ \"Young adult\", \n                               age_years &lt; 18 ~ \"Child\"))\n\n# A tibble: 10 × 2\n   age_years age_group  \n       &lt;dbl&gt; &lt;chr&gt;      \n 1        45 Older adult\n 2        55 Older adult\n 3        23 Older adult\n 4        20 Older adult\n 5        NA &lt;NA&gt;       \n 6        17 Older adult\n 7        13 Older adult\n 8        28 Older adult\n 9        30 Older adult\n10        NA &lt;NA&gt;       \n\n\nAs you can see, everyone is coded as “Older adult”. This happens because the first condition matches everyone, so there is no one left to match with the subsequent conditions. The statement can be read “If age is below 120, input ‘Older adult’, and otherwise if age is below 30….” But there is no “otherwise” because everyone has already been matched!\nThis is illustrated in the diagram below:\n\nAlthough we have spent much time explaining the importance of the order of conditions, in this specific example, there would be a much clearer way to write this code that would not depend on the order of conditions. Rather than leave the age groups open-ended like this:\n\nage_years &lt; 120 ~ \"Older adult\"\n\nyou should actually use closed age bounds like this:\n\nage_years &gt;= 30 & age_years &lt; 120 ~ \"Older adult\"\n\nwhich is read: “if age is greater than or equal to 30 and less than 120, input ‘Older adult’”.\nWith such closed conditions, the order of conditions no longer matters. You get the same result no matter how you arrange the conditions:\n\n## start with \"Older adult\" condition\nyaounde_age %&gt;%\n  mutate(age_group = case_when(\n    age_years &gt;= 30 & age_years &lt; 120 ~ \"Older adult\",\n    age_years &gt;= 18 & age_years &lt; 30 ~ \"Young adult\",\n    age_years &gt;= 0 & age_years &lt; 18 ~ \"Child\"\n  ))\n\n# A tibble: 10 × 2\n   age_years age_group  \n       &lt;dbl&gt; &lt;chr&gt;      \n 1        45 Older adult\n 2        55 Older adult\n 3        23 Young adult\n 4        20 Young adult\n 5        NA &lt;NA&gt;       \n 6        17 Child      \n 7        13 Child      \n 8        28 Young adult\n 9        30 Older adult\n10        NA &lt;NA&gt;       \n\n\n\n## start with \"Child\" condition\nyaounde_age %&gt;%\n  mutate(age_group = case_when(\n    age_years &gt;= 0 & age_years &lt; 18 ~ \"Child\",\n    age_years &gt;= 18 & age_years &lt; 30 ~ \"Young adult\",\n    age_years &gt;= 30 & age_years &lt; 120 ~ \"Older adult\"\n  ))\n\n# A tibble: 10 × 2\n   age_years age_group  \n       &lt;dbl&gt; &lt;chr&gt;      \n 1        45 Older adult\n 2        55 Older adult\n 3        23 Young adult\n 4        20 Young adult\n 5        NA &lt;NA&gt;       \n 6        17 Child      \n 7        13 Child      \n 8        28 Young adult\n 9        30 Older adult\n10        NA &lt;NA&gt;       \n\n\nNice and clean!\nSo why did we spend so much time explaining the importance of condition order if you can simply avoid open-ended categories and not have to worry about condition order?\nOne reason is that understanding condition order should now help you see why it is important to put the TRUE condition as the final line in your case_when() statement. The TRUE condition matches every row that has not yet been matched, so if you use it first in the case_when() , it will match everyone!\nThe other reason is that there are certain cases where you may want to use open-ended overlapping conditions, and so you will have to pay attention to the order of conditions. Let’s see one such example now: identifying COVID-like symptoms. Note that this is somewhat advanced material, likely a bit above your current needs. We are introducing it now so you are aware and can stay vigilant with case_when() in the future.\n\n12.12.1 Overlapping conditions within case_when()\nWe want to identify COVID-like symptoms in our data. Consider the symptoms columns in the yaounde data frame, which indicates which symptoms were experienced by respondents over a 6-month period:\n\nyaounde %&gt;% \n  select(starts_with(\"symp_\"))\n\n# A tibble: 10 × 13\n   symp_fever symp_headache symp_cough symp_rhinitis symp_sneezing symp_fatigue\n   &lt;chr&gt;      &lt;chr&gt;         &lt;chr&gt;      &lt;chr&gt;         &lt;chr&gt;         &lt;chr&gt;       \n 1 No         No            No         No            No            No          \n 2 No         No            No         No            No            No          \n 3 No         No            No         No            No            No          \n 4 No         No            No         Yes           Yes           No          \n 5 No         No            No         No            No            No          \n 6 Yes        No            Yes        Yes           No            No          \n 7 No         No            No         No            Yes           No          \n 8 No         Yes           No         No            No            No          \n 9 Yes        No            No         Yes           No            No          \n10 No         No            No         No            No            No          \n# ℹ 7 more variables: symp_muscle_pain &lt;chr&gt;, symp_nausea_or_vomiting &lt;chr&gt;,\n#   symp_diarrhoea &lt;chr&gt;, symp_short_breath &lt;chr&gt;, symp_sore_throat &lt;chr&gt;,\n#   symp_anosmia_or_ageusia &lt;chr&gt;, symp_stomach_ache &lt;chr&gt;\n\n\nWe would like to use this to assess whether a person may have had COVID, partly following guidelines recommended by the WHO.\n\nIndividuals with cough are to be classed as “possible COVID cases”\nIndividuals with anosmia/ageusia (loss of smell or loss of taste) are to be classed as “probable COVID cases”.\n\nNow, keeping these criteria in mind, consider an individual, let’s call her Osma, who has cough AND anosmia/ageusia? How should we classify Osma?\nShe meets the criteria for “possible COVID” (because she has cough), but she also meets the criteria for “probable COVID” (because she has anosmia/ageusia). So which group should she be classed as, “possible COVID” or “probable COVID”? Think about it for a minute.\nHopefully you guessed that she should be classed as a “probable COVID case”. “Probable” is more likely than “Possible”; and the anosmia/ageusia symptom is more significant than the cough symptom. One might say that the criterion for “probable COVID” has a higher specificity or a higher precedence than the criterion for “possible COVID”.\nTherefore, when constructing a case_when() statement, the “probable COVID” condition should also take higher precedence—it should come first in the conditions provided to case_when(). Let’s see this now.\nFirst we select the relevant variables, for easy illustration. We also identify and slice() specific rows that are useful for the demonstration:\n\nyaounde_symptoms_slice &lt;- \n  yaounde %&gt;% \n  select(symp_cough, symp_anosmia_or_ageusia) %&gt;% \n  # slice of specific rows useful for demo \n  # Once you find the right code, you would remove this slice\n  slice(32, 711, 625, 651 )\n\nyaounde_symptoms_slice\n\n# A tibble: 4 × 2\n  symp_cough symp_anosmia_or_ageusia\n  &lt;chr&gt;      &lt;chr&gt;                  \n1 No         No                     \n2 Yes        No                     \n3 No         Yes                    \n4 Yes        Yes                    \n\n\nNow, the correct case_when() statement, which has the “Probable COVID” condition first:\n\nyaounde_symptoms_slice %&gt;% \n  mutate(covid_status = case_when(\n    symp_anosmia_or_ageusia == \"Yes\" ~ \"Probable COVID\", \n    symp_cough == \"Yes\"  ~ \"Possible COVID\"\n    ))\n\n# A tibble: 4 × 3\n  symp_cough symp_anosmia_or_ageusia covid_status  \n  &lt;chr&gt;      &lt;chr&gt;                   &lt;chr&gt;         \n1 No         No                      &lt;NA&gt;          \n2 Yes        No                      Possible COVID\n3 No         Yes                     Probable COVID\n4 Yes        Yes                     Probable COVID\n\n\nThis case_when() statement can be read in simple terms as ‘If the person has anosmia/ageusia, input “Probable COVID”, and otherwise, if the person has cough, input “Possible COVID”’.\nNow, spend some time looking through the output data frame, especially the last three individuals. The individual in row 2 meets the criterion for “Possible COVID” because they have cough (symp_cough == “Yes”), and the individual in row 3 meets the criterion for “Probable COVID” because they have anosmia/ageusia (symp_anosmia_or_ageusia == \"Yes\").\nThe individual in row 4 is Osma, who both meets the criteria for “possible COVID” and for “probable COVID”. And because we arranged our case_when() conditions in the right order, she is coded correctly as “probable COVID”. Great!\nBut notice what happens if we swap the order of the conditions:\n\nyaounde_symptoms_slice %&gt;% \n  mutate(covid_status = case_when(\n    symp_cough == \"Yes\"  ~ \"Possible COVID\",\n    symp_anosmia_or_ageusia == \"Yes\" ~ \"Probable COVID\"\n    ))\n\n# A tibble: 4 × 3\n  symp_cough symp_anosmia_or_ageusia covid_status  \n  &lt;chr&gt;      &lt;chr&gt;                   &lt;chr&gt;         \n1 No         No                      &lt;NA&gt;          \n2 Yes        No                      Possible COVID\n3 No         Yes                     Probable COVID\n4 Yes        Yes                     Possible COVID\n\n\nOh no! Osma in row 4 is now misclassed as “Possible COVID” even though she has the more significant anosmia/ageusia symptom. This is because the first condition symp_cough == \"Yes\" matched her first, and so the second condition was not able to match her!\nSo now you see why you sometimes need to think deeply about the order of your case_when() conditions. It is a minor point, but it can bite you at unexpected times. Even experienced analysts tend to make mistakes that can be traced to improper arrangement of case_when() statements.\n\n\n\n\n\n\nChallenge\n\n\n\nIn reality, there is still another solution to avoid misclassifying the person with cough and anosmia/ageusia. That is to add symp_anosmia_or_ageusia != \"Yes\" (not equal to “Yes”) to the conditions for “Possible COVID”. Can you think of why this works?\n\nyaounde_symptoms_slice %&gt;% \n  mutate(covid_status = case_when(\n    symp_cough == \"Yes\" & symp_anosmia_or_ageusia != \"Yes\" ~ \"Possible COVID\",\n    symp_anosmia_or_ageusia == \"Yes\" ~ \"Probable COVID\"))\n\n# A tibble: 4 × 3\n  symp_cough symp_anosmia_or_ageusia covid_status  \n  &lt;chr&gt;      &lt;chr&gt;                   &lt;chr&gt;         \n1 No         No                      &lt;NA&gt;          \n2 Yes        No                      Possible COVID\n3 No         Yes                     Probable COVID\n4 Yes        Yes                     Probable COVID\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nWith the flu_linelist dataset, create a new column called follow_up_priority that implements the following schema:\n\nWomen should be considered “High priority”\nAll children (under 18 years) of any gender should be considered “Highest priority”.\nEveryone else should have the value “No priority”\n\n\n## Complete the code with your answer:\nQ_priority_groups &lt;- \n  flu_linelist %&gt;% \n  mutate(follow_up_priority = ________________\n  )"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#binary-conditions-dplyrif_else",
    "href": "untangled_ls04_conditional_mutate.html#binary-conditions-dplyrif_else",
    "title": "12  Conditional mutating",
    "section": "12.13 Binary conditions: dplyr::if_else()",
    "text": "12.13 Binary conditions: dplyr::if_else()\n\n\n\nFig: the if_else() conditions.\n\n\nThere is another {dplyr} verb similar to case_when() for when we want to apply a binary condition to a variable: if_else(). A binary condition is either TRUE or FALSE.\nif_else() has a similar application as case_when() : if the condition is true, then one operation is applied, if the condition is false, the alternative is applied. The syntax is: if_else(CONDITION, IF_TRUE, IF_FALSE). As you can see, this only allows for a binary condition (not multiple cases, such as handled by case_when()).\nIf we take one of the first examples about recoding the highest_education variable, we can write it either with case_when() or with if_else().\nHere is the version we already explored:\n\nyaounde_educ %&gt;%\n  mutate(\n    highest_education =\n      case_when(\n        highest_education %in% c(\"University\", \"Doctorate\") ~ \"Post-secondary\",\n        TRUE ~ highest_education\n      )\n  )\n\n# A tibble: 10 × 1\n   highest_education\n   &lt;chr&gt;            \n 1 Secondary        \n 2 Post-secondary   \n 3 Post-secondary   \n 4 Secondary        \n 5 Primary          \n 6 Secondary        \n 7 Secondary        \n 8 Post-secondary   \n 9 Secondary        \n10 Secondary        \n\n\nAnd this is how we would write it using if_else():\n\nyaounde_educ %&gt;%\n  mutate(highest_education = \n           if_else(\n             highest_education %in% c(\"University\", \"Doctorate\"),\n             # if TRUE then we recode\n             \"Post-secondary\",\n             # if FALSE then we keep default value\n             highest_education\n             ))\n\n# A tibble: 10 × 1\n   highest_education\n   &lt;chr&gt;            \n 1 Secondary        \n 2 Post-secondary   \n 3 Post-secondary   \n 4 Secondary        \n 5 Primary          \n 6 Secondary        \n 7 Secondary        \n 8 Post-secondary   \n 9 Secondary        \n10 Secondary        \n\n\nAs you can see, we get the same output, whether we use if_else() or case_when().\n\n\n\n\n\n\nPractice\n\n\n\nWith the flu_linelist data, make a new column, called age_group, that has the value “Below 50” for people under 50 and “50 and above” for people aged 50 and up. Use the if_else() function.\nThis is exactly the same question as your first practice question, but this time you need to use if_else().\n\n## Complete the code with your answer:\nQ_age_group_if_else &lt;- \n  flu_linelist %&gt;% \n  mutate(age_group = if_else(______________________________))"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#wrap-up",
    "href": "untangled_ls04_conditional_mutate.html#wrap-up",
    "title": "12  Conditional mutating",
    "section": "12.14 Wrap up",
    "text": "12.14 Wrap up\nChanging or constructing your variables based on conditions on other variables is one of the most repeated data wrangling tasks. To the point it deserved its very own lesson !\nI hope now that you will feel comfortable using case_when() and if_else() within mutate() and that you are excited to learn more complex {dplyr} operations such as grouping variables and summarizing them.\nSee you next time!\n\n\n\nFig: the if_else() and the `case_when()` conditions.\n\n\n LAURE VANCAUWENBERGHE    Data analyst, the GRAPH Network A firm believer in science for good, striving to ally programming, health and education  KENE DAVID NWOSU    Data analyst, the GRAPH Network Passionate about world improvement"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#references",
    "href": "untangled_ls04_conditional_mutate.html#references",
    "title": "12  Conditional mutating",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nHorst, A. (2022). Dplyr-learnr. https://github.com/allisonhorst/dplyr-learnr (Original work published 2020)\nCreate, modify, and delete columns — Mutate. (n.d.). Retrieved 21 February 2022, from https://dplyr.tidyverse.org/reference/mutate.html\n\nArtwork was adapted from:\n\nHorst, A. (2022). R & stats illustrations by Allison Horst. https://github.com/allisonhorst/stats-illustrations (Original work published 2018)"
  },
  {
    "objectID": "untangled_ls04_conditional_mutate.html#solutions",
    "href": "untangled_ls04_conditional_mutate.html#solutions",
    "title": "12  Conditional mutating",
    "section": "12.15 Solutions",
    "text": "12.15 Solutions\n\n.SOLUTION_Q_age_group()\n\n\n\nQ_age_group &lt;- \n  flu_linelist %&gt;% \n  mutate(age_group = case_when(age &lt; 50 ~ \"Below 50\", \n                                   age &gt;= 50 ~ \"50 and above\"))\n\n.SOLUTION_Q_age_group_percentage()\n\n\n Here is one way (not the only way) to get it:\n  \nQ_age_group_percentage &lt;- \n  flu_linelist %&gt;% \n      mutate(age_group_percentage = case_when(age &lt; 60 ~ \"Below 60\", \n                                              age &gt;= 60 ~ \"60 and above\")) %&gt;% \n      tabyl(age_group_percentage) %&gt;% \n      filter(age_group_percentage == \"Below 60\") %&gt;% \n      pull(percent) * 100\n\n.SOLUTION_Q_age_group_nas()\n\n\n\nQ_age_group_nas &lt;- \n  flu_linelist %&gt;% \n  mutate(age_group = case_when(age &lt; 60 ~ \"Below 60\", \n                               age &gt;= 60 ~ \"60 and above\", \n                               is.na(age) ~ \"Missing age\"))\n\n.SOLUTION_Q_gender_recode()\n\n\n\nQ_gender_recode &lt;- \n  flu_linelist %&gt;%  \n      mutate(gender = case_when(gender == \"f\" ~ \"Female\",\n                                gender == \"m\" ~ \"Male\",\n                                is.na(gender) ~ \"Missing gender\"))\n\n.SOLUTION_Q_recode_recovery()\n\n\n\nQ_recode_recovery &lt;- \n  flu_linelist %&gt;% \n  mutate(outcome = case_when(outcome == \"Recover\" ~ \"Recovery\", \n                                 TRUE ~ outcome))\n\n.SOLUTION_Q_adolescent_grouping()\n\n\n\nQ_adolescent_grouping &lt;- \n  flu_linelist %&gt;% \n      mutate(adolescent = case_when(\n        age &gt;= 10 & age &lt; 20 ~ \"Yes\",\n        TRUE ~ \"No\"))\n\n.SOLUTION_Q_age_province_grouping()\n\n\n\nQ_age_province_grouping &lt;- \n  flu_linelist %&gt;% \n      mutate(recruit = case_when(\n        province == \"Jiangsu\" & (age &gt;= 30 & age &lt; 60) ~ \"Recruit to Jiangsu study\",\n        province == \"Zhejiang\" & (age &gt;= 30 & age &lt; 60) ~ \"Recruit to Zhejiang study\",\n        TRUE ~ \"Do not recruit\"\n      ))\n\n.SOLUTION_Q_priority_groups()\n\n\n\nQ_priority_groups &lt;- \n  flu_linelist %&gt;% \n      mutate(follow_up_priority = case_when(\n        age &lt; 18 ~ \"Highest priority\", \n        gender == \"f\" ~ \"High priority\", \n        TRUE ~ \"No priority\"\n      ))\n\n.SOLUTION_Q_age_group_if_else()\n\n\n\nQ_age_group_if_else &lt;- \n  flu_linelist %&gt;% \n  mutate(age_group = if_else(age &lt; 50, \"Below 50\", \"50 and above\"))"
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#introduction",
    "href": "untangled_ls05_groupby_summarize.html#introduction",
    "title": "13  Grouping and summarizing data",
    "section": "13.1 Introduction",
    "text": "13.1 Introduction\nYou currently know how to keep your data entries of interest, how keep relevant variables and how to modify them or create new ones.\nNow, we will take your data wrangling skills one step further by understanding how to easily extract summary statistics, through the verb summarize(), such as calculating the mean of a variable.\nMoreover, we will begin exploring a crucial verb, group_by(), capable of grouping your variables together to perform grouped operations on your data set.\nLet’s go !"
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#learning-objectives",
    "href": "untangled_ls05_groupby_summarize.html#learning-objectives",
    "title": "13  Grouping and summarizing data",
    "section": "13.2 Learning objectives",
    "text": "13.2 Learning objectives\n\nYou can use dplyr::summarize() to extract summary statistics from datasets.\nYou can use dplyr::group_by() to group data by one or more variables before performing operations on them.\nYou understand why and how to ungroup grouped data frames.\nYou can use dplyr::n() together with group_by()-summarize() to count rows per group.\nYou can use sum() together with group_by()-summarize() to count rows that meet a condition.\nYou can use dplyr::count() as a handy function to count rows per group."
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#the-yaounde-covid-19-dataset",
    "href": "untangled_ls05_groupby_summarize.html#the-yaounde-covid-19-dataset",
    "title": "13  Grouping and summarizing data",
    "section": "13.3 The Yaounde COVID-19 dataset",
    "text": "13.3 The Yaounde COVID-19 dataset\nIn this lesson, we will again use data from the COVID-19 serological survey conducted in Yaounde, Cameroon.\n\nyaounde &lt;- read_csv(here::here('data/yaounde_data.csv'))\n\n## A smaller subset of variables\nyao &lt;- yaounde %&gt;% select(\n  age, age_category_3, sex, weight_kg, height_cm,\n  neighborhood, is_smoker, is_pregnant, occupation,\n  treatment_combinations, symptoms, n_days_miss_work, n_bedridden_days,\n  highest_education, igg_result)\n\nyao\n\n# A tibble: 971 × 15\n     age age_category_3 sex    weight_kg height_cm neighborhood is_smoker \n   &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;     \n 1    45 Adult          Female        95       169 Briqueterie  Non-smoker\n 2    55 Adult          Male          96       185 Briqueterie  Ex-smoker \n 3    23 Adult          Male          74       180 Briqueterie  Smoker    \n 4    20 Adult          Female        70       164 Briqueterie  Non-smoker\n 5    55 Adult          Female        67       147 Briqueterie  Non-smoker\n 6    17 Child          Female        65       162 Briqueterie  Non-smoker\n 7    13 Child          Female        65       150 Briqueterie  Non-smoker\n 8    28 Adult          Male          62       173 Briqueterie  Non-smoker\n 9    30 Adult          Male          73       170 Briqueterie  Non-smoker\n10    13 Child          Female        56       153 Briqueterie  Non-smoker\n# ℹ 961 more rows\n# ℹ 8 more variables: is_pregnant &lt;chr&gt;, occupation &lt;chr&gt;,\n#   treatment_combinations &lt;chr&gt;, symptoms &lt;chr&gt;, n_days_miss_work &lt;dbl&gt;,\n#   n_bedridden_days &lt;dbl&gt;, highest_education &lt;chr&gt;, igg_result &lt;chr&gt;\n\n\nSee the first lesson in this chapter for more information about this dataset."
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#what-are-summary-statistics",
    "href": "untangled_ls05_groupby_summarize.html#what-are-summary-statistics",
    "title": "13  Grouping and summarizing data",
    "section": "13.4 What are summary statistics?",
    "text": "13.4 What are summary statistics?\nA summary statistic is a single value (such as a mean or median) that describes a sequence of values (typically a column in your dataset).\n\nSummary statistics can describe the center, spread or range of a variable, or the counts and positions of values within that variable. Some common summary statistics are shown in the diagram below:\n\nComputing summary statistics is a very common operation in most data analysis workflows, so it will be important to become fluent in extracting them from your datasets. And for this task, there is no better tool than the {dplyr} function summarize()! So let’s see how to use this powerful function."
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#introducing-dplyrsummarize",
    "href": "untangled_ls05_groupby_summarize.html#introducing-dplyrsummarize",
    "title": "13  Grouping and summarizing data",
    "section": "13.5 Introducing dplyr::summarize()",
    "text": "13.5 Introducing dplyr::summarize()\nTo get started, it is best to first consider how to get simple summary statistics without using summarize(), then we will consider why you should actually use summarize().\nImagine you were asked to find the mean age of respondents in the yao data frame. How might you do this in base R?\nFirst, recall that the dollar sign function, $, allows you to extract a data frame column to a vector:\n\nyao$age # extract the `age` column from `yao`\n\nTo obtain the mean, you simply pass this yao$age vector into the mean() function:\n\nmean(yao$age)\n\n[1] 29.01751\n\n\nAnd that’s it! You now have a simple summary statistic. Extremely easy, right?\nSo why do we need summarize() to get summary statistics if the process is already so simple without it?We’ll come back to the why question soon. First let’s see how to obtain summary statistics with summarize().\nGoing back to the previous example, the correct syntax to get the mean age with summarize() would be:\n\nyao %&gt;% \n  summarize(mean_age = mean(age))\n\n# A tibble: 1 × 1\n  mean_age\n     &lt;dbl&gt;\n1     29.0\n\n\nThe anatomy of this syntax is shown below. You simply need to input name of the new column (e.g. mean_age), the summary function (e.g. mean()), and the column to summarize (e.g. age).\n\n\n\nFig. Basic syntax for the summarize() function.\n\n\n\nYou can also compute multiple summary statistics in a single summarize() statement. For example, if you wanted both the mean and the median age, you could run:\n\nyao %&gt;% \n  summarize(mean_age = mean(age), \n            median_age = median(age))\n\n# A tibble: 1 × 2\n  mean_age median_age\n     &lt;dbl&gt;      &lt;dbl&gt;\n1     29.0         26\n\n\nNice!\n\nNow, you should be wondering why summarize() puts the summary statistics into a data frame, with each statistic in a different column.\nThe main benefit of this data frame structure is to make it easy to produce grouped summaries (and creating such grouped summaries will be the primary benefit of using summarize()).\nWe will look at these grouped summaries in the next section. For now, attempt the practice questions below.\n\n\n\n\n\n\nPractice\n\n\n\nUse summarize() and the relevant summary functions to obtain the mean, median and standard deviation of respondent weights from the weight_kg variable of the yao data frame.\nYour output should be a data frame with three columns named as shown below:\n\n\n\nmean_weight_kg\nmedian_weight_kg\nsd_weight_kg\n\n\n\n\n\n\n\n\n\n\n\nQ_weight_summary &lt;- \n  yao %&gt;%\n  ____________________________\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUse summarize() and the relevant summary functions to obtain the minimum and maximum respondent heights from the height_cm variable of the yao data frame.\nYour output should be a data frame with two columns named as shown below:\n\n\n\nmin_height_cm\nmax_height_cm\n\n\n\n\n\n\n\n\n\n\nQ_height_summary &lt;- \n  yao %&gt;% \n  ____________________________\n\n\n.CHECK_Q_height_summary()\n.HINT_Q_height_summary()"
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#grouped-summaries-with-dplyrgroup_by",
    "href": "untangled_ls05_groupby_summarize.html#grouped-summaries-with-dplyrgroup_by",
    "title": "13  Grouping and summarizing data",
    "section": "13.6 Grouped summaries with dplyr::group_by()",
    "text": "13.6 Grouped summaries with dplyr::group_by()\nAs its name suggests, dplyr::group_by() lets you group a data frame by the values in a variable (e.g. male vs female sex). You can then perform operations that are split according to these groups.\nWhat effect does group_by() have on a data frame? Let’s try to group the yao data frame by sex and observe the effect:\n\nyao %&gt;% \n  group_by(sex)\n\n# A tibble: 971 × 15\n# Groups:   sex [2]\n     age age_category_3 sex    weight_kg height_cm neighborhood is_smoker \n   &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;     \n 1    45 Adult          Female        95       169 Briqueterie  Non-smoker\n 2    55 Adult          Male          96       185 Briqueterie  Ex-smoker \n 3    23 Adult          Male          74       180 Briqueterie  Smoker    \n 4    20 Adult          Female        70       164 Briqueterie  Non-smoker\n 5    55 Adult          Female        67       147 Briqueterie  Non-smoker\n 6    17 Child          Female        65       162 Briqueterie  Non-smoker\n 7    13 Child          Female        65       150 Briqueterie  Non-smoker\n 8    28 Adult          Male          62       173 Briqueterie  Non-smoker\n 9    30 Adult          Male          73       170 Briqueterie  Non-smoker\n10    13 Child          Female        56       153 Briqueterie  Non-smoker\n# ℹ 961 more rows\n# ℹ 8 more variables: is_pregnant &lt;chr&gt;, occupation &lt;chr&gt;,\n#   treatment_combinations &lt;chr&gt;, symptoms &lt;chr&gt;, n_days_miss_work &lt;dbl&gt;,\n#   n_bedridden_days &lt;dbl&gt;, highest_education &lt;chr&gt;, igg_result &lt;chr&gt;\n\n\nHmm. Apparently nothing happened. The one thing you might notice is a new section in the header that tells you the grouped-by variable—sex—and the number of groups—2:\n  # A tibble: 971 × 10\n👉# Groups:   sex [2]👈\nApart from this header however, the data frame appears unchanged.\nBut watch what happens when we chain the group_by() with the summarize() call we used in the previous section:\n\nyao %&gt;% \n  group_by(sex) %&gt;% \n  summarize(mean_age = mean(age))\n\n# A tibble: 2 × 2\n  sex    mean_age\n  &lt;chr&gt;     &lt;dbl&gt;\n1 Female     29.5\n2 Male       28.4\n\n\nYou get a different summary statistic for each group! The statistics for women are in one row and those for men are in another. (From this output data frame, you can tell that, for example, the mean age for female respondents is 29.5, while that for male respondents is 28.4)\nAs was mentioned earlier, this kind of grouped summary is the primary reason the summarize() function is so useful!\n\nLet’s see another example of a simple group_by() + summarize() operation.\nSuppose you were asked to obtain the maximum and minimum weights for individuals in different neighborhoods in the yao data frame. First you would group_by() the neighbourhood variable, then call the max() and min() functions inside summarize():\n\nyao %&gt;% \n  group_by(neighborhood) %&gt;% \n  summarize(max_weight = max(weight_kg), \n            min_weight = min(weight_kg))\n\n# A tibble: 9 × 3\n  neighborhood max_weight min_weight\n  &lt;chr&gt;             &lt;dbl&gt;      &lt;dbl&gt;\n1 Briqueterie         128         20\n2 Carriere            129         14\n3 Cité Verte          118         16\n4 Ekoudou             135         15\n5 Messa                96         19\n6 Mokolo              162         16\n7 Nkomkana            161         15\n8 Tsinga              105         15\n9 Tsinga Oliga        100         17\n\n\nGreat! With just a few code lines you are able to extract quite a lot of information.\n\nLet’s see one more example for good measure. The variable n_days_miss_work tells us the number of days that respondents missed work due to COVID-like symptoms. Individuals who reported no COVID-like symptoms have an NA for this variable:\n\nyao %&gt;% \n  select(n_days_miss_work)\n\n# A tibble: 971 × 1\n   n_days_miss_work\n              &lt;dbl&gt;\n 1                0\n 2               NA\n 3               NA\n 4                7\n 5               NA\n 6                7\n 7                0\n 8                0\n 9                0\n10               NA\n# ℹ 961 more rows\n\n\nTo count the total number of work days missed for each sex group, you could try to run the sum() function on the n_days_miss_work variable:\n\nyao %&gt;% \n  group_by(sex) %&gt;% \n  summarise(total_days_missed = sum(n_days_miss_work))\n\n# A tibble: 2 × 2\n  sex    total_days_missed\n  &lt;chr&gt;              &lt;dbl&gt;\n1 Female                NA\n2 Male                  NA\n\n\nHmmm. This gives you NA results because some rows in the n_days_miss_work column have NAs in them, and R cannot find the sum of values containing an NA. To solve this, the argument na.rm = TRUE is needed:\n\nyao %&gt;% \n  group_by(sex) %&gt;% \n  summarise(total_days_missed = sum(n_days_miss_work, na.rm = TRUE))\n\n# A tibble: 2 × 2\n  sex    total_days_missed\n  &lt;chr&gt;              &lt;dbl&gt;\n1 Female               256\n2 Male                 272\n\n\nThe output tells us that across all women in the sample, 256 work days were missed due to COVID-like symptoms, and across all men, 272 days.\n\nSo hopefully now you see why summarize() is so powerful. In combination with group_by(), it lets you obtain highly informative grouped summaries of your datasets with very few lines of code.\nProducing such summaries is a very important part of most data analysis workflows, so this skill is likely to come in handy soon!\n\n\n\n\n\n\nVocab\n\n\n\nsummarize() produces “Pivot Tables”\nThe summary data frames created by summarize() are often called Pivot Tables in the context of spreadsheet software like Microsoft Excel.\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUse group_by() and summarize() to obtain the mean weight (kg) by smoking status in the yao data frame. Name the average weight column weight_mean\nThe output data frame should look like this:\n\n\n\nis_smoker\nweight_mean\n\n\n\n\nEx-smoker\n\n\n\nNon-smoker\n\n\n\nSmoker\n\n\n\nNA\n\n\n\n\n\nQ_weight_by_smoking_status &lt;- \n  yao %&gt;% \n  ________________________\n  ________________________\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUse group_by(), summarize(), and the relevant summary functions to obtain the minimum and maximum heights for each sex in the yao data frame.\nYour output should be a data frame with three columns named as shown below:\n\n\n\nsex\nmin_height_cm\nmax_height_cm\n\n\n\n\nFemale\n\n\n\n\nMale\n\n\n\n\n\n\nQ_min_max_height_by_sex &lt;- \n  yao %&gt;% \n  ________________________\n  ________________________\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUse group_by(), summarize(), and the sum() function to calculate the total number of bedridden days (from the n_bedridden_days variable) reported by respondents of each sex.\nYour output should be a data frame with two columns named as shown below:\n\n\n\nsex\ntotal_bedridden_days\n\n\n\n\nFemale\n\n\n\nMale\n\n\n\n\n\nQ_sum_bedridden_days &lt;- \n  yao %&gt;% \n  ________________________\n  ________________________"
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#grouping-by-multiple-variables-nested-grouping",
    "href": "untangled_ls05_groupby_summarize.html#grouping-by-multiple-variables-nested-grouping",
    "title": "13  Grouping and summarizing data",
    "section": "13.7 Grouping by multiple variables (nested grouping)",
    "text": "13.7 Grouping by multiple variables (nested grouping)\nIt is possible to group a data frame by more than one variable. This is sometimes called “nested” grouping.\nLet’s see an example. Suppose you want to know the mean age of men and women in each neighbourhood (rather than the mean age of all women), you could put both sex and neighborhood in the group_by() statement:\n\nyao %&gt;% \n  group_by(sex, neighborhood) %&gt;% \n  summarize(mean_age = mean(age))\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 18 × 3\n# Groups:   sex [2]\n   sex    neighborhood mean_age\n   &lt;chr&gt;  &lt;chr&gt;           &lt;dbl&gt;\n 1 Female Briqueterie      31.6\n 2 Female Carriere         28.2\n 3 Female Cité Verte       31.8\n 4 Female Ekoudou          29.3\n 5 Female Messa            30.2\n 6 Female Mokolo           28.0\n 7 Female Nkomkana         33.0\n 8 Female Tsinga           30.6\n 9 Female Tsinga Oliga     24.3\n10 Male   Briqueterie      33.7\n11 Male   Carriere         30.0\n12 Male   Cité Verte       27.0\n13 Male   Ekoudou          25.2\n14 Male   Messa            23.9\n15 Male   Mokolo           30.5\n16 Male   Nkomkana         29.8\n17 Male   Tsinga           28.8\n18 Male   Tsinga Oliga     24.3\n\n\nFrom this output data frame you can tell that, for example, women from Briqueterie have a mean age of 31.6 years, while men from Briqueterie have a mean age of 33.7 years.\nThe order of the columns listed in group_by() is interchangeable. So if you run group_by(neighborhood, sex) instead of group_by(sex, neighborhood), you’ll get the same result, although it will be ordered differently:\n\nyao %&gt;% \n  group_by(neighborhood, sex) %&gt;% \n  summarize(mean_age = mean(age))\n\n`summarise()` has grouped output by 'neighborhood'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 18 × 3\n# Groups:   neighborhood [9]\n   neighborhood sex    mean_age\n   &lt;chr&gt;        &lt;chr&gt;     &lt;dbl&gt;\n 1 Briqueterie  Female     31.6\n 2 Briqueterie  Male       33.7\n 3 Carriere     Female     28.2\n 4 Carriere     Male       30.0\n 5 Cité Verte   Female     31.8\n 6 Cité Verte   Male       27.0\n 7 Ekoudou      Female     29.3\n 8 Ekoudou      Male       25.2\n 9 Messa        Female     30.2\n10 Messa        Male       23.9\n11 Mokolo       Female     28.0\n12 Mokolo       Male       30.5\n13 Nkomkana     Female     33.0\n14 Nkomkana     Male       29.8\n15 Tsinga       Female     30.6\n16 Tsinga       Male       28.8\n17 Tsinga Oliga Female     24.3\n18 Tsinga Oliga Male       24.3\n\n\nNow the column order is different: neighborhood is the first column, and sex is the second. And the row order is also different: rows are first ordered by neighborhood, then ordered by sex within each neighborhood.\nBut the actual summary statistics are the same. For example, you can again see that women from Briqueterie have a mean age of 31.6 years, while men from Briqueterie have a mean age of 33.7 years.\n\n\n\n\n\n\nPractice\n\n\n\nUsing the yao data frame, group your data by gender (sex) and treatments (treatment_combinations) using group_by. Then, using summarize() and the relevant summary function, calculate the mean weight (weight_kg) for each group.\nYour output should be a data frame with three columns named as shown below:\n\n\n\nsex\ntreatment_combinations\nmean_weight_kg\n\n\n\n\n\n\n\n\n\n\n\nQ_weight_by_sex_treatments &lt;- \n  yao %&gt;%\n  ____________________________\n\nUsing the yao data frame, group your data by age category (age_category_3), gender (sex), and IgG results (igg_result) using group_by. Then, using summarize() and the relevant summary function, calculate the mean number of bedridden days (n_bedridden_days) for each group.\nYour output should be a data frame with four columns named as shown below:\n\n\n\nage_category_3\nsex\nigg_result\nmean_n_bedridden_days\n\n\n\n\n\n\n\n\n\n\n\n\nQ_bedridden_by_age_sex_iggresult &lt;- \n  yao %&gt;%\n  ____________________________"
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#ungrouping-with-dplyrungroup-why-and-how",
    "href": "untangled_ls05_groupby_summarize.html#ungrouping-with-dplyrungroup-why-and-how",
    "title": "13  Grouping and summarizing data",
    "section": "13.8 Ungrouping with dplyr::ungroup() (why and how)",
    "text": "13.8 Ungrouping with dplyr::ungroup() (why and how)\nWhen you group_by() more than one variable before using summarize(), the output data frame is still grouped. This persistent grouping can have unwanted downstream effects, so you will sometimes need to use dplyr::ungroup() to ungroup the data before doing further analysis.\nTo understand why you should ungroup() data, first consider the following example, where we group by only one variable before summarizing:\n\nyao %&gt;% \n  group_by(sex) %&gt;% \n  summarize(mean_age = mean(age))\n\n# A tibble: 2 × 2\n  sex    mean_age\n  &lt;chr&gt;     &lt;dbl&gt;\n1 Female     29.5\n2 Male       28.4\n\n\nThe data comes out like a normal data frame; it is not grouped. You can tell this because there is no information about groups in the header.\nBut now consider when you group by two variables before summarizing:\n\nyao %&gt;% \n  group_by(sex, neighborhood) %&gt;% \n  summarize(mean_age = mean(age))\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 18 × 3\n# Groups:   sex [2]\n   sex    neighborhood mean_age\n   &lt;chr&gt;  &lt;chr&gt;           &lt;dbl&gt;\n 1 Female Briqueterie      31.6\n 2 Female Carriere         28.2\n 3 Female Cité Verte       31.8\n 4 Female Ekoudou          29.3\n 5 Female Messa            30.2\n 6 Female Mokolo           28.0\n 7 Female Nkomkana         33.0\n 8 Female Tsinga           30.6\n 9 Female Tsinga Oliga     24.3\n10 Male   Briqueterie      33.7\n11 Male   Carriere         30.0\n12 Male   Cité Verte       27.0\n13 Male   Ekoudou          25.2\n14 Male   Messa            23.9\n15 Male   Mokolo           30.5\n16 Male   Nkomkana         29.8\n17 Male   Tsinga           28.8\n18 Male   Tsinga Oliga     24.3\n\n\nNow the header tells you that the data is still grouped by the first variable in group_by(), sex:\n  # A tibble: 18 × 3\n👉# Groups:   sex [2]👈\nWhat is the implication of this persistent grouping in the data frame? It means that the data frame may exhibit what seems like weird behavior when you try to apply some {dplyr} functions on it.\nFor example, if you try to select() a single variable, perhaps the mean_age variable, you should normally be able to just use select(mean_age):\n\nyao %&gt;% \n  group_by(sex, neighborhood) %&gt;% \n  summarize(mean_age = mean(age)) %&gt;% \n  select(mean_age) # doesn't work as expected \n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\nAdding missing grouping variables: `sex`\n\n\n# A tibble: 18 × 2\n# Groups:   sex [2]\n   sex    mean_age\n   &lt;chr&gt;     &lt;dbl&gt;\n 1 Female     31.6\n 2 Female     28.2\n 3 Female     31.8\n 4 Female     29.3\n 5 Female     30.2\n 6 Female     28.0\n 7 Female     33.0\n 8 Female     30.6\n 9 Female     24.3\n10 Male       33.7\n11 Male       30.0\n12 Male       27.0\n13 Male       25.2\n14 Male       23.9\n15 Male       30.5\n16 Male       29.8\n17 Male       28.8\n18 Male       24.3\n\n\nBut as you can see, the grouped-by variable, sex, is still selected, even though we only asked for mean_age in the select() statement.\nThis is one of the many examples of unique behaviors of grouped data frames. Other dplyr verbs like filter(), mutate() and arrange() also act in special ways on grouped data. We will address this in detail in a future lesson.\n\nSo you now know why you should ungroup data when you no longer need it grouped. Let’s now see how to ungroup data. It’s quite simple: just add the ungroup() function to your pipe chain. For example:\n\nyao %&gt;% \n  group_by(sex, neighborhood) %&gt;% \n  summarize(mean_age = mean(age)) %&gt;% \n  ungroup()\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 18 × 3\n   sex    neighborhood mean_age\n   &lt;chr&gt;  &lt;chr&gt;           &lt;dbl&gt;\n 1 Female Briqueterie      31.6\n 2 Female Carriere         28.2\n 3 Female Cité Verte       31.8\n 4 Female Ekoudou          29.3\n 5 Female Messa            30.2\n 6 Female Mokolo           28.0\n 7 Female Nkomkana         33.0\n 8 Female Tsinga           30.6\n 9 Female Tsinga Oliga     24.3\n10 Male   Briqueterie      33.7\n11 Male   Carriere         30.0\n12 Male   Cité Verte       27.0\n13 Male   Ekoudou          25.2\n14 Male   Messa            23.9\n15 Male   Mokolo           30.5\n16 Male   Nkomkana         29.8\n17 Male   Tsinga           28.8\n18 Male   Tsinga Oliga     24.3\n\n\nNow that the data frame is ungrouped, it will behave like a normal data frame again. For example, you can select() any column(s) you want; you won’t have some unwanted columns tagging along:\n\nyao %&gt;% \n  group_by(sex, neighborhood) %&gt;% \n  summarize(mean_age = mean(age)) %&gt;% \n  ungroup() %&gt;% \n  select(mean_age)\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 18 × 1\n   mean_age\n      &lt;dbl&gt;\n 1     31.6\n 2     28.2\n 3     31.8\n 4     29.3\n 5     30.2\n 6     28.0\n 7     33.0\n 8     30.6\n 9     24.3\n10     33.7\n11     30.0\n12     27.0\n13     25.2\n14     23.9\n15     30.5\n16     29.8\n17     28.8\n18     24.3"
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#counting-rows",
    "href": "untangled_ls05_groupby_summarize.html#counting-rows",
    "title": "13  Grouping and summarizing data",
    "section": "13.9 Counting rows",
    "text": "13.9 Counting rows\n\nYou can do a lot of data science by just counting and occasionally dividing. - Hadley Wickham, Chief Scientist at RStudio\n\nA common data summarization task is counting how many observations (rows) there are for each group. You can achieve this with the special n() function from {dplyr}, which is specifically designed to be used within summarise().\nFor example, if you want to count how many individuals are in each neighborhood group, you would run:\n\nyao %&gt;% \n  group_by(neighborhood) %&gt;% \n  summarize(count = n())\n\n# A tibble: 9 × 2\n  neighborhood count\n  &lt;chr&gt;        &lt;int&gt;\n1 Briqueterie    106\n2 Carriere       236\n3 Cité Verte      72\n4 Ekoudou        190\n5 Messa           48\n6 Mokolo          96\n7 Nkomkana        75\n8 Tsinga          81\n9 Tsinga Oliga    67\n\n\nAs you can see, the n() function does not require any arguments. It just “knows its job” in the data frame!\n\nOf course, you can include other summary statistics in the same summarize() call. For example, below we also calculate the mean age per neighborhood.\n\nyao %&gt;% \n  group_by(neighborhood) %&gt;% \n  summarize(count = n(), \n            mean_age = mean(age))\n\n# A tibble: 9 × 3\n  neighborhood count mean_age\n  &lt;chr&gt;        &lt;int&gt;    &lt;dbl&gt;\n1 Briqueterie    106     32.5\n2 Carriere       236     28.9\n3 Cité Verte      72     29.9\n4 Ekoudou        190     27.6\n5 Messa           48     27.3\n6 Mokolo          96     29.1\n7 Nkomkana        75     31.7\n8 Tsinga          81     29.7\n9 Tsinga Oliga    67     24.3\n\n\n\n\n\n\n\n\nPractice\n\n\n\nGroup your yao data frame by the respondents’ occupation (occupation) and use summarize() to create columns that show:\n\nhow many individuals there are with each occupation (think of the n() function)\nthe mean number of work days missed (n_days_miss_work) by those in that occupation\n\nYour output should be a data frame with three columns named as shown below:\n\n\n\noccupation\ncount\nmean_n_days_miss_work\n\n\n\n\n\n\n\n\n\n\n\nQ_occupation_summary &lt;- \n  yao %&gt;%\n  ____________________________\n\n\n\n\n13.9.1 Counting rows that meet a condition\nRather than counting all rows as above, it is sometimes more useful to count just the rows that meet specific conditions. This can be done easily by placing the required conditions within the sum() function.\nFor example, to count the number of people under 18 in each neighborhood, you place the condition age &lt; 18 inside sum():\n\nyao %&gt;% \n  group_by(neighborhood) %&gt;% \n  summarize(count_under_18 = sum(age &lt; 18))\n\n# A tibble: 9 × 2\n  neighborhood count_under_18\n  &lt;chr&gt;                 &lt;int&gt;\n1 Briqueterie              28\n2 Carriere                 58\n3 Cité Verte               19\n4 Ekoudou                  66\n5 Messa                    18\n6 Mokolo                   32\n7 Nkomkana                 22\n8 Tsinga                   23\n9 Tsinga Oliga             25\n\n\n\nSimilarly, to count the number of people with doctorate degrees in each neighborhood, you place the condition highest_education == \"Doctorate\" inside sum():\n\nyao %&gt;% \n  group_by(neighborhood) %&gt;% \n  summarize(count_with_doctorates = sum(highest_education == \"Doctorate\"))\n\n# A tibble: 9 × 2\n  neighborhood count_with_doctorates\n  &lt;chr&gt;                        &lt;int&gt;\n1 Briqueterie                      2\n2 Carriere                         1\n3 Cité Verte                       1\n4 Ekoudou                          1\n5 Messa                            2\n6 Mokolo                           0\n7 Nkomkana                         4\n8 Tsinga                           3\n9 Tsinga Oliga                     3\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUnder the hood: counting with conditions\nWhy are you able to use sum() which is meant to add numbers, on a condition like highest_education == \"Doctorate\"?\nUsing sum() on a condition works because the condition evaluates to the Boolean values TRUE and FALSE. And these Boolean values are treated as numbers (where TRUE equals 1 and FALSE equals 0), and numbers can, of course, be summed.\nThe code below demonstrates what is going on under the hood in a step-by-step way. Run through it and see if you can follow.\n\ndemo_of_condition_sums &lt;- yao %&gt;% \n  select(highest_education) %&gt;% \n  mutate(with_doctorate = highest_education == \"Doctorate\") %&gt;% \n  mutate(numeric_with_doctorate = as.numeric(with_doctorate))\n\ndemo_of_condition_sums\n\n# A tibble: 971 × 3\n   highest_education with_doctorate numeric_with_doctorate\n   &lt;chr&gt;             &lt;lgl&gt;                           &lt;dbl&gt;\n 1 Secondary         FALSE                               0\n 2 University        FALSE                               0\n 3 University        FALSE                               0\n 4 Secondary         FALSE                               0\n 5 Primary           FALSE                               0\n 6 Secondary         FALSE                               0\n 7 Secondary         FALSE                               0\n 8 Doctorate         TRUE                                1\n 9 Secondary         FALSE                               0\n10 Secondary         FALSE                               0\n# ℹ 961 more rows\n\n\nThe numeric values can then be added to produce a count of rows fulfilling the condition highest_education == \"Doctorate\":\n\ndemo_of_condition_sums %&gt;% \n  summarize(count_with_doctorate = sum(numeric_with_doctorate))\n\n# A tibble: 1 × 1\n  count_with_doctorate\n                 &lt;dbl&gt;\n1                   17\n\n\n\n\n\nFor a final illustration of counting with conditions, consider the treatment_combinations variable, which lists the treatments received by people with COVID-like symptoms. People who received no treatments have an NA value:\n\nyao %&gt;% \n  select(treatment_combinations)\n\n# A tibble: 971 × 1\n   treatment_combinations        \n   &lt;chr&gt;                         \n 1 Paracetamol                   \n 2 &lt;NA&gt;                          \n 3 &lt;NA&gt;                          \n 4 Antibiotics                   \n 5 &lt;NA&gt;                          \n 6 Paracetamol--Antibiotics      \n 7 Traditional meds.             \n 8 Paracetamol                   \n 9 Paracetamol--Traditional meds.\n10 &lt;NA&gt;                          \n# ℹ 961 more rows\n\n\nIf you want to count the number of people who received no treatment, you would sum up those who meet the is.na(treatment_combinations) condition:\n\nyao %&gt;% \n  group_by(neighborhood) %&gt;% \n  summarize(unknown_treatments = sum(is.na(treatment_combinations)))\n\n# A tibble: 9 × 2\n  neighborhood unknown_treatments\n  &lt;chr&gt;                     &lt;int&gt;\n1 Briqueterie                  82\n2 Carriere                    192\n3 Cité Verte                   46\n4 Ekoudou                     133\n5 Messa                        35\n6 Mokolo                       65\n7 Nkomkana                     53\n8 Tsinga                       56\n9 Tsinga Oliga                 47\n\n\nThese are the people with NA values for the treatment_combinations column.\nTo count the people who did receive some treatment, you can simply negate the is.na() function with !:\n\nyao %&gt;% \n  group_by(neighborhood) %&gt;% \n  summarize(known_treatments = sum(!is.na(treatment_combinations)))\n\n# A tibble: 9 × 2\n  neighborhood known_treatments\n  &lt;chr&gt;                   &lt;int&gt;\n1 Briqueterie                24\n2 Carriere                   44\n3 Cité Verte                 26\n4 Ekoudou                    57\n5 Messa                      13\n6 Mokolo                     31\n7 Nkomkana                   22\n8 Tsinga                     25\n9 Tsinga Oliga               20\n\n\nPLEASE SKIP THE PRACTICE QUESTION ON CHECKING SYMPTOMS FOR ADULTS. WE DECIDED TO REMOVE IT.\n\n\n13.9.2 dplyr::count()\nThe dplyr::count() function wraps a bunch of things into one beautiful friendly line of code to help you find counts of observations by group.\nLet’s use dplyr::count() on our occupation variable:\n\nyao %&gt;%\n  count(occupation)\n\n# A tibble: 28 × 2\n   occupation                              n\n   &lt;chr&gt;                               &lt;int&gt;\n 1 Farmer                                  5\n 2 Farmer--Other                           1\n 3 Home-maker                             65\n 4 Home-maker--Farmer                      2\n 5 Home-maker--Informal worker             3\n 6 Home-maker--Informal worker--Farmer     1\n 7 Home-maker--Trader                      3\n 8 Informal worker                       189\n 9 Informal worker--Other                  2\n10 Informal worker--Trader                 4\n# ℹ 18 more rows\n\n\nNote that this is the same output as:\n\nyao %&gt;%\n  group_by(occupation) %&gt;% \n  summarize(n = n())\n\n# A tibble: 28 × 2\n   occupation                              n\n   &lt;chr&gt;                               &lt;int&gt;\n 1 Farmer                                  5\n 2 Farmer--Other                           1\n 3 Home-maker                             65\n 4 Home-maker--Farmer                      2\n 5 Home-maker--Informal worker             3\n 6 Home-maker--Informal worker--Farmer     1\n 7 Home-maker--Trader                      3\n 8 Informal worker                       189\n 9 Informal worker--Other                  2\n10 Informal worker--Trader                 4\n# ℹ 18 more rows\n\n\nYou can also apply dplyr::count() in a nested fashion:\n\nyao %&gt;%\n  count(sex, occupation)\n\n# A tibble: 40 × 3\n   sex    occupation                              n\n   &lt;chr&gt;  &lt;chr&gt;                               &lt;int&gt;\n 1 Female Farmer                                  3\n 2 Female Home-maker                             65\n 3 Female Home-maker--Farmer                      2\n 4 Female Home-maker--Informal worker             3\n 5 Female Home-maker--Informal worker--Farmer     1\n 6 Female Home-maker--Trader                      3\n 7 Female Informal worker                        77\n 8 Female Informal worker--Trader                 1\n 9 Female No response                             8\n10 Female Other                                   6\n# ℹ 30 more rows\n\n\n\n\n\n\n\n\nPractice\n\n\n\nThe count() verb gives you key information about your dataset in a very quick manner. Let’s look at our IgG results stratified by age category and sex in one line of code.\nUsing the yao data frame, count the different combinations of gender (sex), age categories (age_category_3) and IgG results (igg_result).\nYour output should be a data frame with four columns named as shown below:\n\n\n\nsex\nage_category_3\nigg_result\nn\n\n\n\n\n\n\n\n\n\n\n\n\nQ_count_iggresults_stratified_by_sex_agecategories &lt;- \n  yao %&gt;%\n  ____________________________\n\nUsing the yao data frame, count the different combinations of age categories (age_category_3) and number of bedridden days (n_bedridden_days).\nYour output should be a data frame with three columns named as shown below:\n\n\n\nage_category_3\nn_bedridden_days\nn\n\n\n\n\n\n\n\n\n\n\n\nQ_count_bedridden_age_categories &lt;- \n  yao %&gt;%\n  ____________________________\n\n\n\n\nThe downside of count() is that it can only give you a single summary statistic in the data frame. When you use summarize() and n() you can include multiple summary statistics. For example:\n\nyao %&gt;% \n  group_by(sex, neighborhood) %&gt;% \n  summarize(count = n(), \n            median_age = median(age))\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 18 × 4\n# Groups:   sex [2]\n   sex    neighborhood count median_age\n   &lt;chr&gt;  &lt;chr&gt;        &lt;int&gt;      &lt;dbl&gt;\n 1 Female Briqueterie     61       28  \n 2 Female Carriere       140       25.5\n 3 Female Cité Verte      44       28  \n 4 Female Ekoudou        110       26.5\n 5 Female Messa           26       27.5\n 6 Female Mokolo          53       23  \n 7 Female Nkomkana        43       28  \n 8 Female Tsinga          42       29  \n 9 Female Tsinga Oliga    30       23.5\n10 Male   Briqueterie     45       28  \n11 Male   Carriere        96       27  \n12 Male   Cité Verte      28       22.5\n13 Male   Ekoudou         80       21.5\n14 Male   Messa           22       24.5\n15 Male   Mokolo          43       32  \n16 Male   Nkomkana        32       27  \n17 Male   Tsinga          39       27  \n18 Male   Tsinga Oliga    37       21  \n\n\nBut count() can only yield counts:\n\nyao %&gt;% \n  group_by(sex, neighborhood) %&gt;% \n  count()\n\n# A tibble: 18 × 3\n# Groups:   sex, neighborhood [18]\n   sex    neighborhood     n\n   &lt;chr&gt;  &lt;chr&gt;        &lt;int&gt;\n 1 Female Briqueterie     61\n 2 Female Carriere       140\n 3 Female Cité Verte      44\n 4 Female Ekoudou        110\n 5 Female Messa           26\n 6 Female Mokolo          53\n 7 Female Nkomkana        43\n 8 Female Tsinga          42\n 9 Female Tsinga Oliga    30\n10 Male   Briqueterie     45\n11 Male   Carriere        96\n12 Male   Cité Verte      28\n13 Male   Ekoudou         80\n14 Male   Messa           22\n15 Male   Mokolo          43\n16 Male   Nkomkana        32\n17 Male   Tsinga          39\n18 Male   Tsinga Oliga    37"
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#including-missing-combinations-in-summaries",
    "href": "untangled_ls05_groupby_summarize.html#including-missing-combinations-in-summaries",
    "title": "13  Grouping and summarizing data",
    "section": "13.10 Including missing combinations in summaries",
    "text": "13.10 Including missing combinations in summaries\nWhen you use group_by() and summarize() on multiple variables, you obtain a summary statistic for every unique combination of the grouped variables. For instance, consider the code and output below, which counts the number of individuals in each age-sex group:\n\nyao %&gt;% \n  group_by(sex, age_category_3) %&gt;% \n  summarise(number_of_individuals = n()) \n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 6 × 3\n# Groups:   sex [2]\n  sex    age_category_3 number_of_individuals\n  &lt;chr&gt;  &lt;chr&gt;                          &lt;int&gt;\n1 Female Adult                            368\n2 Female Child                            155\n3 Female Senior                            26\n4 Male   Adult                            267\n5 Male   Child                            136\n6 Male   Senior                            19\n\n\nIn the output data frame, there is one row for each combination of sex and age group (Female—Adult, Female—Child and so on).\nBut what happens if one of these combinations is not present in the data?\nLet’s create an artificial example to observe this. With the code below, we artificially drop all male children from the yao data frame:\n\nyao_no_male_children &lt;- \n  yao %&gt;% \n  filter(!(sex == \"Male\" & age_category_3 == \"Child\"))\n\nNow if you run the same group_by() and summarize() call on yao_no_male_children, you’ll notice the missing combination:\n\nyao_no_male_children %&gt;% \n  group_by(sex, age_category_3) %&gt;% \n  summarise(number_of_individuals = n())\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 5 × 3\n# Groups:   sex [2]\n  sex    age_category_3 number_of_individuals\n  &lt;chr&gt;  &lt;chr&gt;                          &lt;int&gt;\n1 Female Adult                            368\n2 Female Child                            155\n3 Female Senior                            26\n4 Male   Adult                            267\n5 Male   Senior                            19\n\n\nIndeed, there is no row for male children.\nBut sometimes it is useful to include such missing combinations in the output data frame, with an NA or 0 value for the summary statistic.\nTo do this, you can run the following code instead:\n\nyao_no_male_children %&gt;% \n  # convert variables to factors\n  mutate(sex = as.factor(sex), \n         age_category_3 = as.factor(age_category_3)) %&gt;% \n  # Note the the .drop = FALSE argument\n  group_by(sex, age_category_3, .drop = FALSE) %&gt;% \n  summarise(number_of_individuals = n())\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 6 × 3\n# Groups:   sex [2]\n  sex    age_category_3 number_of_individuals\n  &lt;fct&gt;  &lt;fct&gt;                          &lt;int&gt;\n1 Female Adult                            368\n2 Female Child                            155\n3 Female Senior                            26\n4 Male   Adult                            267\n5 Male   Child                              0\n6 Male   Senior                            19\n\n\nWhat does the code do?\n\nFirst it converts the grouping variables to factors with as.factor() (inside a mutate() call)\nThen it uses the argument .drop = FALSE in the group_by() function to avoid dropping the missing combinations.\n\nNow you have a clear 0 count for the number of male children!\n\nLet’s see one more example, this time without artificially modifying our data.\nThe code below calculates the average age by sex and education group:\n\nyao %&gt;% \n  group_by(sex, highest_education) %&gt;% \n  summarise(mean_age = mean(age))\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 13 × 3\n# Groups:   sex [2]\n   sex    highest_education     mean_age\n   &lt;chr&gt;  &lt;chr&gt;                    &lt;dbl&gt;\n 1 Female Doctorate                 28  \n 2 Female No formal instruction     45.6\n 3 Female No response               35  \n 4 Female Primary                   26.8\n 5 Female Secondary                 28.8\n 6 Female University                31.5\n 7 Male   Doctorate                 42.2\n 8 Male   No formal instruction     37.9\n 9 Male   No response               22  \n10 Male   Other                      5.5\n11 Male   Primary                   22.9\n12 Male   Secondary                 29.4\n13 Male   University                31.9\n\n\nNotice that in the output data frame, there are 7 rows for men but only 6 rows for women, because no woman answered “Other” to the question on highest education level.\nIf you nonetheless want to include the “Female—Other” row in the output data frame, you would run:\n\nyao %&gt;% \n  mutate(sex = as.factor(sex), \n         highest_education = as.factor(highest_education)) %&gt;% \n  group_by(sex, highest_education, .drop = FALSE) %&gt;% \n  summarise(mean_age = mean(age))\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 14 × 3\n# Groups:   sex [2]\n   sex    highest_education     mean_age\n   &lt;fct&gt;  &lt;fct&gt;                    &lt;dbl&gt;\n 1 Female Doctorate                 28  \n 2 Female No formal instruction     45.6\n 3 Female No response               35  \n 4 Female Other                    NaN  \n 5 Female Primary                   26.8\n 6 Female Secondary                 28.8\n 7 Female University                31.5\n 8 Male   Doctorate                 42.2\n 9 Male   No formal instruction     37.9\n10 Male   No response               22  \n11 Male   Other                      5.5\n12 Male   Primary                   22.9\n13 Male   Secondary                 29.4\n14 Male   University                31.9\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUsing the yao data frame, let’s calculate the median age when grouping by neighborhood, age_category, and gender\nNote, we want all possible combinations of these three variables (not just those present in our data).\nPay attention to two data wrangling imperatives!\n\nconvert your grouping variables to factors beforehand using mutate()\ncalculate your statistic, the median, while removing any NA values.\n\nYour output should be a data frame with four columns named as shown below:\n\n\n\nneighborhood\nage_category_3\nsex\nmedian_age\n\n\n\n\n\n\n\n\n\n\n\n\nQ_median_age_by_neighborhood_agecategory_sex &lt;- \n  yao %&gt;%\n  ____________________________\n\n\n\n\n\n\n\n\n\nSide Note\n\n\n\nWhy include missing combinations?\nAbove, we mentioned that including missing combinations is often useful in the data analysis workflow. Let’s see one use case: plotting with {ggplot}. If you have not yet learned {ggplot}, that is okay, just focus on the plot outputs.\nTo make a dodged bar chart with the age-sex counts of yao_no_male_children, you could run:\n\nyao_no_male_children %&gt;% \n  group_by(sex, age_category_3) %&gt;% \n  summarise(number_of_individuals = n()) %&gt;% \n  ungroup() %&gt;% \n  \n  # pass the output to ggplot\n  ggplot() + \n  geom_col(aes(x = sex, y = number_of_individuals, fill = age_category_3), \n           position = \"dodge\")\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n\n\n\nNot very elegant! Ideally there should be an empty space indicating 0 for the number of male children.\nIf you instead implement the procedure to include missing combinations, you get a more natural dodged bar plot, with an empty space for male children:\n\nyao_no_male_children %&gt;% \n  mutate(sex = as.factor(sex), \n         age_category_3 = as.factor(age_category_3)) %&gt;% \n  group_by(sex, age_category_3, .drop = FALSE) %&gt;% \n  summarise(number_of_individuals = n()) %&gt;% \n  ungroup() %&gt;% \n  \n  # pass the output to ggplot\n  ggplot() + \n  geom_col(aes(x = sex, y = number_of_individuals, fill = age_category_3), \n           position = \"dodge\")\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n\n\n\nMuch better!\nBy the way, this output can be improved slightly by setting the factor levels for age to their proper ascending order: first “Child”, then “Adult” then “Senior”:\n\nyao_no_male_children %&gt;% \n  mutate(sex = as.factor(sex), \n         age_category_3 = factor(age_category_3, \n                                 levels = c(\"Child\", \n                                            \"Adult\", \n                                            \"Senior\"))) %&gt;% \n  group_by(sex, age_category_3, .drop = FALSE) %&gt;% \n  summarise(number_of_individuals = n()) %&gt;% \n  ungroup() %&gt;% \n  \n  # pass the output to ggplot\n  ggplot() + \n  geom_col(aes(x = sex, y = number_of_individuals, fill = age_category_3), \n           position = \"dodge\")\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument."
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#wrap-up",
    "href": "untangled_ls05_groupby_summarize.html#wrap-up",
    "title": "13  Grouping and summarizing data",
    "section": "13.11 Wrap up",
    "text": "13.11 Wrap up\nYou have now seen how to obtain quick summary statistics from your data, either for exploratory data or for further data presentation or plotting.\nAdditionally, you have discovered one of the marvels of {dplyr}, the possibility to group your data using group_by().\ngroup_by() combined with summarize() is a one of the most common grouping manipulations.\n\n\n\nFig: summarize() and its use combined with group_by().\n\n\nHowever, you can also combine group_by() with many of the other {dplyr} verbs: this is what we will cover in our next lesson. See you soon !\n LAURE VANCAUWENBERGHE    Data analyst, the GRAPH Network A firm believer in science for good, striving to ally programming, health and education  ANDREE VALLE CAMPOS    R Developer and Instructor, the GRAPH Network Motivated by reproducible science and education  KENE DAVID NWOSU    Data analyst, the GRAPH Network Passionate about world improvement\nThank you to Alice Osmaston and Saifeldin Shehata for their comments and review."
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#references",
    "href": "untangled_ls05_groupby_summarize.html#references",
    "title": "13  Grouping and summarizing data",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nHorst, A. (2022). Dplyr-learnr. https://github.com/allisonhorst/dplyr-learnr (Original work published 2020)\nGroup by one or more variables. (n.d.). Retrieved 21 February 2022, from https://dplyr.tidyverse.org/reference/group_by.html\nSummarise each group to fewer rows. (n.d.). Retrieved 21 February 2022, from https://dplyr.tidyverse.org/reference/summarize.html\nThe Carpentries. (n.d.). Grouped operations using `dplyr`. Grouped operations using `dplyr` – Introduction to R/tidyverse for Exploratory Data Analysis. Retrieved July 28, 2022, from https://tavareshugo.github.io/r-intro-tidyverse-gapminder/06-grouped_operations_dplyr/index.html\n\nArtwork was adapted from:\n\nHorst, A. (2022). R & stats illustrations by Allison Horst. https://github.com/allisonhorst/stats-illustrations (Original work published 2018)"
  },
  {
    "objectID": "untangled_ls05_groupby_summarize.html#solutions",
    "href": "untangled_ls05_groupby_summarize.html#solutions",
    "title": "13  Grouping and summarizing data",
    "section": "13.12 Solutions",
    "text": "13.12 Solutions\n\n.SOLUTION_Q_weight_summary()\n\n\n\nQ_weight_summary &lt;- \n  yao %&gt;%\n      summarize(mean_weight_kg = mean(weight_kg),\n                median_weight_kg = median(weight_kg),\n                sd_weight_kg = sd(weight_kg))\n\n.SOLUTION_Q_height_summary()\n\n\n\nQ_height_summary &lt;- \n  yao %&gt;%\n      summarize(min_height_cm = min(height_cm),\n                max_height_cm = max(height_cm))\n\n.SOLUTION_Q_weight_by_smoking_status()\n\n\n\nQ_weight_by_smoking_status &lt;- \n  yao %&gt;% \n  group_by(is_smoker) %&gt;% \n  summarise(weight_mean = mean(weight_kg))\n\n.SOLUTION_Q_min_max_height_by_sex()\n\n\n\nQ_min_max_height_by_sex &lt;- \n  yao %&gt;% \n  group_by(sex) %&gt;%\n  summarise(min_height_cm = min(height_cm),\n            max_height_cm = max(height_cm))\n\n.SOLUTION_Q_sum_bedridden_days()\n\n\n\nQ_sum_bedridden_days &lt;- \n  yao %&gt;% \n  group_by(sex) %&gt;% \n  summarise(total_bedridden_days = sum(n_bedridden_days, na.rm = T))\n\n.SOLUTION_Q_weight_by_sex_treatments()\n\n\n\n  \nQ_weight_by_sex_treatments &lt;- \n  yao %&gt;% \n  group_by(sex, treatment_combinations) %&gt;%\n  summarise(mean_weight_kg = mean(weight_kg, na.rm = T))\n\n.SOLUTION_Q_bedridden_by_age_sex_iggresult()\n\n\n\nQ_bedridden_by_age_sex_iggresult &lt;- \n  yao %&gt;% \n  group_by(age_category_3, sex, igg_result) %&gt;% \n  summarise(mean_n_bedridden_days = mean(n_bedridden_days, na.rm = T))\n\n.SOLUTION_Q_occupation_summary()\n\n\n\nQ_occupation_summary &lt;- \n  yao %&gt;% \n  group_by(occupation) %&gt;%\n  summarise(count = n(),\n            mean_n_days_miss_work = mean(n_days_miss_work, na.rm=TRUE))\n\n.SOLUTION_Q_count_iggresults_stratified_by_sex_agecategories()\n\n\n\nQ_count_iggresults_stratified_by_sex_agecategories &lt;- \n  yao %&gt;% \n  count(sex, age_category_3, igg_result)\n\n.SOLUTION_Q_count_bedridden_age_categories()\n\n\n\nQ_count_bedridden_age_categories &lt;- \n  yao %&gt;% \n  count(age_category_3, n_bedridden_days)\n\n.SOLUTION_Q_median_age_by_neighborhood_agecategory_sex()\n\n\n\nQ_median_age_by_neighborhood_agecategory_sex &lt;- \n  yao %&gt;% \n  mutate(neighborhood = as.factor(neighborhood),\n             age_category_3 = as.factor(age_category_3),\n             sex = as.factor(sex)) %&gt;%\n  group_by(neighborhood, age_category_3, sex, .drop=FALSE) %&gt;%\n  summarize(median_age = median(age, na.rm=TRUE))"
  },
  {
    "objectID": "untangled_ls06_group_by_other_verbs.html#introduction",
    "href": "untangled_ls06_group_by_other_verbs.html#introduction",
    "title": "14  Grouped filter, mutate and arrange",
    "section": "14.1 Introduction",
    "text": "14.1 Introduction\nData wrangling often involves applying the same operations separately to different groups within the data. This pattern, sometimes called “split-apply-combine”, is easily accomplished in {dplyr} by chaining the group_by() verb with other wrangling verbs like filter(), mutate(), and arrange() (all of which you have seen before!).\nIn this lesson, you’ll become confident with these kinds of grouped manipulations.\nLet’s get started."
  },
  {
    "objectID": "untangled_ls06_group_by_other_verbs.html#learning-objectives",
    "href": "untangled_ls06_group_by_other_verbs.html#learning-objectives",
    "title": "14  Grouped filter, mutate and arrange",
    "section": "14.2 Learning objectives",
    "text": "14.2 Learning objectives\n\nYou can use group_by() with arrange(), filter(), and mutate() to conduct grouped operations on a data frame."
  },
  {
    "objectID": "untangled_ls06_group_by_other_verbs.html#packages",
    "href": "untangled_ls06_group_by_other_verbs.html#packages",
    "title": "14  Grouped filter, mutate and arrange",
    "section": "14.3 Packages",
    "text": "14.3 Packages\nThis lesson will require the {tidyverse} suite of packages and the {here} package:\n\nif(!require(pacman)) install.packages(\"pacman\")\npacman::p_load(tidyverse, here)"
  },
  {
    "objectID": "untangled_ls06_group_by_other_verbs.html#datasets",
    "href": "untangled_ls06_group_by_other_verbs.html#datasets",
    "title": "14  Grouped filter, mutate and arrange",
    "section": "14.4 Datasets",
    "text": "14.4 Datasets\nIn this lesson, we will again use data from the COVID-19 serological survey conducted in Yaounde, Cameroon. Below, we import the data, create a small data frame subset, yao and an even smaller subset, yao_sex_weight.\n\nyao &lt;- \n  read_csv(here::here('data/yaounde_data.csv'))  %&gt;% \n  select(sex, age, age_category, weight_kg, occupation, igg_result, igm_result)\n\nyao\n\n# A tibble: 5 × 7\n  sex      age age_category weight_kg occupation      igg_result igm_result\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;     \n1 Female    45 45 - 64             95 Informal worker Negative   Negative  \n2 Male      55 45 - 64             96 Salaried worker Positive   Negative  \n3 Male      23 15 - 29             74 Student         Negative   Negative  \n4 Female    20 15 - 29             70 Student         Positive   Negative  \n5 Female    55 45 - 64             67 Trader--Farmer  Positive   Negative  \n\nyao_sex_weight &lt;- \n  yao %&gt;% \n  select(sex, weight_kg)\n\nyao_sex_weight\n\n# A tibble: 5 × 2\n  sex    weight_kg\n  &lt;chr&gt;      &lt;dbl&gt;\n1 Female        95\n2 Male          96\n3 Male          74\n4 Female        70\n5 Female        67\n\n\n\nFor practice questions, we will also use the sarcopenia data set that you have seen previously:\n\nsarcopenia &lt;- read_csv(here::here('data/sarcopenia_elderly.csv'))\n\nsarcopenia\n\n# A tibble: 5 × 9\n  number   age age_group sex_male_1_female_0 marital_status height_meters\n   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                   &lt;dbl&gt; &lt;chr&gt;                  &lt;dbl&gt;\n1      7  60.8 Sixties                     0 married                 1.57\n2      8  72.3 Seventies                   1 married                 1.65\n3      9  62.6 Sixties                     0 married                 1.59\n4     12  72   Seventies                   0 widow                   1.47\n5     13  60.1 Sixties                     0 married                 1.55\n# ℹ 3 more variables: weight_kg &lt;dbl&gt;, grip_strength_kg &lt;dbl&gt;,\n#   skeletal_muscle_index &lt;dbl&gt;"
  },
  {
    "objectID": "untangled_ls06_group_by_other_verbs.html#arranging-by-group",
    "href": "untangled_ls06_group_by_other_verbs.html#arranging-by-group",
    "title": "14  Grouped filter, mutate and arrange",
    "section": "14.5 Arranging by group",
    "text": "14.5 Arranging by group\nThe arrange() function orders the rows of a data frame by the values of selected columns. This function is only sensitive to groupings when we set its argument .by_group to TRUE. To illustrate this, consider the yao_sex_weight data frame:\n\nyao_sex_weight\n\n# A tibble: 5 × 2\n  sex    weight_kg\n  &lt;chr&gt;      &lt;dbl&gt;\n1 Female        95\n2 Male          96\n3 Male          74\n4 Female        70\n5 Female        67\n\n\nWe can arrange this data frame by weight like so:\n\nyao_sex_weight %&gt;% \n  arrange(weight_kg)\n\n# A tibble: 5 × 2\n  sex    weight_kg\n  &lt;chr&gt;      &lt;dbl&gt;\n1 Female        14\n2 Male          15\n3 Male          15\n4 Male          15\n5 Female        15\n\n\nAs expected, lower weights have been brought to the top of the data frame.\nIf we first group the data, we might expect a different output:\n\nyao_sex_weight %&gt;% \n  group_by(sex) %&gt;% \n  arrange(weight_kg)\n\n# A tibble: 5 × 2\n# Groups:   sex [2]\n  sex    weight_kg\n  &lt;chr&gt;      &lt;dbl&gt;\n1 Female        14\n2 Male          15\n3 Male          15\n4 Male          15\n5 Female        15\n\n\nBut as you see, the arrangement is still the same.\nOnly when we set the .by_group argument to TRUE do we get something different:\n\nyao_sex_weight %&gt;% \n  group_by(sex) %&gt;% \n  arrange(weight_kg, .by_group = TRUE)\n\n# A tibble: 5 × 2\n# Groups:   sex [1]\n  sex    weight_kg\n  &lt;chr&gt;      &lt;dbl&gt;\n1 Female        14\n2 Female        15\n3 Female        16\n4 Female        16\n5 Female        18\n\n\nNow, the data is first sorted by sex (all women first), and then by weight.\n\narrange() can group automatically\nIn reality we do not need group_by() to arrange by group; we can simply put multiple variables in the arrange() function for the same effect.\nSo this simple arrange() statement:\n\nyao_sex_weight %&gt;% \n  arrange(sex, weight_kg)\n\n# A tibble: 5 × 2\n  sex    weight_kg\n  &lt;chr&gt;      &lt;dbl&gt;\n1 Female        14\n2 Female        15\n3 Female        16\n4 Female        16\n5 Female        18\n\n\nis equivalent to the more complex group_by(), arrange() statement used before:\n\nyao_sex_weight %&gt;% \n  group_by(sex) %&gt;% \n  arrange(weight_kg, .by_group = TRUE)\n\nThe code arrange(sex, weight_kg) tells R to arrange the rows first by sex, and then by weight.\nObviously, this syntax, with just arrange(), and no group_by() is simpler, so you can stick to it.\n\ndesc() for descending order\nRecall that to arrange in descending order, we can wrap the target variable in desc(). So, for example, to sort by sex and weight, but with the heaviest people on top, we can run:\n\nyao_sex_weight %&gt;% \n  arrange(sex, desc(weight_kg))\n\n# A tibble: 5 × 2\n  sex    weight_kg\n  &lt;chr&gt;      &lt;dbl&gt;\n1 Female       162\n2 Female       161\n3 Female       158\n4 Female       135\n5 Female       129\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nWith an arrange() call, sort the sarcopenia data first by sex and then by grip strength. (If done correctly, the first row should be of a woman with a grip strength of 1.3 kg). To make the arrangement clear, you should first select() the sex and grip strength variables.\n\n## Complete the code with your answer:\nQ_grip_strength_arranged &lt;- \n  sarcopenia %&gt;% \n  select(______________________________) %&gt;% \n  arrange(______________________________)\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nThe sarcopenia dataset contains a column, age_group, which stores age groups as a string (the age groups are “Sixties”, “Seventies” and “Eighties”). Convert this variable to a factor with the levels in the right order (first “Sixties” then “Seventies” and so on). (Hint: Look back on the case_when() lesson if you do not see how to relevel a factor.)\nThen, with a nested arrange() call, arrange the data first by the newly-created age_group factor variable (younger individuals first) and then by height_meters, with shorter individuals first.\n\n## Complete the code with your answer:\nQ_age_group_height &lt;- \n  sarcopenia"
  },
  {
    "objectID": "untangled_ls06_group_by_other_verbs.html#filtering-by-group",
    "href": "untangled_ls06_group_by_other_verbs.html#filtering-by-group",
    "title": "14  Grouped filter, mutate and arrange",
    "section": "14.6 Filtering by group",
    "text": "14.6 Filtering by group\nThe filter() function keeps or drops rows based on a condition. If filter() is applied to grouped data, the filtering operation is carried out separately for each group.\nTo illustrate this, consider again the yao_sex_weight data frame:\n\nyao_sex_weight\n\n# A tibble: 5 × 2\n  sex    weight_kg\n  &lt;chr&gt;      &lt;dbl&gt;\n1 Female        95\n2 Male          96\n3 Male          74\n4 Female        70\n5 Female        67\n\n\nIf we want to filter the data for the heaviest person, we could run:\n\nyao_sex_weight %&gt;% \n  filter(weight_kg == max(weight_kg))\n\n# A tibble: 1 × 2\n  sex    weight_kg\n  &lt;chr&gt;      &lt;dbl&gt;\n1 Female       162\n\n\nBut if we want to get heaviest person per sex group (the heaviest man and the heaviest woman), we can use group_by(sex) then filter():\n\nyao_sex_weight %&gt;% \n  group_by(sex) %&gt;% \n  filter(weight_kg == max(weight_kg))\n\n# A tibble: 2 × 2\n# Groups:   sex [2]\n  sex    weight_kg\n  &lt;chr&gt;      &lt;dbl&gt;\n1 Male         128\n2 Female       162\n\n\nGreat! The code above can be translated as “For each sex group, keep the row with the maximum weight_kg value”.\n\nFiltering with nested groupings\nfilter() will work fine with any number of nested groupings.\nFor example, if we want to see the heaviest man and heaviest woman per age group we could run the following on the yao data frame:\n\nyao %&gt;% \n  group_by(sex, age_category) %&gt;% \n  filter(weight_kg == max(weight_kg))\n\n# A tibble: 10 × 7\n# Groups:   sex, age_category [10]\n   sex      age age_category weight_kg occupation      igg_result igm_result\n   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;     \n 1 Male      69 65 +               108 Retired         Positive   Negative  \n 2 Male      37 30 - 44            128 Informal worker Negative   Negative  \n 3 Male      26 15 - 29             91 Trader          Positive   Negative  \n 4 Female    19 15 - 29            109 Student         Negative   Negative  \n 5 Female    64 45 - 64            158 Retired         Negative   Negative  \n 6 Female    32 30 - 44            162 Informal worker Positive   Negative  \n 7 Male      46 45 - 64            122 Informal worker Negative   Negative  \n 8 Female     8 5 - 14             161 Student         Negative   Positive  \n 9 Female    68 65 +               109 Retired         Negative   Negative  \n10 Male       6 5 - 14              99 No response     Negative   Negative  \n\n\nThis code groups by sex and age category, and then finds the heaviest person in each sub-category.\n(Why do we have 10 rows in the output? Well, 2 sex groups x 5 groups age groups = 10 unique groupings.)\nThe output is a bit scattered though, so we can chain this with the arrange() function, to arrange by sex and age group.\n\nyao %&gt;% \n  group_by(sex, age_category) %&gt;% \n  filter(weight_kg == max(weight_kg)) %&gt;% \n  arrange(sex, age_category)\n\n# A tibble: 10 × 7\n# Groups:   sex, age_category [10]\n   sex      age age_category weight_kg occupation      igg_result igm_result\n   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;     \n 1 Female    19 15 - 29            109 Student         Negative   Negative  \n 2 Female    32 30 - 44            162 Informal worker Positive   Negative  \n 3 Female    64 45 - 64            158 Retired         Negative   Negative  \n 4 Female     8 5 - 14             161 Student         Negative   Positive  \n 5 Female    68 65 +               109 Retired         Negative   Negative  \n 6 Male      26 15 - 29             91 Trader          Positive   Negative  \n 7 Male      37 30 - 44            128 Informal worker Negative   Negative  \n 8 Male      46 45 - 64            122 Informal worker Negative   Negative  \n 9 Male       6 5 - 14              99 No response     Negative   Negative  \n10 Male      69 65 +               108 Retired         Positive   Negative  \n\n\nNow the data is easier to read. All women come first, then men. But we see notice a weird arrangement of the age groups! Those aged 5 to 14 should come first in the arrangement. Of course, we’ve learned how to fix this—the factor() function, and its levels argument:\n\nyao %&gt;%\n  mutate(age_category = factor(\n    age_category,\n    levels = c(\"5 - 14\", \"15 - 29\", \"30 - 44\", \"45 - 64\", \"65 +\")\n  )) %&gt;%\n  group_by(sex, age_category) %&gt;%\n  filter(weight_kg == max(weight_kg)) %&gt;%\n  arrange(sex, age_category)\n\n# A tibble: 10 × 7\n# Groups:   sex, age_category [10]\n   sex      age age_category weight_kg occupation      igg_result igm_result\n   &lt;chr&gt;  &lt;dbl&gt; &lt;fct&gt;            &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;     \n 1 Female     8 5 - 14             161 Student         Negative   Positive  \n 2 Female    19 15 - 29            109 Student         Negative   Negative  \n 3 Female    32 30 - 44            162 Informal worker Positive   Negative  \n 4 Female    64 45 - 64            158 Retired         Negative   Negative  \n 5 Female    68 65 +               109 Retired         Negative   Negative  \n 6 Male       6 5 - 14              99 No response     Negative   Negative  \n 7 Male      26 15 - 29             91 Trader          Positive   Negative  \n 8 Male      37 30 - 44            128 Informal worker Negative   Negative  \n 9 Male      46 45 - 64            122 Informal worker Negative   Negative  \n10 Male      69 65 +               108 Retired         Positive   Negative  \n\n\nNow we have a nice and well-arranged output!\n\n\n\n\n\n\nPractice\n\n\n\nGroup the sarcopenia data frame by age group and sex, then filter for the highest skeletal muscle index in each (nested) group.\n\n## Complete the code with your answer:\nQ_max_skeletal_muscle_index &lt;- \n  sarcopenia"
  },
  {
    "objectID": "untangled_ls06_group_by_other_verbs.html#mutating-by-group",
    "href": "untangled_ls06_group_by_other_verbs.html#mutating-by-group",
    "title": "14  Grouped filter, mutate and arrange",
    "section": "14.7 Mutating by group",
    "text": "14.7 Mutating by group\nmutate() is used to modify columns or to create new ones. With grouped data, mutate() operates over each group independently.\nLet’s first consider a regular mutate() call, not a grouped one. Imagine that you wanted to add a column that ranks respondents by weight. This can be done with the rank() function inside a mutate() call:\n\nyao_sex_weight %&gt;% \n  mutate(weight_rank = rank(weight_kg))\n\n# A tibble: 5 × 3\n  sex    weight_kg weight_rank\n  &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n1 Female        95        901 \n2 Male          96        908 \n3 Male          74        640.\n4 Female        70        564.\n5 Female        67        502.\n\n\nThe output shows that the first row is the 901st lightest individual. But it would be more intuitive to rank in descending order with the heaviest person first. We can do this with the desc() function:\n\nyao_sex_weight %&gt;% \n  mutate(weight_rank = rank(desc(weight_kg)))\n\n# A tibble: 5 × 3\n  sex    weight_kg weight_rank\n  &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n1 Female        95         71 \n2 Male          96         64 \n3 Male          74        332.\n4 Female        70        408.\n5 Female        67        470.\n\n\nThe output shows that the person in the first row is the 71st heaviest individual.\n\nNow, let’s try to write a grouped mutate() call. Imagine we want to add this weight rank column per sex group in the data frame. That is, we want to know each person’s weight rank in their sex category. In this case, we can chain group_by(sex) with mutate():\n\nyao_sex_weight %&gt;% \n  group_by(sex) %&gt;% \n  mutate(weight_rank = rank(desc(weight_kg)))\n\n# A tibble: 5 × 3\n# Groups:   sex [2]\n  sex    weight_kg weight_rank\n  &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n1 Female        95        53.5\n2 Male          96        13.5\n3 Male          74       148  \n4 Female        70       220. \n5 Female        67       250. \n\n\nNow we see that the person in the first row is the 53rd heaviest woman. (The .5 indicates that this rank is a tie with someone else in the data.)\nWe could also arrange the data to make things clearer:\n\nyao_sex_weight %&gt;% \n  group_by(sex) %&gt;% \n  mutate(weight_rank = rank(desc(weight_kg))) %&gt;% \n  arrange(sex, weight_rank)\n\n# A tibble: 5 × 3\n# Groups:   sex [1]\n  sex    weight_kg weight_rank\n  &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n1 Female       162           1\n2 Female       161           2\n3 Female       158           3\n4 Female       135           4\n5 Female       129           5\n\n\n\nMutating with nested groupings\nOf course, as with the other verbs we have seen, mutate() also works with nested groups.\nFor example, below we create the nested grouping of age and sex with the yao data frame, then add a rank column with mutate():\n\nyao %&gt;% \n  group_by(sex, age_category) %&gt;% \n  mutate(weight_rank = rank(desc(weight_kg)))\n\n# A tibble: 5 × 8\n# Groups:   sex, age_category [4]\n  sex      age age_category weight_kg occupation      igg_result igm_result\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;     \n1 Female    45 45 - 64             95 Informal worker Negative   Negative  \n2 Male      55 45 - 64             96 Salaried worker Positive   Negative  \n3 Male      23 15 - 29             74 Student         Negative   Negative  \n4 Female    20 15 - 29             70 Student         Positive   Negative  \n5 Female    55 45 - 64             67 Trader--Farmer  Positive   Negative  \n# ℹ 1 more variable: weight_rank &lt;dbl&gt;\n\n\nThe output shows that the person in the first row is 20th heaviest woman in the 45 to 64 age group.\n\n\n\n\n\n\nPractice\n\n\n\nWith the sarcopenia data, group by age_group, then in a new variable called grip_strength_rank, compute the per-age-group rank of each individual’s grip strength. (To compute the rank, use mutate() and the rank() function with its default ties method.)\n\n## Complete the code with your answer:\nQ_rank_grip_strength &lt;- \n  sarcopenia\n\n\n\n\n\n\n\n\n\nWatch Out\n\n\n\nRemember to ungroup data before further analysis\nAs has been mentioned before, it is important ungroup your data before doing further analysis.\nConsider this last example, where we computed the weight rank of individuals per age and sex group:\n\nyao %&gt;% \n  group_by(sex, age_category) %&gt;% \n  mutate(weight_rank = rank(desc(weight_kg)))\n\n# A tibble: 5 × 8\n# Groups:   sex, age_category [4]\n  sex      age age_category weight_kg occupation      igg_result igm_result\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;     \n1 Female    45 45 - 64             95 Informal worker Negative   Negative  \n2 Male      55 45 - 64             96 Salaried worker Positive   Negative  \n3 Male      23 15 - 29             74 Student         Negative   Negative  \n4 Female    20 15 - 29             70 Student         Positive   Negative  \n5 Female    55 45 - 64             67 Trader--Farmer  Positive   Negative  \n# ℹ 1 more variable: weight_rank &lt;dbl&gt;\n\n\nIf, in the process of analysis, you stored this output as a new data frame:\n\nyao_modified &lt;- \n  yao %&gt;% \n  group_by(sex, age_category) %&gt;% \n  mutate(weight_rank = rank(desc(weight_kg)))\n\nAnd then, later on, you picked up the data frame and tried some other analysis, for example, filtering to get the oldest person in the data:\n\nyao_modified %&gt;% \n  filter(age == max(age))\n\n# A tibble: 5 × 8\n# Groups:   sex, age_category [5]\n  sex      age age_category weight_kg occupation           igg_result igm_result\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;                &lt;chr&gt;      &lt;chr&gt;     \n1 Male      65 45 - 64             93 Retired              Negative   Negative  \n2 Male      78 65 +                95 Retired--Informal w… Positive   Negative  \n3 Male      14 5 - 14              44 Student              Negative   Negative  \n4 Female    44 30 - 44             67 Home-maker           Positive   Negative  \n5 Female    79 65 +                40 Retired              Negative   Negative  \n# ℹ 1 more variable: weight_rank &lt;dbl&gt;\n\n\nYou might be confused by the output! Why are there 55 rows of “oldest people”?\nThis would be because you forgot to ungroup the data before storing it for further analysis. Let’s do this properly now\n\nyao_modified &lt;- \n  yao %&gt;% \n  group_by(sex, age_category) %&gt;% \n  mutate(weight_rank = rank(desc(weight_kg))) %&gt;% \n  ungroup()\n\nNow we can correctly obtain the oldest person/people in the data set:\n\nyao_modified %&gt;% \n  filter(age == max(age))\n\n# A tibble: 2 × 8\n  sex      age age_category weight_kg occupation igg_result igm_result\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     \n1 Female    79 65 +                40 Retired    Negative   Negative  \n2 Female    79 65 +                81 Home-maker Negative   Negative  \n# ℹ 1 more variable: weight_rank &lt;dbl&gt;"
  },
  {
    "objectID": "untangled_ls06_group_by_other_verbs.html#wrap-up",
    "href": "untangled_ls06_group_by_other_verbs.html#wrap-up",
    "title": "14  Grouped filter, mutate and arrange",
    "section": "14.8 Wrap up",
    "text": "14.8 Wrap up\ngroup_by() is a marvelous tool for arranging, mutating, filtering based on the groups within a single or multiple variables.\n \n\n\n\nFig: filter() and its use combined with group_by().\n\n\nThere are numerous ways of combining these verbs to manipulate your data. We invite you to take some time and to try these verbs out in different combinations!\nSee you next time!\n LAURE VANCAUWENBERGHE    Data analyst, the GRAPH Network A firm believer in science for good, striving to ally programming, health and education  KENE DAVID NWOSU    Data analyst, the GRAPH Network Passionate about world improvement"
  },
  {
    "objectID": "untangled_ls06_group_by_other_verbs.html#references",
    "href": "untangled_ls06_group_by_other_verbs.html#references",
    "title": "14  Grouped filter, mutate and arrange",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nHorst, A. (2022). Dplyr-learnr. https://github.com/allisonhorst/dplyr-learnr (Original work published 2020)\nGroup by one or more variables. (n.d.). Retrieved 21 February 2022, from https://dplyr.tidyverse.org/reference/group_by.html\nCreate, modify, and delete columns — Mutate. (n.d.). Retrieved 21 February 2022, from https://dplyr.tidyverse.org/reference/mutate.html\nSubset rows using column values — Filter. (n.d.). Retrieved 21 February 2022, from https://dplyr.tidyverse.org/reference/filter.html\nArrange rows by column values — Arrange. (n.d.). Retrieved 21 February 2022, from https://dplyr.tidyverse.org/reference/arrange.html\n\nArtwork was adapted from:\n\nHorst, A. (2022). R & stats illustrations by Allison Horst. https://github.com/allisonhorst/stats-illustrations (Original work published 2018)"
  },
  {
    "objectID": "untangled_ls06_group_by_other_verbs.html#solutions",
    "href": "untangled_ls06_group_by_other_verbs.html#solutions",
    "title": "14  Grouped filter, mutate and arrange",
    "section": "14.9 Solutions",
    "text": "14.9 Solutions\n\n.SOLUTION_Q_grip_strength_arranged()\n\n\n\nQ_grip_strength_arranged &lt;- \n  sarcopenia %&gt;%\n  select(sex_male_1_female_0, grip_strength_kg) %&gt;%\n  arrange(sex_male_1_female_0, grip_strength_kg)\n\n.SOLUTION_Q_age_group_height()\n\n\n\nQ_age_group_height &lt;- \n  sarcopenia %&gt;%\n  mutate(age_group = factor(age_group, levels = c(\"Sixties\",\n                                                  \"Seventies\",\n                                                  \"Eighties\"))) %&gt;%\n  arrange(age_group, height_meters)\n\n.SOLUTION_Q_max_skeletal_muscle_index()\n\n\n\nQ_max_skeletal_muscle_index &lt;- \n  sarcopenia %&gt;%\n  group_by(age_group,sex_male_1_female_0) %&gt;%\n  filter(skeletal_muscle_index == max(skeletal_muscle_index))\n\n.SOLUTION_Q_rank_grip_strength()\n\n\n\nQ_rank_grip_strength &lt;- \n  sarcopenia %&gt;%\n  group_by(age_group) %&gt;%\n  mutate(grip_strength_rank = rank(grip_strength_kg))"
  },
  {
    "objectID": "untangled_ls07_pivoting.html#intro",
    "href": "untangled_ls07_pivoting.html#intro",
    "title": "15  Pivoting data",
    "section": "15.1 Intro",
    "text": "15.1 Intro\nPivoting or reshaping is a data manipulation technique that involves re-orienting the rows and columns of a dataset. This is sometimes required to make data easier to analyze, or to make data easier to understand.\nIn this lesson, we will cover how to effectively pivot data using pivot_longer() and pivot_wider() from the tidyr package."
  },
  {
    "objectID": "untangled_ls07_pivoting.html#learning-objectives",
    "href": "untangled_ls07_pivoting.html#learning-objectives",
    "title": "15  Pivoting data",
    "section": "15.2 Learning Objectives",
    "text": "15.2 Learning Objectives\n\nYou will understand what wide data format is, and what long data format is.\nYou will know how to pivot long data to wide data using pivot_long()\nYou will know how to pivot wide data to long data using pivot_wider()\nYou will understand why the long data format is easier for plotting and wrangling in R."
  },
  {
    "objectID": "untangled_ls07_pivoting.html#packages",
    "href": "untangled_ls07_pivoting.html#packages",
    "title": "15  Pivoting data",
    "section": "15.3 Packages",
    "text": "15.3 Packages\n\n## Load packages \nif(!require(pacman)) install.packages(\"pacman\")\npacman::p_load(tidyverse, outbreaks, janitor, rio, here, knitr)"
  },
  {
    "objectID": "untangled_ls07_pivoting.html#what-do-wide-and-long-mean",
    "href": "untangled_ls07_pivoting.html#what-do-wide-and-long-mean",
    "title": "15  Pivoting data",
    "section": "15.4 What do wide and long mean?",
    "text": "15.4 What do wide and long mean?\nThe terms wide and long are best understood in the context of example datasets. Let’s take a look at some now.\nImagine that you have three patients from whom you collect blood pressure data on three days.\nYou can record the data in a wide format like this:\n\n\n\nFig: wide dataset for a timeseries of patients.\n\n\nOr you could record the data in a long format as so :\n\n\n\nFig: long dataset for a timeseries of patients.\n\n\nTake a minute to study the two datasets to make sure you understand the relationship between them.\nIn the wide dataset, each observational unit (each patient) occupies only one row. And each measurement. (blood pressure day 1, blood pressure day 2…) is in a separate column.\nIn the long dataset, on the other hand, each observational unit (each patient) occupies multiple rows, with one row for each measurement.\n\nHere is another example with mock data, in which the observational units are countries:\n\n\n\nFig: long dataset where the unique observation unit is a country.\n\n\n\n\n\nFig: the equivalent wide dataset\n\n\n\nThe examples above are both time-series datasets, because the measurements are repeated across time (day 1, day 2 and so on). But the concepts of long and wide are relevant to other kinds of data too, not just time series data.\nConsider the example below, showing the number of patients in different units of three hospitals:\n\n\n\nFig: wide dataset, where each hospital is an observational unit\n\n\n\n\n\nFig: the equivalent long dataset\n\n\nIn the wide dataset, again, each observational unit (each hospital) occupies only one row, with the repeated measurements for that unit (number of patients in different rooms) spread across two columns.\nIn the long dataset, each observational unit is spread over multiple lines.\n\n\n\n\n\n\nVocab\n\n\n\nThe “observational units”, sometimes called “statistical units” of a dataset are the primary entities or items described by the columns in that dataset.\nIn the first example, the observational/statistical units were patients; in the second example, countries, and in the third example, hospitals.\n\n\n\n\n\n\n\n\nPractice\n\n\n\nConsider the mock dataset created below:\n\ntemperatures &lt;- \n  data.frame(\n    country = c(\"Sweden\", \"Denmark\", \"Norway\"),\n    avgtemp.1994 = 1:3,\n    avgtemp.1995 = 3:5,\n    avgtemp.1996 = 5:7)\ntemperatures\n\n  country avgtemp.1994 avgtemp.1995 avgtemp.1996\n1  Sweden            1            3            5\n2 Denmark            2            4            6\n3  Norway            3            5            7\n\n\nIs this data in a wide or long format?\n\n## Enter the string \"wide\" or the string \"long\"\n## Assign your answer to the object Q_data_type\nQ_data_type &lt;- \"_____\"\n## Then run the provided CHECK function"
  },
  {
    "objectID": "untangled_ls07_pivoting.html#when-should-you-use-wide-vs-long-data",
    "href": "untangled_ls07_pivoting.html#when-should-you-use-wide-vs-long-data",
    "title": "15  Pivoting data",
    "section": "15.5 When should you use wide vs long data?",
    "text": "15.5 When should you use wide vs long data?\nThe truth is: it really depends on what you want to do! The wide format is great for displaying data because it’s easy to visually compare values this way. Long data is best for some data analysis tasks, like grouping and plotting.\nIt will therefore be essential for you to know how to switch from one format to the other easily. Switching from the wide to the long format, or the other way around, is called pivoting."
  },
  {
    "objectID": "untangled_ls07_pivoting.html#pivoting-wide-to-long",
    "href": "untangled_ls07_pivoting.html#pivoting-wide-to-long",
    "title": "15  Pivoting data",
    "section": "15.6 Pivoting wide to long",
    "text": "15.6 Pivoting wide to long\nTo practice pivoting from a wide to a long format, we’ll consider data from Gapminder on the number of infant deaths in specific countries over several years.\n\n\n\n\n\n\nSide Note\n\n\n\nGapminder is a good source of rich, health-relevant datasets. You are encouraged to peruse their collections.\n\n\nBelow, we read in and view this data on infant deaths:\n\ninfant_deaths_wide &lt;- read_csv(here(\"data/gapminder_infant_deaths.csv\"))\ninfant_deaths_wide\n\n# A tibble: 5 × 7\n  country              x2010 x2011 x2012 x2013 x2014 x2015\n  &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Afghanistan          74600 72000 69500 67100 64800 62700\n2 Angola               79100 76400 73700 71200 69000 67200\n3 Albania                420   384   354   331   313   301\n4 United Arab Emirates   683   687   686   681   672   658\n5 Argentina             9550  9230  8860  8480  8100  7720\n\n\nWe observe that each observational unit (each country) occupies only one row, with the repeated measurements spread out across multiple columns. Hence this dataset is in a wide format.\nTo convert to a long format, we can use a convenient function pivot_longer. Within pivot_longer we define, using the cols argument, which columns we want to pivot:\n\ninfant_deaths_wide %&gt;% \n  pivot_longer(cols = x2010:x2015)\n\n# A tibble: 5 × 3\n  country     name  value\n  &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt;\n1 Afghanistan x2010 74600\n2 Afghanistan x2011 72000\n3 Afghanistan x2012 69500\n4 Afghanistan x2013 67100\n5 Afghanistan x2014 64800\n\n\nVery easy!\nWe can observe that the resulting long format dataset has each country occupying 5 rows (one per year between 2010 and 2015). The years are indicated in the variable names, and all the death count values occupy a single variable, values.\nA useful way to think about this transformation is that the infant deaths values used to be in matrix format (2 dimensions; 2D), but they are now in a vector format (1 dimension; 1D).\nThis long dataset will be much more handy for many data analysis procedures.\nAs a good data analyst, you may find the default names of the variables, names and values, to be unsatisfactory; they do not adequately describe what the variables contain. Not to worry; you can give custom column names, using the arguments names_to and values_to:\n\ninfant_deaths_wide %&gt;% \n  pivot_longer(cols = x2010:x2015,\n               names_to = \"year\", \n               values_to = \"deaths_count\")\n\n# A tibble: 5 × 3\n  country     year  deaths_count\n  &lt;chr&gt;       &lt;chr&gt;        &lt;dbl&gt;\n1 Afghanistan x2010        74600\n2 Afghanistan x2011        72000\n3 Afghanistan x2012        69500\n4 Afghanistan x2013        67100\n5 Afghanistan x2014        64800\n\n\n\n\n\n\n\n\nSide Note\n\n\n\nNotice that the long format is more informative than the original wide format. Why? Because of the informative column name “deaths_count”. In the wide format, unless the CSV is named something like count_infant_deaths, or someone tells you “these are the counts of infant deaths per country and per year”, you have no idea what the numbers in the cells represent.\n\n\nYou may also want to remove the x in front of each year. This can be achieved with the convenient parse_number() function from the {readr} package (part of the tidyverse), which extracts numbers from strings:\n\ninfant_deaths_wide %&gt;% \n  pivot_longer(cols = x2010:x2015,\n               names_to = \"year\", \n               values_to = \"deaths_count\") %&gt;% \n  mutate(year = parse_number(year))\n\n# A tibble: 5 × 3\n  country      year deaths_count\n  &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt;\n1 Afghanistan  2010        74600\n2 Afghanistan  2011        72000\n3 Afghanistan  2012        69500\n4 Afghanistan  2013        67100\n5 Afghanistan  2014        64800\n\n\nGreat! Now we have a clean, long dataset.\nFor later use, let’s now store this data:\n\ninfant_deaths_long &lt;- \n  infant_deaths_wide %&gt;% \n  pivot_longer(cols = x2010:x2015,\n               names_to = \"year\", \n               values_to = \"deaths_count\")\n\n\n\n\n\n\n\nPractice\n\n\n\nFor this practice question, you will use the euro_births_wide dataset from Eurostat. It shows the annual number of births in 50 European countries:\n\neuro_births_wide &lt;- \n  read_csv(here(\"data/euro_births_wide.csv\"))\nhead(euro_births_wide)\n\n# A tibble: 5 × 8\n  country   x2015  x2016  x2017  x2018  x2019  x2020  x2021\n  &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 Belgium  122274 121896 119690 118319 117695 114350 118349\n2 Bulgaria  65950  64984  63955  62197  61538  59086  58678\n3 Czechia  110764 112663 114405 114036 112231 110200 111793\n4 Denmark   58205  61614  61397  61476  61167  60937  63473\n5 Germany  737575 792141 784901 787523 778090 773144 795492\n\n\nThe data is in a wide format. Convert it to a long format data frame that has the following column names: “country”, “year” and “births_count”\n\nQ_euro_births_long &lt;- \n  euro_births_wide %&gt;% # complete the code with your answer"
  },
  {
    "objectID": "untangled_ls07_pivoting.html#pivoting-long-to-wide",
    "href": "untangled_ls07_pivoting.html#pivoting-long-to-wide",
    "title": "15  Pivoting data",
    "section": "15.7 Pivoting long to wide",
    "text": "15.7 Pivoting long to wide\nNow you know how to pivot from wide to long with pivot_longer(). How about going the other way, from long to wide? For this, you can use the fittingly-named pivot_wider() function.\nBut before we consider how to use this function to manipulate long data, let’s first consider where you’re likely to run into long data.\nWhile wide data tends to come from external sources (as we have seen above), long data on the other hand, is likely to be created by you while data wrangling, especially in the course of group_by()-summarize() manipulations.\nLet’s see an example of this now.\nWe will use a dataset of patient records from an Ebola outbreak in Sierra Leone in 2014. Below we extract this data from the {outbreaks} package and perform some simplifying manipulations on it.\n\nebola &lt;- \n  outbreaks::ebola_sierraleone_2014 %&gt;% \n  as_tibble() %&gt;% \n  mutate(year = lubridate::year(date_of_onset)) %&gt;% # extract the year from the date\n  select(patient_id = id, district, year_of_onset = year) # select and rename\n\nebola\n\n# A tibble: 5 × 3\n  patient_id district year_of_onset\n       &lt;int&gt; &lt;fct&gt;            &lt;dbl&gt;\n1          1 Kailahun          2014\n2          2 Kailahun          2014\n3          3 Kailahun          2014\n4          4 Kailahun          2014\n5          5 Kailahun          2014\n\n\nEach row corresponds to one patient, and we have each patient’s id number, their district and the year in which they contracted Ebola.\nNow, consider the following grouped summary of the ebola dataset, which counts the number of patients recorded in each district in each year:\n\ncases_per_district_per_year &lt;- \n  ebola %&gt;% \n  group_by(district) %&gt;% \n  count(year_of_onset) %&gt;% \n  ungroup()\n\ncases_per_district_per_year\n\n# A tibble: 5 × 3\n  district year_of_onset     n\n  &lt;fct&gt;            &lt;dbl&gt; &lt;int&gt;\n1 Bo                2014   397\n2 Bo                2015   209\n3 Bombali           2014  1070\n4 Bombali           2015   120\n5 Bonthe            2014     7\n\n\nThe output of this grouped operation is a quintessentially “long” dataset! Each observational unit (each district) occupies multiple rows (two rows per district, to be exact), with one row for each measurement (each year).\nSo, as you now see, long data often can arrive as an output of grouped summaries, among other data manipulations.\nNow, let’s see how to convert such long data into a wide format with pivot_wider().\nThe code is quite straightforward:\n\ncases_per_district_per_year %&gt;% \n  pivot_wider(values_from = n, \n              names_from = year_of_onset)\n\n# A tibble: 5 × 3\n  district `2014` `2015`\n  &lt;fct&gt;     &lt;int&gt;  &lt;int&gt;\n1 Bo          397    209\n2 Bombali    1070    120\n3 Bonthe        7     77\n4 Kailahun    535     35\n5 Kambia      127    294\n\n\nAs you can see, pivot_wider() has two important arguments: values_from and names_from. The values_from argument defines which values will become the core of the wide data format (in other words: which 1D vector will become a 2D matrix). In our case, these values were in the n variable. And names_from identifies which variable to use to define column names in the wide format. In our case, this was the year_of_onset variable.\n\n\n\n\n\n\nSide Note\n\n\n\nYou might also want to have the years be your primary observational/statistical unit, with each year occupying one row. This can be carried out similarly to the above example, but the district variable will be provided as an argument to names_from, instead of year_of_onset.\n\ncases_per_district_per_year %&gt;% \n  pivot_wider(values_from = n, \n              names_from = district)\n\n# A tibble: 2 × 15\n  year_of_onset    Bo Bombali Bonthe Kailahun Kambia Kenema Koinadugu  Kono\n          &lt;dbl&gt; &lt;int&gt;   &lt;int&gt;  &lt;int&gt;    &lt;int&gt;  &lt;int&gt;  &lt;int&gt;     &lt;int&gt; &lt;int&gt;\n1          2014   397    1070      7      535    127    641       142   328\n2          2015   209     120     77       35    294    139        15   223\n# ℹ 6 more variables: Moyamba &lt;int&gt;, `Port Loko` &lt;int&gt;, Pujehun &lt;int&gt;,\n#   Tonkolili &lt;int&gt;, `Western Rural` &lt;int&gt;, `Western Urban` &lt;int&gt;\n\n\nHere the unique observation units (our rows) are now the years (2014, 2015).\n\n\n\n\n\n\n\n\nPractice\n\n\n\nThe population dataset from the tidyr package shows the populations of 219 countries over time.\nPivot this data into a wide format. Your answer should have 20 columns and 219 rows.\n\nQ_population_widen &lt;- \n  tidyr::population"
  },
  {
    "objectID": "untangled_ls07_pivoting.html#why-is-long-data-better-for-analysis",
    "href": "untangled_ls07_pivoting.html#why-is-long-data-better-for-analysis",
    "title": "15  Pivoting data",
    "section": "15.8 Why is long data better for analysis?",
    "text": "15.8 Why is long data better for analysis?\nAbove we mentioned that long data is best for a majority of data analysis tasks. Now we can justify why. In the sections below, we will go through a few common operations that you will need to do with long data, in each case you will observe that similar manipulations on wide data would be quite tricky.\n\n15.8.1 Filtering grouped data\nFirst, let’s talk about filtering grouped data, which is very easy to do on long data, but difficult on wide data.\nHere is an example with the infant deaths dataset. Imagine that we want to answer the following question: For each country, which year had the highest number of child deaths?\nThis is how we would do so with the long format of the data :\n\ninfant_deaths_long %&gt;% \n  group_by(country) %&gt;% \n  filter(deaths_count == max(deaths_count))\n\n# A tibble: 5 × 3\n# Groups:   country [5]\n  country              year  deaths_count\n  &lt;chr&gt;                &lt;chr&gt;        &lt;dbl&gt;\n1 Afghanistan          x2010        74600\n2 Angola               x2010        79100\n3 Albania              x2010          420\n4 United Arab Emirates x2011          687\n5 Argentina            x2010         9550\n\n\nEasy right? We can easily see, for example, that Afghanistan had its highest infant death count in 2010, and the United Arab Emirates had its highest death count in 2011.\n\nIf you wanted to do the same thing with wide data, it would be much more difficult. You could try an approach like this with rowwise():\n\ninfant_deaths_wide %&gt;% \n  rowwise() %&gt;% \n  mutate(max_count = max(x2010, x2011, x2012, x2013, x2014, x2015))\n\n# A tibble: 5 × 8\n# Rowwise: \n  country              x2010 x2011 x2012 x2013 x2014 x2015 max_count\n  &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1 Afghanistan          74600 72000 69500 67100 64800 62700     74600\n2 Angola               79100 76400 73700 71200 69000 67200     79100\n3 Albania                420   384   354   331   313   301       420\n4 United Arab Emirates   683   687   686   681   672   658       687\n5 Argentina             9550  9230  8860  8480  8100  7720      9550\n\n\nThis almost works—we have, for each country, we have the maximum number of child deaths reported—but we still don’t know which year is attached to that value in max_count. We would have to take that value and index it back to its respective year column somehow… what a hassle! There are solutions to find this but all are very painful. Why make your life complicated when you can just pivot to long format and use the beauty of group_by() and filter()?\n\n\n\n\n\n\nSide Note\n\n\n\nHere we used a special {dplyr} function: rowwise(). rowwise() allows further operations to be applied per-row . It is equivalent to creating one group for each row (group_by(row_number())).\nWithout rowwise() you would get this :\n\ninfant_deaths_wide %&gt;% \n  mutate(max_count = max(x2010, x2011, x2012, x2013, x2014, x2015))\n\n# A tibble: 5 × 8\n  country              x2010 x2011 x2012 x2013 x2014 x2015 max_count\n  &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1 Afghanistan          74600 72000 69500 67100 64800 62700   1170000\n2 Angola               79100 76400 73700 71200 69000 67200   1170000\n3 Albania                420   384   354   331   313   301   1170000\n4 United Arab Emirates   683   687   686   681   672   658   1170000\n5 Argentina             9550  9230  8860  8480  8100  7720   1170000\n\n\n…the maximum count over ALL rows in the dataset.\n\n\n\n\n\n\n\n\nPractice\n\n\n\nFor this practice question, you will perform a grouped filter on the long format population dataset from the tidyr package. Use group_by() and filter() to obtain a dataset that shows the maximum population recorded for each country, and the year in which that maximum population was recorded.\n\nQ_population_max &lt;- \n  population \n\n\n\n\n\n15.8.2 Summarizing grouped data\nGrouped summaries are also difficult to perform on wide data. For example, considering again the infant_deaths_long dataset, if you want to ask: For each country, what was the mean number of infant deaths and the standard deviation (variation) in deaths ?\nWith long data it is simple:\n\ninfant_deaths_long %&gt;% \n  group_by(country) %&gt;% \n  summarize(mean_deaths = mean(deaths_count), \n            sd_deaths = sd(deaths_count))\n\n# A tibble: 5 × 3\n  country             mean_deaths sd_deaths\n  &lt;chr&gt;                     &lt;dbl&gt;     &lt;dbl&gt;\n1 Afghanistan             68450    4466.   \n2 Albania                   350.     45.2  \n3 Algeria                 21033.    484.   \n4 Angola                  72767.   4513.   \n5 Antigua and Barbuda        10.7     0.816\n\n\nWith wide data, on the other hand, finding the mean is less intuitive…\n\ninfant_deaths_wide %&gt;% \n  rowwise() %&gt;% \n  mutate(mean_deaths = sum(x2010, x2011, x2012, \n                           x2013, x2014, x2015, na.rm = T)/6) \n\n# A tibble: 5 × 8\n# Rowwise: \n  country              x2010 x2011 x2012 x2013 x2014 x2015 mean_deaths\n  &lt;chr&gt;                &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;       &lt;dbl&gt;\n1 Afghanistan          74600 72000 69500 67100 64800 62700      68450 \n2 Angola               79100 76400 73700 71200 69000 67200      72767.\n3 Albania                420   384   354   331   313   301        350.\n4 United Arab Emirates   683   687   686   681   672   658        678.\n5 Argentina             9550  9230  8860  8480  8100  7720       8657.\n\n\nAnd finding the standard deviation would be very difficult. (We can’t think of any way to achieve this, actually.)\n\n\n\n\n\n\nPractice\n\n\n\nFor this practice question, you will again work with the long format population dataset from the tidyr package.\nUse group_by() and summarize() to obtain, for each country, the maximum reported population, the minimum reported population, and the mean reported population across the years available in the data. Your data should have four columns, “country”, “max_population”, “min_population” and “mean_population”.\n\nQ_population_summaries &lt;- \n  population\n\n\n\n\n\n15.8.3 Plotting\nFinally, one of the data analysis tasks that is MOST hindered by wide formats is plotting. You may not yet have any prior knowledge of {ggplot} and how to plot so we will see the figures without going in depth with the code. What you need to remember is: many plots with with ggplot are also only possible with long-format data\nConsider again the infant_deaths data infant_deaths_long. We will plot the number of deaths for Belgium per year:\n\ninfant_deaths_long %&gt;% \n  filter(country == \"Belgium\") %&gt;% \n  ggplot() + \n  geom_col(aes(x = year, y = deaths_count))\n\n\n\n\nThe plotting works because we can give the variable year for the x-axis. In the long format, year is a variable variable of its own. In the wide format, each there would be no such variable to pass to the x axis.\n\nAnother plot that would not be possible without a long format:\n\ninfant_deaths_long %&gt;% \n  head(30) %&gt;% \n  ggplot(aes(x = year, y = deaths_count, group = country, color = country)) + \n  geom_line() + \n  geom_point()\n\n\n\n\nOnce again, the reason is the same, we need to tell the plot what to use as an x-axis and a y-axis and it is necessary to have these variables in their own columns (as organized in the long format)."
  },
  {
    "objectID": "untangled_ls07_pivoting.html#pivoting-can-be-hard",
    "href": "untangled_ls07_pivoting.html#pivoting-can-be-hard",
    "title": "15  Pivoting data",
    "section": "15.9 Pivoting can be hard",
    "text": "15.9 Pivoting can be hard\nWe have mostly looked at very simple examples of pivoting here, but in the wild, pivoting can be very difficult to do accurately. This is because the data you are working with may not have all the information necessary for a successful pivot, or the data may contain errors that prevent you from pivoting correctly.\nWhen you run into such cases, we recommend looking at the official documentation of pivoting from the tidyr team, as it is quite rich in examples. You could also post your questions about pivoting on forums like Stack Overflow."
  },
  {
    "objectID": "untangled_ls07_pivoting.html#wrap-up",
    "href": "untangled_ls07_pivoting.html#wrap-up",
    "title": "15  Pivoting data",
    "section": "15.10 Wrap up",
    "text": "15.10 Wrap up\nYou have now explored different datasets and how they are either in a long or wide format. In the end, it’s just about how you present the information. Sometimes one format will be more convenient, and other times another could be best. Now, you are no longer limited by the format of your data: don’t like it? change it !\n KENE DAVID NWOSU    Data analyst, the GRAPH Network Passionate about world improvement  LAURE VANCAUWENBERGHE    Data analyst, the GRAPH Network A firm believer in science for good, striving to ally programming, health and education  CAMILLE BEATRICE VALERA    Project Manager and Scientific Collaborator, The GRAPH Network"
  },
  {
    "objectID": "untangled_ls07_pivoting.html#solutions",
    "href": "untangled_ls07_pivoting.html#solutions",
    "title": "15  Pivoting data",
    "section": "15.11 Solutions",
    "text": "15.11 Solutions\n\n.SOLUTION_Q_data_type()\n\n\n\n  \"Wide\"\n\n.SOLUTION_Q_euro_births_long()\n\n\n\n  euro_births_wide %&gt;% \n      pivot_longer(2:8, \n                   names_to = \"year\", \n                   values_to = \"births_count\")\n\n.SOLUTION_Q_population_widen()\n\n\n\n  \n  tidyr::population %&gt;% \n      pivot_wider(names_from = year,\n                   values_from = population)\n\n.SOLUTION_Q_population_max()\n\n\n\n  \n  tidyr::population %&gt;% \n    group_by(country) %&gt;% \n    filter(population == max(population)) %&gt;% \n    ungroup()\n\n.SOLUTION_Q_population_summaries()\n\n\n\n  \n  population %&gt;% \n  group_by(country) %&gt;% \n  summarise(max_population = max(population), \n            min_population = min(population), \n            mean_population = mean(population))\n\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  },
  {
    "objectID": "untangled_ls08_advanced_pivoting.html#intro",
    "href": "untangled_ls08_advanced_pivoting.html#intro",
    "title": "16  Advanced pivoting",
    "section": "16.1 Intro",
    "text": "16.1 Intro\nYou know basic pivoting operations from long format datasets to wide format datasets and vice versa. However, as is often the case, basic manipulations are sometimes not enough for the wrangling you need to do. Let’s now see the next level. Let’s go !"
  },
  {
    "objectID": "untangled_ls08_advanced_pivoting.html#learning-objectives",
    "href": "untangled_ls08_advanced_pivoting.html#learning-objectives",
    "title": "16  Advanced pivoting",
    "section": "16.2 Learning Objectives",
    "text": "16.2 Learning Objectives\n\nMaster complex pivoting from wide to long and long to wide\nKnow how to use separators as a pivoting tool"
  },
  {
    "objectID": "untangled_ls08_advanced_pivoting.html#packages",
    "href": "untangled_ls08_advanced_pivoting.html#packages",
    "title": "16  Advanced pivoting",
    "section": "16.3 Packages",
    "text": "16.3 Packages\n\n## Load packages \nif(!require(pacman)) install.packages(\"pacman\")\npacman::p_load(tidyverse, outbreaks, janitor, rio, here, knitr)"
  },
  {
    "objectID": "untangled_ls08_advanced_pivoting.html#datasets",
    "href": "untangled_ls08_advanced_pivoting.html#datasets",
    "title": "16  Advanced pivoting",
    "section": "16.4 Datasets",
    "text": "16.4 Datasets\nWe will introduce these datasets as we go along but here is an overview:\n\nSurvey data from India on how much money patients spent on tuberculosis treatment\nBiomarker data from an enteropathogen study in Zambia\nA diet survey from Vietnam"
  },
  {
    "objectID": "untangled_ls08_advanced_pivoting.html#wide-to-long",
    "href": "untangled_ls08_advanced_pivoting.html#wide-to-long",
    "title": "16  Advanced pivoting",
    "section": "16.5 Wide to long",
    "text": "16.5 Wide to long\nSometimes you have multiple kinds of wide data in the same table. Consider this artificial example of heights and weights for children over two years:\n\nchild_stats &lt;- \n  tibble::tribble(\n    ~child, ~year1_height, ~year2_height, ~year1_weight, ~year2_weight,\n       \"A\",        \"80cm\",        \"85cm\",         \"5kg\",        \"10kg\",\n       \"B\",        \"85cm\",        \"90cm\",         \"7kg\",        \"12kg\",\n       \"C\",        \"90cm\",       \"100cm\",         \"6kg\",        \"14kg\"\n    )\n\nchild_stats\n\n# A tibble: 3 × 5\n  child year1_height year2_height year1_weight year2_weight\n  &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;       \n1 A     80cm         85cm         5kg          10kg        \n2 B     85cm         90cm         7kg          12kg        \n3 C     90cm         100cm        6kg          14kg        \n\n\nIf you pivot all the measurement columns, you’ll get overly long data:\n\nchild_stats %&gt;% \n  pivot_longer(2:5)\n\n# A tibble: 5 × 3\n  child name         value\n  &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt;\n1 A     year1_height 80cm \n2 A     year2_height 85cm \n3 A     year1_weight 5kg  \n4 A     year2_weight 10kg \n5 B     year1_height 85cm \n\n\nThis is not what you (usually) want, because now you have two different kinds of data in the same column—weight and height.\nTo get the right shape, you’ll need to use the names_sep argument and the “.value” identifier:\n\nchild_stats %&gt;% \n  pivot_longer(2:5, \n               names_sep = \"_\",\n               names_to = c(\"period\", \".value\"))\n\n# A tibble: 5 × 4\n  child period height weight\n  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; \n1 A     year1  80cm   5kg   \n2 A     year2  85cm   10kg  \n3 B     year1  85cm   7kg   \n4 B     year2  90cm   12kg  \n5 C     year1  90cm   6kg   \n\n\nNow we have one row for each child-period, an appropriately long format!\nWhat the code above is doing may not be clear, but you should already be able to answer the practice question below by pattern matching with our example. After the practice question, we will explain the names_sep argument and the “.value” identifier in more depth.\n\n\n\n\n\n\nPractice\n\n\n\nConsider this other artificial data set:\n\nadult_stats &lt;- \n  tibble::tribble(\n    ~adult,  ~year1_BMI,  ~year2_BMI,  ~year1_HIV,  ~year2_HIV,\n       \"A\",          25,          30,  \"Positive\",  \"Positive\",\n       \"B\",          34,          28,  \"Negative\",  \"Positive\",\n       \"C\",          19,          17,  \"Negative\",  \"Negative\"\n  )\n\n\nadult_stats\n\n# A tibble: 3 × 5\n  adult year1_BMI year2_BMI year1_HIV year2_HIV\n  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;    \n1 A            25        30 Positive  Positive \n2 B            34        28 Negative  Positive \n3 C            19        17 Negative  Negative \n\n\nPivot the data into a long format to get the following structure:\n\n\n\nadult\nyear\nBMI\nHIV\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQ_adult_long &lt;-\n  adult_stats %&gt;%\n  pivot_longer(_________)\n\n\n\n\n\n\n\n\n\nSide Note\n\n\n\nThe child_stats example above has numbers stored as characters […]\nAs you saw in the previous lesson, you can easily extract the numbers from the output long data frame in our example using the parse_number() function from readr:\n\nchild_stats_long &lt;- \n  child_stats %&gt;% \n  pivot_longer(2:5, \n               names_sep = \"_\",\n               names_to = c(\"period\", \".value\"))\n\nchild_stats_long\n\n# A tibble: 5 × 4\n  child period height weight\n  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; \n1 A     year1  80cm   5kg   \n2 A     year2  85cm   10kg  \n3 B     year1  85cm   7kg   \n4 B     year2  90cm   12kg  \n5 C     year1  90cm   6kg   \n\n\n\nchild_stats_long %&gt;% \n  mutate(height = parse_number(height), \n         weight = parse_number(weight))\n\n# A tibble: 5 × 4\n  child period height weight\n  &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1 A     year1      80      5\n2 A     year2      85     10\n3 B     year1      85      7\n4 B     year2      90     12\n5 C     year1      90      6\n\n\n\n\n\n16.5.1 Understanding names_sep and “.value”\nNow let’s break down the pivot_longer() call we saw above a bit more:\n\nchild_stats\n\n# A tibble: 3 × 5\n  child year1_height year2_height year1_weight year2_weight\n  &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;       \n1 A     80cm         85cm         5kg          10kg        \n2 B     85cm         90cm         7kg          12kg        \n3 C     90cm         100cm        6kg          14kg        \n\nchild_stats %&gt;% \n  pivot_longer(2:5, \n               names_sep = \"_\",\n               names_to = c(\"period\", \".value\"))\n\n# A tibble: 5 × 4\n  child period height weight\n  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; \n1 A     year1  80cm   5kg   \n2 A     year2  85cm   10kg  \n3 B     year1  85cm   7kg   \n4 B     year2  90cm   12kg  \n5 C     year1  90cm   6kg   \n\n\nNotice that the column names in the original child_stats data frame (year1_height, year2_height and so on) are made of three parts:\n\nthe period being referenced: e.g. “year1”\nan underscore separator, “_”;\nand the type of value recorded “height” or “weight”\n\nWe can make a table with these parts:\n\n\n\ncolumn_name\nperiod\nseparator\n“.value”\n\n\n\n\nyear1_height\nyear1\n_\nheight\n\n\nyear2_height\nyear2\n_\nheight\n\n\nyear1_weight\nyear1\n_\nweight\n\n\nyear2_weight\nyear2\n_\nweight\n\n\n\nBased on that table, it should now be easier to understand the names_sep and names_to arguments that we supplied to pivot_longer():\n\n16.5.1.1 names_sep = \"_\":\nThis is the separator between the period indicator (year) and the values (year and weight) recorded.\nIf we have a different separator, this argument would change. For example, if the separator were an empty space, ” “, you would have names_sep = \" \", as seen in the example below:\n\nchild_stats_space_sep &lt;- \n  tibble::tribble(\n    ~child, ~`yr1 height`, ~`yr2 height`, ~`yr1 weight`, ~`yr2 weight`,\n       \"A\",        \"80cm\",        \"85cm\",         \"5kg\",        \"10kg\",\n       \"B\",        \"85cm\",        \"90cm\",         \"7kg\",        \"12kg\",\n       \"C\",        \"90cm\",       \"100cm\",         \"6kg\",        \"14kg\"\n    )\n\nchild_stats_space_sep %&gt;% \n  pivot_longer(2:5, \n               names_sep = \" \", \n               names_to = c(\"period\", \".value\"))\n\n# A tibble: 5 × 4\n  child period height weight\n  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; \n1 A     yr1    80cm   5kg   \n2 A     yr2    85cm   10kg  \n3 B     yr1    85cm   7kg   \n4 B     yr2    90cm   12kg  \n5 C     yr1    90cm   6kg   \n\n\n\n\n16.5.1.2 names_to = c(\"period\", \".value\")\nNext, the names_to argument indicates how the data should be reshaped. We passed a vector of two character strings , “period” and the “.value” to this argument. Let’s consider each in turn:\nThe “period” string indicated that we want to move the data from each year (or period) into a separate row Note that there is nothing special about the word “period” used here; we could change this to any other string. So instead of “period”, you could have written “time” or “year_of_measurement” or anything else:\n\nchild_stats %&gt;% \n  pivot_longer(2:5, \n               names_sep = \"_\",\n               names_to = c(\"year_of_measurement\", \".value\"))\n\n# A tibble: 5 × 4\n  child year_of_measurement height weight\n  &lt;chr&gt; &lt;chr&gt;               &lt;chr&gt;  &lt;chr&gt; \n1 A     year1               80cm   5kg   \n2 A     year2               85cm   10kg  \n3 B     year1               85cm   7kg   \n4 B     year2               90cm   12kg  \n5 C     year1               90cm   6kg   \n\n\nNow, the “.value” placeholder is a special indicator, that tells pivot_longer() to make a separate column for every distinct value that appears after the separator. In our example, these distinct values are “height” and “weight”.\nThe “.value” string cannot be arbitrarily replaced. For example, this won’t work:\n\nchild_stats %&gt;% \n  pivot_longer(2:5, \n               names_sep = \"_\", \n               names_to = c(\"period\", \"values\"))\n\n# A tibble: 5 × 4\n  child period values value\n  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;\n1 A     year1  height 80cm \n2 A     year2  height 85cm \n3 A     year1  weight 5kg  \n4 A     year2  weight 10kg \n5 B     year1  height 85cm \n\n\n\nTo restate the point, the “.value” placeholder is tells pivot_longer() that we want to separate out the “height” and “weight” values into separate columns, because there are the two value types that occur after the “_” separator in the column names.\nThis means that if you had a wide dataset with three types of values, you would get separated-out columns, one for each value type. For example, consider the mock dataset below which shows children’s records, at two time points, for the following variables:\n\nage in months,\nbody fat %\nbmi\n\n\nchild_stats_three_values &lt;- \n  tibble::tribble(\n  ~child,  ~t1_age,  ~t2_age, ~t1_fat, ~t2_fat, ~t1_bmi, ~t2_bmi,\n     \"a\",  \"5mths\",  \"8mths\",   \"13%\",   \"15%\",      14,      15,\n     \"b\",  \"7mths\",  \"9mths\",   \"15%\",   \"17%\",      16,      18\n  )\nchild_stats_three_values\n\n# A tibble: 2 × 7\n  child t1_age t2_age t1_fat t2_fat t1_bmi t2_bmi\n  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1 a     5mths  8mths  13%    15%        14     15\n2 b     7mths  9mths  15%    17%        16     18\n\n\nHere, in the column names there are three value types occurring after the “_” separator: age, fat and bmi; the “.value” string tells pivot_longer() to make a new column for each value type:\n\nchild_stats_three_values %&gt;% \n  pivot_longer(2:7, \n               names_sep = \"_\",\n               names_to = c(\"time\", \".value\")\n               )\n\n# A tibble: 4 × 5\n  child time  age   fat     bmi\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n1 a     t1    5mths 13%      14\n2 a     t2    8mths 15%      15\n3 b     t1    7mths 15%      16\n4 b     t2    9mths 17%      18\n\n\n\n\n\n\n\n\nPractice\n\n\n\nA pediatrician records the following information for a set of children over two years:\n\nhead circumference;\nneck circumference; and\nhip circumference\n\nall in centimeters.\nThe output table resembles the below:\n\ngrowth_stats &lt;- \n  tibble::tribble(\n    ~child,~yr1_head,~yr2_head,~yr1_neck,~yr2_neck,~yr1_hip,~yr2_hip,\n       \"a\",       45,       48,       23,       24,      51,      52,\n       \"b\",       48,       50,       24,       26,      52,      52,\n       \"c\",       50,       52,       24,       27,      53,      54\n    )\n\ngrowth_stats\n\n# A tibble: 3 × 7\n  child yr1_head yr2_head yr1_neck yr2_neck yr1_hip yr2_hip\n  &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 a           45       48       23       24      51      52\n2 b           48       50       24       26      52      52\n3 c           50       52       24       27      53      54\n\n\nPivot the data into a long format to get the following structure:\n\n\n\nchild\nyear\nhead\nneck\nhip\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQ_growth_stats_long &lt;-\n  growth_stats %&gt;%\n  pivot_longer(_________)\n\n\n\n\n\n\n16.5.2 Value type before the separator\nIn all the example we have used so far, the column names were constructed such that value type came after the separator (Recall our table:\n\n\n\ncolumn_name\nperiod\nseparator\n“.value”\n\n\n\n\nyear1_height\nyear1\n_\nheight\n\n\nyear2_height\nyear2\n_\nheight\n\n\nyear1_weight\nyear1\n_\nweight\n\n\nyear2_weight\nyear2\n_\nweight\n\n\n\n)\nBut of course, the column names could be constructed differently, with the value types coming before the separator, as in this example:\n\nchild_stats2 &lt;- \n  tibble::tribble(\n    ~child, ~height_year1, ~height_year2, ~weight_year1, ~weight_year2,\n       \"A\",        \"80cm\",        \"85cm\",         \"5kg\",        \"10kg\",\n       \"B\",        \"85cm\",        \"90cm\",         \"7kg\",        \"12kg\",\n       \"C\",        \"90cm\",       \"100cm\",         \"6kg\",        \"14kg\"\n    )\n\nchild_stats2\n\n# A tibble: 3 × 5\n  child height_year1 height_year2 weight_year1 weight_year2\n  &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;       \n1 A     80cm         85cm         5kg          10kg        \n2 B     85cm         90cm         7kg          12kg        \n3 C     90cm         100cm        6kg          14kg        \n\n\nHere, the value types (height and weight) come before the “_” separator.\nHow can our pivot_longer() command accommodate this? Simple! Just swap the order of the vector given to the names_to argument:\nSo instead of names_to = c(\"time\", \".value\"), you would have names_to = c(\".value\", \"time\"):\n\nchild_stats2 %&gt;% \n  pivot_longer(2:5, \n               names_sep = \"_\",\n               names_to = c(\".value\", \"time\"))\n\n# A tibble: 5 × 4\n  child time  height weight\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; \n1 A     year1 80cm   5kg   \n2 A     year2 85cm   10kg  \n3 B     year1 85cm   7kg   \n4 B     year2 90cm   12kg  \n5 C     year1 90cm   6kg   \n\n\nAnd that’s it!\n\n\n\n\n\n\nPractice\n\n\n\nConsider the following data set from Zambia about enteropathogens and their biomarkers.\n\nenteropathogens_zambia_wide&lt;- read_csv(here(\"data/enteropathogens_zambia_wide.csv\"))\n\nenteropathogens_zambia_wide\n\n# A tibble: 5 × 7\n     ID LPS_1 LPS_2  LBP_1 LBP_2 IFABP_1 IFABP_2\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1  1002  222.  390. 38414. 6840.  1294.     610.\n2  1003  181.   NA  26888.   NA     22.5     NA \n3  1004  257.  221. 49183. 5426.     0        0 \n4  1005   NA   369.    NA  1938.     0     1010.\n5  1006  275.   NA  61758.   NA      0       NA \n\n\nThis data frame has the following columns:\n\nLPS_1 and LPS_2: lipopolysaccharide levels, measured by Pyrochrome LAL, in EU/mL\nLBP_1 and LBP_2: LPS binding protein levels, in pg/mL\nIFABP_1 and IFAPB_2: intestinal-type fatty acid binding protein levels, in pg/mL\n\nPivot the dataset so that it resembles the following structure\n\n\n\nID\nsample_count\nLPS\nLBP\nIFABP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nenteropathogens_zambia_wide %&gt;% \n   pivot_longer(____________)\n\n\n\n\n\n16.5.3 A non-time-series example\nSo far we have been using person-period (time series) datasets to illustrate the idea of complex pivots with multiple value types.\nBut as we have mentioned, not all reshape-requiring datasets are time series data. Let’s see a quick non-time-series example […]\nYou might measure the height (cm) and weight (kg) of a series of parental couples in a table like this:\n\nfamily_stats &lt;- \n  tibble::tribble(\n  ~couple, ~father_height, ~father_weight, ~mother_height, ~mother_weight,\n      \"a\",            180,            80,            160,             70,\n      \"b\",            185,            90,            150,             76,\n      \"c\",            182,            93,            143,             78\n  )\nfamily_stats\n\n# A tibble: 3 × 5\n  couple father_height father_weight mother_height mother_weight\n  &lt;chr&gt;          &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1 a                180            80           160            70\n2 b                185            90           150            76\n3 c                182            93           143            78\n\n\nHere we have two different types of values (weight and height) for each person in the couple.\nTo pivot this to one-row per person, we’ll again need the names_sep and names_to arguments:\n\nfamily_stats %&gt;% \n  pivot_longer(2:5, \n               names_sep  = \"_\",\n               names_to = c(\"person\", \".value\"))\n\n# A tibble: 5 × 4\n  couple person height weight\n  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1 a      father    180     80\n2 a      mother    160     70\n3 b      father    185     90\n4 b      mother    150     76\n5 c      father    182     93\n\n\nThe separator is an underscore, “_”, so we used names_sep  = \"_\" and because the value types come after the separator, the “.value” identifier was placed second in the names_to argument.\n\n\n16.5.4 Escaping the dot separator\nA special example may crop up when you try to pivot a dataset where the separator is a period.\n\nchild_stats_dot_sep &lt;- \n  tibble::tribble(\n    ~child, ~year1.height, ~year2.height, ~year1.weight, ~year2.weight,\n       \"A\",        \"80cm\",        \"85cm\",         \"5kg\",        \"10kg\",\n       \"B\",        \"85cm\",        \"90cm\",         \"7kg\",        \"12kg\",\n       \"C\",        \"90cm\",       \"100cm\",         \"6kg\",        \"14kg\"\n    )\n\nchild_stats_dot_sep %&gt;% \n  pivot_longer(2:5, \n               names_to = c(\"period\", \".value\"),\n               names_sep = \"\\\\.\")\n\n# A tibble: 5 × 4\n  child period height weight\n  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; \n1 A     year1  80cm   5kg   \n2 A     year2  85cm   10kg  \n3 B     year1  85cm   7kg   \n4 B     year2  90cm   12kg  \n5 C     year1  90cm   6kg   \n\n\nThere we used the string “\\.” to indicate a dot “.” because the “.” is a special character in R, and sometimes needs to be escaped\n\n\n\n\n\n\nPractice\n\n\n\nConsider again the adult_stats data you saw above. Now the column names have been changed slightly.\n\nadult_stats_dot_sep &lt;- \n  tibble::tribble(\n    ~adult,  ~`BMI.year1`,  ~`BMI.year2`,  ~`HIV.year1`,  ~`HIV.year2`,\n       \"A\",            25,            30,    \"Positive\",   \"Positive\",\n       \"B\",            34,            28,    \"Negative\",   \"Positive\",\n       \"C\",            19,            17,    \"Negative\",   \"Negative\"\n  )\n\n\nadult_stats_dot_sep\n\n# A tibble: 3 × 5\n  adult BMI.year1 BMI.year2 HIV.year1 HIV.year2\n  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;    \n1 A            25        30 Positive  Positive \n2 B            34        28 Negative  Positive \n3 C            19        17 Negative  Negative \n\n\nAgain, pivot the data into a long format to get the following structure:\n\n\n\nadult\nyear\nBMI\nHIV\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQ_adult2_long &lt;-\n  adult_stats_dot_sep %&gt;%\n  pivot_longer(_________)\n\n\n\n\n\n16.5.5 What to do when you don’t have a neat separator ?\nSometimes you do not have a neat separator.\nConsider this survey data from India that looked at how much money patients spent on tuberculosis treatment:\n\ntb_visits &lt;- read_csv(here(\"data/india_tb_pathways_and_costs_data.csv\")) %&gt;% \n  clean_names() %&gt;% \n  select(id, first_visit_location, first_visit_cost, second_visit_location, second_visit_cost, third_visit_location, third_visit_cost)\n\ntb_visits\n\n# A tibble: 5 × 7\n      id first_visit_location first_visit_cost second_visit_location\n   &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;chr&gt;                \n1 100202 GH                                  0 &lt;NA&gt;                 \n2 100396 Pvt. docto                       1500 Pvt. clini           \n3 100590 Pvt. docto                       2000 Pvt. docto           \n4 100687 Pvt. hospi                      20000 Pvt. hospi           \n5 100784 Pvt. docto                       1000 GH                   \n# ℹ 3 more variables: second_visit_cost &lt;dbl&gt;, third_visit_location &lt;chr&gt;,\n#   third_visit_cost &lt;dbl&gt;\n\n\nIt does not have a neat separator between the time indicators (first, second, third) and the value type (cost, location). That is, rather than something like “firstvisit_location”, we have instead “first_visit_location”, so the underscore is used for two purposes. For this reason, if you try our usual pivot strategy, you will get an error:\n\ntb_visits %&gt;% \n  pivot_longer(2:7, \n               names_to = c(\"visit_count\", \".value\"), \n               names_sep = \"_\")\n\nError in `pivot_longer_spec()`:\n! Can't combine `first_visit_location` &lt;character&gt; and `first_visit_cost` &lt;double&gt;.\nRun `rlang::last_error()` to see where the error occurred.\nThe most direct way to reshape this dataset successfully would be to use special “regex” (string manipulation), but you likely have not learned this yet!\nSo for now, the solution we recommend is to manually rename your columns to insert a clear separator, “__”:\n\ntb_visits_renamed &lt;- \n  tb_visits %&gt;% \n  rename(first__visit_location = first_visit_location, \n         first__visit_cost = first_visit_cost, \n         second__visit_location = second_visit_location, \n         second__visit_cost= second_visit_cost, \n         third__visit_location = third_visit_location, \n         third__visit_cost = third_visit_cost)\n\ntb_visits_renamed\n\n# A tibble: 5 × 7\n      id first__visit_location first__visit_cost second__visit_location\n   &lt;dbl&gt; &lt;chr&gt;                             &lt;dbl&gt; &lt;chr&gt;                 \n1 100202 GH                                    0 &lt;NA&gt;                  \n2 100396 Pvt. docto                         1500 Pvt. clini            \n3 100590 Pvt. docto                         2000 Pvt. docto            \n4 100687 Pvt. hospi                        20000 Pvt. hospi            \n5 100784 Pvt. docto                         1000 GH                    \n# ℹ 3 more variables: second__visit_cost &lt;dbl&gt;, third__visit_location &lt;chr&gt;,\n#   third__visit_cost &lt;dbl&gt;\n\n\nNow we can try the pivot:\n\ntb_visits_long &lt;-\n  tb_visits_renamed %&gt;% \n  pivot_longer(2:7, \n               names_to = c(\"visit_count\", \".value\"), \n               names_sep = \"__\")\ntb_visits_long\n\n# A tibble: 5 × 4\n      id visit_count visit_location visit_cost\n   &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;               &lt;dbl&gt;\n1 100202 first       GH                      0\n2 100202 second      &lt;NA&gt;                    0\n3 100202 third       &lt;NA&gt;                    0\n4 100396 first       Pvt. docto           1500\n5 100396 second      Pvt. clini           1000\n\n\nNow let’s polish the data frame:\n\ntb_visits_long %&gt;% \n  # remove nonexistent entries\n  filter(!visit_location == \"\") %&gt;% \n  # give significant naming to the visit_count values\n  mutate(visit_count = case_when(visit_count == \"first\" ~ 1, \n                                 visit_count == \"second\" ~ 2, \n                                 visit_count == \"third\" ~ 3)) %&gt;% \n  # ensure visit_cost is numerical\n  mutate(visit_cost = as.numeric(visit_cost))\n\n# A tibble: 5 × 4\n      id visit_count visit_location visit_cost\n   &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt;\n1 100202           1 GH                      0\n2 100396           1 Pvt. docto           1500\n3 100396           2 Pvt. clini           1000\n4 100396           3 Pvt. hospi           2500\n5 100590           1 Pvt. docto           2000\n\n\nAbove, we first remove the entries where we do not have the visit location information (i.e. we filter out the rows where the visit location variable is set to \"\" ). We then convert to numeric values the visit count variable, where the strings \"first\" to \"third\" are converted to numerical entries 1 to 3. Finally, we ensure the variable of visit cost is numeric using mutate() and the helper function as.numeric().\n\n\n\n\n\n\nPractice\n\n\n\nWe will use a survey data about diet from Vietnam. Women in Hanoi were interviewed about their food shopping, and this was used to create nutrition profiles for each women. Here we will use a subset of this data for 61 households who came for 2 visits, recording:\n\nenerc_kcal_w_1: the consumed energy from ingredient/food (Kcal) during the first visit (with _2 for the second visit)\ndry_w_1: the consumed dry from ingredient/food (g) during the first visit (with _2 for the second visit)\nwater_w_1: the consumed water from ingredient/food (g) during the first visit (with _2 for the second visit)\nfat_w_1: the consumed Lipid from ingredient/food (g) during the first visit (with _2 for the second visit)\n\n\ndiet_diversity_vietnam_wide &lt;- read_csv(here(\"data/diet_diversity_vietnam_wide.csv\"))\n\ndiet_diversity_vietnam_wide\n\n# A tibble: 5 × 9\n  household_id enerc_kcal_w_1 enerc_kcal_w_2 dry_w_1 dry_w_2 water_w_1 water_w_2\n         &lt;dbl&gt;          &lt;dbl&gt;          &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1          348          2268.          1386.    548.    281.     4219.     1997.\n2          354          2775.          1240.    600.    284.     2376.     3145.\n3           53          3104.          2075.    646.    451.     2808.     2305.\n4           18          2802.          2146.    620.    807.     3457.     1903.\n5          211          1298.          1191.    269.    288.     2584.     2269.\n# ℹ 2 more variables: fat_w_1 &lt;dbl&gt;, fat_w_2 &lt;dbl&gt;\n\n\nYou should first distinguish if we have a neat operator or not. Based on this, rename your columns if necessary. Then bring the different visit records (1 and 2) into a sole column for energy, fat weight, water weight and dry weight. In other words, pivot the dataset into long format of this form:\n\n\n\nhousehold_id\nvisit\nenerc_kcal_w\ndry_w\nwater_w\nfat_w\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQ_diet_diversity_vietnam_long &lt;-\n  diet_diversity_vietnam_wide %&gt;%\n  pivot_longer(_________)"
  },
  {
    "objectID": "untangled_ls08_advanced_pivoting.html#long-to-wide",
    "href": "untangled_ls08_advanced_pivoting.html#long-to-wide",
    "title": "16  Advanced pivoting",
    "section": "16.6 Long to wide",
    "text": "16.6 Long to wide\nWe just saw how to do some complex operations wide to long, which we saw in the previous lesson is essential for plotting and wrangling. Let’s see the opposite transformation.\nIt could be useful to put long to wide to do different transformations, filters, and processing NAs. In this format, your measurements / collected data become the columns of the data set.\nLet’s take the Zambia enteropathogen data, and this time, let’s take the original ! Indeed, what you were handling before was a dataset prepared for you, in a wide format. The original dataset is long and we will now see the data preparation I did beforehand, behind the scenes. You’re almost becoming the teacher of this lesson ;)\n\nenteropathogens_zambia_long &lt;- read_csv(here(\"data/enteropathogens_zambia_long.csv\"))\nenteropathogens_zambia_long\n\n# A tibble: 5 × 5\n     ID group   LPS    LBP  IFABP\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1  1002     1  222. 38414. 1294. \n2  1002     2  390.  6840.  610. \n3  1003     1  181. 26888.   22.5\n4  1004     2  221.  5426.    0  \n5  1004     1  257. 49183.    0  \n\n\nThis is how we convert it from long to wide:\n\nenteropathogens_zambia_wide &lt;-\n  enteropathogens_zambia_long %&gt;%\n  pivot_wider(\n    names_from = group,\n    values_from = c(LPS, LBP, IFABP)\n  )\n\nenteropathogens_zambia_wide\n\n# A tibble: 5 × 7\n     ID LPS_1 LPS_2  LBP_1 LBP_2 IFABP_1 IFABP_2\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1  1002  222.  390. 38414. 6840.  1294.     610.\n2  1003  181.   NA  26888.   NA     22.5     NA \n3  1004  257.  221. 49183. 5426.     0        0 \n4  1005   NA   369.    NA  1938.     0     1010.\n5  1006  275.   NA  61758.   NA      0       NA \n\n\nYou can see that the values of the variable group (1 or 2) are added to the values’ names (LPS, LBP, IFABP) to create the new columns representing different group data: for example, LPS_1 and LPS_2.\nWe are considering this “advanced” pivoting because we are pivoting wider several variables at the same time, but as you can see, the syntax is quite simple—the same arguments are used as we did with the simpler pivots in the previous lesson—names_from and values_from.\n\nLet’s see another example, using the diet survey data from Vietnam that you manipulated previously:\n\ndiet_diversity_vietnam_long &lt;- read_csv(here(\"data/diet_diversity_vietnam_long.csv\"))\ndiet_diversity_vietnam_long\n\n# A tibble: 5 × 6\n  visit_number household_id enerc_kcal_w dry_w water_w fat_w\n         &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1            1          348        2268.  548.   4219.  78.4\n2            1          354        2775.  600.   2376. 115. \n3            1           53        3104.  646.   2808. 127. \n4            1           18        2802.  620.   3457.  87.4\n5            1          211        1298.  269.   2584.  47.8\n\n\nHere we will use the visit_number variable to create new variable for energy, water, fat and dry content of foods recorded at different visits:\n\ndiet_diversity_vietnam_wide &lt;-\n  diet_diversity_vietnam_long %&gt;%\n  pivot_wider(\n    names_from = visit_number, \n    values_from = c(enerc_kcal_w, dry_w, water_w, fat_w)\n  )\n\ndiet_diversity_vietnam_wide\n\n# A tibble: 5 × 9\n  household_id enerc_kcal_w_1 enerc_kcal_w_2 dry_w_1 dry_w_2 water_w_1 water_w_2\n         &lt;dbl&gt;          &lt;dbl&gt;          &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1          348          2268.          1386.    548.    281.     4219.     1997.\n2          354          2775.          1240.    600.    284.     2376.     3145.\n3           53          3104.          2075.    646.    451.     2808.     2305.\n4           18          2802.          2146.    620.    807.     3457.     1903.\n5          211          1298.          1191.    269.    288.     2584.     2269.\n# ℹ 2 more variables: fat_w_1 &lt;dbl&gt;, fat_w_2 &lt;dbl&gt;\n\n\nYou can see that the values of the variable visit_number (1 or 2) are added to the values’ names (energy_kcal_w, dry_w, fat_w, water_w) to create the new columns representing different group data: for example, water_w_1 and water_w_2. We have pivoted to wide format all of these variables at the same time. Now each weight measure per visit is represented as a single variable (i.e. column) in the dataset.\nWith this format, it is easy to sum together the energy intake per household for example:\n\ndiet_diversity_vietnam_wide %&gt;%\n  select(household_id, enerc_kcal_w_1, enerc_kcal_w_2) %&gt;%\n  mutate(total_energy_kcal = enerc_kcal_w_1 + enerc_kcal_w_2) %&gt;%\n  arrange(household_id)\n\n# A tibble: 5 × 4\n  household_id enerc_kcal_w_1 enerc_kcal_w_2 total_energy_kcal\n         &lt;dbl&gt;          &lt;dbl&gt;          &lt;dbl&gt;             &lt;dbl&gt;\n1           14          1040.          1663.             2704.\n2           17          2100.          1286.             3386.\n3           18          2802.          2146.             4948.\n4           22          3187.          1582.             4769.\n5           24          2359.          2026.             4385.\n\n\nHowever, you could get something similar in the long format:\n\ndiet_diversity_vietnam_long %&gt;%\n  group_by(household_id) %&gt;%\n  summarize(total_energy = sum(enerc_kcal_w)) \n\n# A tibble: 5 × 2\n  household_id total_energy\n         &lt;dbl&gt;        &lt;dbl&gt;\n1           14        2704.\n2           17        3386.\n3           18        4948.\n4           22        4769.\n5           24        4385.\n\n\n\n\n\n\n\n\nPractice\n\n\n\nTake tb_visits_long dataset that we manipulated above and pivot it back to a wide format.\n\nQ_tb_visit_wide &lt;-\n  tb_visits_long %&gt;%\n  pivot_wider(_________)"
  },
  {
    "objectID": "untangled_ls08_advanced_pivoting.html#wrap-up",
    "href": "untangled_ls08_advanced_pivoting.html#wrap-up",
    "title": "16  Advanced pivoting",
    "section": "16.7 Wrap up",
    "text": "16.7 Wrap up\nYou data wrangling skills have just been enhanced with advanced pivoting. This skill will often prove essential when handling real world data. I have no doubt you will soon put it into practice. It is also essential, as we have seen, for plotting. So I hope pivoting will be of use not only for your wrangling, but also for your plotting tasks.\n KENE DAVID NWOSU    Data analyst, the GRAPH Network Passionate about world improvement  LAURE VANCAUWENBERGHE    Data analyst, the GRAPH Network A firm believer in science for good, striving to ally programming, health and education  CAMILLE BEATRICE VALERA    Project Manager and Scientific Collaborator, The GRAPH Network"
  },
  {
    "objectID": "untangled_ls08_advanced_pivoting.html#solutions",
    "href": "untangled_ls08_advanced_pivoting.html#solutions",
    "title": "16  Advanced pivoting",
    "section": "16.8 Solutions",
    "text": "16.8 Solutions\n\n.SOLUTION_Q_adult_long()\n\n\n\n  \n  adult_stats %&gt;%\n      pivot_longer(cols = 2:5,\n                   names_sep = \"_\",\n                   names_to = c(\"year\", \".value\"))\n\n.SOLUTION_Q_growth_stats_long()\n\n\n\n  \n  growth_stats %&gt;%\n     pivot_longer(cols = 2:7,\n                   names_to = c(\"year\", \".value\"),\n                   names_sep = \"_\")\n\n.SOLUTION_Q_adult2_long()\n\n\n\n  \n  adult_stats_dot_sep %&gt;%\n      pivot_longer(cols = 2:5,\n                   names_sep = \"\\.\",\n                   names_to = c(\".value\", \"year\"))\n\n.SOLUTION_Q_diet_diversity_vietnam_long()\n\n\n\n  \n  diet_diversity_vietnam_wide%&gt;%\n      rename(\n        enerc_kcal_w__1 = enerc_kcal_w_1,\n        enerc_kcal_w__2 = enerc_kcal_w_2,\n        dry_w__1 = dry_w_1,\n        dry_w__2 = dry_w_2,\n        water_w__1 = water_w_1,\n        water_w__2 = water_w_2,\n        fat_w__1 = fat_w_1,\n        fat_w__2 = fat_w_2\n      ) %&gt;%  \n      pivot_longer(2:9, names_sep = \"__\", names_to = c(\".value\", \"visit\"))\n  \n\n.SOLUTION_Q_tb_visit_wide()\n\n\n\n  \n  tb_visits_long %&gt;%\n      pivot_wider(names_from = visit_count,\n                  values_from = c(visit_location, visit_cost))\n      )\n\n.SOLUTION_Q_adult_long()\n\n\n\n  \n  adult_stats %&gt;%\n      pivot_longer(cols = 2:5,\n                   names_sep = \"_\",\n                   names_to = c(\"year\", \".value\"))\n\n.SOLUTION_Q_growth_stats_long()\n\n\n\n  \n  growth_stats %&gt;%\n     pivot_longer(cols = 2:7,\n                   names_to = c(\"year\", \".value\"),\n                   names_sep = \"_\")\n\n.SOLUTION_Q_adult2_long()\n\n\n\n  \n  adult_stats_dot_sep %&gt;%\n      pivot_longer(cols = 2:5,\n                   names_sep = \"\\.\",\n                   names_to = c(\".value\", \"year\"))\n\n.SOLUTION_Q_diet_diversity_vietnam_long()\n\n\n\n  \n  diet_diversity_vietnam_wide%&gt;%\n      rename(\n        enerc_kcal_w__1 = enerc_kcal_w_1,\n        enerc_kcal_w__2 = enerc_kcal_w_2,\n        dry_w__1 = dry_w_1,\n        dry_w__2 = dry_w_2,\n        water_w__1 = water_w_1,\n        water_w__2 = water_w_2,\n        fat_w__1 = fat_w_1,\n        fat_w__2 = fat_w_2\n      ) %&gt;%  \n      pivot_longer(2:9, names_sep = \"__\", names_to = c(\".value\", \"visit\"))\n  \n\n.SOLUTION_Q_tb_visit_wide()\n\n\n\n  \n  tb_visits_long %&gt;%\n      pivot_wider(names_from = visit_count,\n                  values_from = c(visit_location, visit_cost))\n      )"
  },
  {
    "objectID": "data_on_display_ls01_gg_intro.html#introduction",
    "href": "data_on_display_ls01_gg_intro.html#introduction",
    "title": "17  Intro to ggplot2",
    "section": "17.1 Introduction",
    "text": "17.1 Introduction\nWelcome to The GRAPH Courses’ Data Visualization course!\nWe will focus on learning how to use the {ggplot2} package to produce high quality visualizations in R.\n\n\n\n{ggplot2} is one of the core packages of the {tidyverse} metapackage. It is the most popular R package for data visualization.\n\n\nLet’s dive in!"
  },
  {
    "objectID": "data_on_display_ls01_gg_intro.html#learning-objectives",
    "href": "data_on_display_ls01_gg_intro.html#learning-objectives",
    "title": "17  Intro to ggplot2",
    "section": "17.2 Learning objectives",
    "text": "17.2 Learning objectives\nBy the end of this lesson you should be able to:\n\nRecall and explain how the {ggplot2} package for data visualization is based on a theoretical framework called the grammar of graphics.\nName and describe the 3 essential components required for building a graph: data, aesthetics, and geometries.\nWrite code to build a complete ggplot graphic by correctly supplying the 3 essential layers to the ggplot() function.\nCreate different types of plots such as scatter plots, line graphs, and bar graphs.\nAdd or modify visual elements of a plot such as color and size.\nDistinguish between between aesthetic mappings and fixed aesthetics, and how to apply them.\n\n\n\n\nIllustration by Allison Horst"
  },
  {
    "objectID": "data_on_display_ls01_gg_intro.html#packages",
    "href": "data_on_display_ls01_gg_intro.html#packages",
    "title": "17  Intro to ggplot2",
    "section": "17.3 Packages",
    "text": "17.3 Packages\nThe {tidyverse} meta package includes {ggplot2}, so we don’t need to add it separately. The {here} package will help us correctly reference file paths.\n\n## Load packages \npacman::p_load(tidyverse,\n               here)"
  },
  {
    "objectID": "data_on_display_ls01_gg_intro.html#measles-outbreaks-in-niger",
    "href": "data_on_display_ls01_gg_intro.html#measles-outbreaks-in-niger",
    "title": "17  Intro to ggplot2",
    "section": "17.4 Measles outbreaks in Niger",
    "text": "17.4 Measles outbreaks in Niger\nIn this lesson, we will explore patterns of measles outbreaks in Niger.\nMeasles is a highly infectious virus spread by airborne respiratory droplets.\n[Slide presentation about geography]\nSince it is transmitted through direct contact, population density is an important driver of measles dynamics.\n\n17.4.1 The nigerm dataset\nWe will be creating plots with a dataset of weekly reported measles cases at the region level in Niger.\nThese data were collected by the Ministry of Health of Niger, from 1 Jan 1995 to 31 Dec 2005.\nTo get started, let’s first load the (preprocessed) data set:\n\n## Import data frame to RStudio Environment\nload(here(\"data/clean/nigerm_cases_rgn.RData\"))\n\nTake a moment to browse through the data:\n\n## Print Niger measles (nigerm) data frame\nnigerm\n\n\n\n\n\n\nThe nigerm data frame has 4 variables (or columns):\n\nyear: Calendar year (ranges from 1995 to 2005)\nweek: Week of the year (ranges from 1 to 52)\nregion: Region in which the cases were recorded (see figure below)\ncases: Number of measles cases reported\n\n\n\n\nAdministrative divisions of Niger: Districts and Regions\n\n\nSeveral papers have investigated these trends, linking measles to human activity, migration, and seasonality.\n\n\n\nResearch articles that have used this dataset, and analyzed it in R!\n\n\nThese studies are much more complex than what we will do there, but let’s see if we can find any patterns even with basic exploratory data visualization.\nWe can get some information about patterns in this data by inspecting summary statistics given by the summary() function:\n\nsummary(nigerm)\n\n      year           week           region         cases       \n Min.   :1995   Min.   : 1.00   Agadez : 572   Min.   :   0.0  \n 1st Qu.:1997   1st Qu.:13.75   Diffa  : 572   1st Qu.:   1.0  \n Median :2000   Median :26.50   Dosso  : 572   Median :  16.0  \n Mean   :2000   Mean   :26.50   Maradi : 572   Mean   : 100.3  \n 3rd Qu.:2003   3rd Qu.:39.25   Niamey : 572   3rd Qu.:  86.0  \n Max.   :2005   Max.   :52.00   Tahoua : 572   Max.   :1887.0  \n                                (Other):1144                   \n\n\nThis gives us values for the maximum, minimum, and quartiles of each numeric variable, and the number of observations (rows) for each region. This is summary useful, but it omits a large amount information contained in the dataset.\nKeep in mind that summary statistics can be highly misleading, and a simple plot can reveal a lot more.\nThe easiest and clearest way to analyze patterns from this dataset is to visualize it!\nThe best way to do this in R is with {ggplot2}. So let’s see how that works.\n\n\n17.4.2 The layered Grammar of Graphics\nThe gg in ggplot is short for “grammar of graphics”, which is the data visualization philosophy that {ggplot2} is based on.\nThe grammar of graphics is a theoretical framework which deconstructs the process of producing a graph.\nThink of how we construct and form sentences in written and spoken languages by combining different elements, like nouns, verbs, articles, subjects, objects, etc. We can’t just combine these elements in any arbitrary order; we must do so following a set of rules known as a linguistic grammar.\nSimilarly, the grammar of graphics (GG) defines a set of rules for constructing graphics by combining different types of elements, known as layers.\n\n\n\nThe grammar of graphics framework dissects a graph into individual components, which belong to these seven distinct layers. We take these different layers and combine them together to build a plot.\n\n\nThe three layers at the bottom of this figure - data, aesthetics, and geometries - are required for building any plot.\nLet’s define what they mean:\n\ndata: the dataset containing the variables of interest.\n\naesthetics: things we can see that visually communicate information in our data.\n\ngeometry: the geometric shape used to represent data in a plot: points, lines, bars, etc.\n\n\nYou might be wondering why we wrote data, geom, and aes in a computer code type font. You’ll see very shortly that we use these terms in R code to represent GG layers.\n\n\n\n\n\n\nChallenge\n\n\n\nThe terms and syntax used for ggplot functions, arguments, and layers can be hard to keep up with at first, but as you gain experience using these terms to make plots in R, you will become fluent in no time."
  },
  {
    "objectID": "data_on_display_ls01_gg_intro.html#working-through-the-essential-layers",
    "href": "data_on_display_ls01_gg_intro.html#working-through-the-essential-layers",
    "title": "17  Intro to ggplot2",
    "section": "17.5 Working through the essential layers",
    "text": "17.5 Working through the essential layers\nIn this section, we will work towards a first plot with {ggplot2}. It will be a scatter plot using data from nigerm.\nFor easier plotting in this lesson, we will use a smaller subsets of the nigerm data frame at a time.\nFirst let’s create one called nigerm96, which only contains measles case data for the year 1996. Running the code below will create nigerm96 and add it to your RStudio Environment:\n\n## Create nigerm96 data frame\nnigerm96 &lt;- nigerm %&gt;%   \n  filter(year == 1996)  %&gt;% # filter to only include rows from 1996\n  select(-year) # remove the year column\n\n\n\n\n\n\n\nReminder\n\n\n\nThe select() and filter() functions are part of the {dplyr} package for data manipulation, which is a core package of the {tidyverse}. These topics are covered in the Data Wrangling course. See The GRAPH Courses website for more.\n\n\nLet’s look at our new dataframe, nigerm96:\n\n## Print nigerm96\nnigerm96\n\n\n\n\n\n\n\n17.5.1 Building a ggplot() in steps\nTime to start building a ggplot in increments! We’ll do this by starting with a blank canvas and then adding one layer at a time.\nStep 0: Call the ggplot() function\n\n## Call the `ggplot()` function\nggplot()\n\n\n\n\nAs you can see, this gives us nothing but a blank canvas. But not to worry, we’re about to add some more elements.\nStep 1: Provide data\nThe first input we need to supply the ggplot() function is the data layer (i.e., a data frame), by filling in the data argument (data = DF_NAME):\n\n## Data layer\nggplot(data = nigerm96)  # what data to use\n\n\n\n\nThis gives us blank plot again, since we’ve only supplied one out of the three inputs required for a complete graphic. Next we need to assign variables to aesthetic mappings.\nStep 2: Define the variables\nWhat should we plot on our axes? Let’s say we want to make an epidemic time series plot. To do that, we plot time (in weeks) on the x-axis, and disease incidence (number of reported cases) on the y-axis. In ggplot-speak, we are mapping the variable cases to the x aesthetic, and week to the y aesthetic.\nLet’s tell ggplot() which variables to to plot on the aesthetics layer with a mapping argument, using this syntax: mapping = aes(x = VAR1, y = VAR2).\n\n## Aesthetics layer: x and y position\nggplot(data = nigerm96, # what data to use\n       mapping = aes(   # supply a mapping in the form of an 'aesthetic'\n         x = week,      # which variable to map onto the x-axis\n         y = cases))    # which variable to map onto the y-axis\n\n\n\n\nThere’s still no data plotted, but the axis scales, titles, and labels are present. The x-axis marks weeks of the year from 1 to 52, and the y-axis shows that the number of weekly reported cases per region ranges from 0 to around 2000.\nThe plot is still lacking the required geometry layer.\n\n\n\n\n\n\nKey Point\n\n\n\naes() stands for aesthetics - things we can see. Variables are always inside the aes() function, which in return is inside a ggplot(). Take a moment to observe the double closing brackets )) - the first one belongs to aes(), the second one to ggplot().\n\n\nStep 3: Specify which type of plot to create\nFinally, we add a geometry layer using a geom_* function. This determines which geometric objects - or visual markers - should be used to map the data.\nSince we are looking at the relationship of two numerical variables, it makes sense to use a scatter plot. The geometric objects used to represent data on scatter plots are points, and the geom_* function for scatter plots is conveniently named geom_point(). We’ll add this function as new layer using a + sign:\n\n## Geometries layer: points\nggplot(data = nigerm96, # what data to use\n       mapping = aes(   # define mapping\n         x = week,      # which variable to map onto the x-axis\n         y = cases)) +  # which variable to map onto the y-axis\n  geom_point()          # add a geom of type `point` (for scatter plot)\n\n\n\n\nPoints have been added, and this is now a complete scatter plot! There are 8 points per week, representing each of the 8 regions (but at this point we cannot tell which point is from which region).\n\n\n\n\n\n\nReminder\n\n\n\nThe aesthetic function is nested inside the ggplot() function, so be sure to close the brackets for both functions before adding the + sign for the geom_* function, or your code will not run correctly.\n\n\nIt’s your turn to practice plotting with ggplot()! For practice exercises in this lesson, you will be using a different subset of nigerm called nigerm04, which contains only data from the year 2004:\n\n\n\n\n\n\n\nPlotting with a different set of data will also allow you to explore if the patterns we see for 1996 is also true for 2004.\n\n\n\n\n\n\nPractice\n\n\n\nUsing the nigerm04 data frame, write ggplot code that will create a scatter plot displaying the relationship between cases on the y-axis and week on the x-axis."
  },
  {
    "objectID": "data_on_display_ls01_gg_intro.html#modifying-the-layers",
    "href": "data_on_display_ls01_gg_intro.html#modifying-the-layers",
    "title": "17  Intro to ggplot2",
    "section": "17.6 Modifying the layers",
    "text": "17.6 Modifying the layers\nGenerally speaking, the grammar of graphics allows for a high degree of customization of plots and also a consistent framework for easily updating and modifying them.\nWe can tinker with our existing code to switch up the data, aesthetics, and geometry inputs supplied to ggplot(), and create variations of the original plot. In fact, you’ve already done this by changing the dataset from nigerm96 to nigerm04 in the practice question.\nSimilarly, the aesthetics and geometry inputs can also be changed to create different visualizations. In the next few sections we will take the scatter plot we built in the previous section, and make incremental changes to modify different elements of the original code.\n\n17.6.1 Changing aesthetic mappings\nWe created a scatter plot of cases vs week for nigerm96 with this code:\n\nggplot(data = nigerm96, \n       mapping = aes(x = week, \n                     y = cases)) +\n  geom_point()\n\n\n\n\nIf we copy the same code and change just one thing - by replacing the x variable week (numerical) with region (categorical) - we get what’s called a strip plot:\n\nggplot(data = nigerm96, \n       mapping = aes(x = region, # change which variable to map on the x-axis \n                     y = cases)) +\n  geom_point()\n\n\n\n\nWhile the y-axis values of the points are the same as before, their x-axis mappings have changed significantly. They are now mapped to 8 separate positions along the x-axis, each corresponding to a discrete category of the region variable.\n\n\n17.6.2 Changing geom_* functions\nSimilarly, we can modify the geometry layer to create a different type of plot, while still using the same aesthetic mappings.\n\n\n\n{ggplot2} has a variety of different geom_* functions and geometric objects which you can use to visualize your data. Here are some examples of different types of geoms that can be used with ggplot().\n\n\nLet’s copy and paste the original scatter plot code once again, but this time we will replace the geom_* function instead of the x aesthetic. If we change geom_point() to geom_col(), we get a bar plot (sometimes called a column chart):\n\nggplot(data = nigerm96, \n       mapping = aes(x = week,\n                     y = cases)) +  \n  geom_col()  # declare that we want a bar plot\n\n\n\n\nAgain, the rest of the code is still the same - we just changed the key word of the geom_* function. However, the plot is significantly different that either the scatter plot or the strip plot.\nNotice that the y-axis has been rescaled. The height of each bar represents the cumulative number of weekly cases, i.e, the total number of cases reported from all eight regions that week, rather than showing 8 separate data points for each region.\n\n\n\n\n\n\nCaution\n\n\n\nNot all plot types are interchangeable. Using a geom_* function that is not compatible with the variables you defined in aes() will give you an error. For example, let’s replace geom_point() with geom_histogram() instead:\n\nggplot(data = nigerm96, \n       mapping = aes(x = week, \n                     y = cases)) +\n  geom_histogram()\n\nThis is because a histogram shows the distribution of one numerical variable. ggplot() can’t map two variables to both the x and y-axis positions with a histogram, so it throws an error.\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUse the nigerm04 data frame to create a bar plot of weekly cases with the geom_col() function. Map cases on the y-axis and week on the x-axis.\n\n\n\n\n17.6.3 Additional aesthetic mappings inside aes()\nSo far, we have only mapped variables to the x and y aesthetic attributes. We can also map variables to other aesthetics like color, size, or shape.\n\n\n\nCommon aesthetic attributes used in ggplot graphics.\n\n\nLet’s return to our original scatter plot (cases vs week):\n\nggplot(data = nigerm96, \n       mapping = aes(x = week, \n                     y = cases)) +\n  geom_point()\n\n\n\n\nThere are other aesthetics we can add, like color or size.\n\n\n\n\n\n\n\nPro Tip\n\n\n\nTo see the full list of aesthetics that can be used with a particular geom_* function look it up the function documentation. You can do this by pressing F1 on a function, e.g., geom_point() to open the Help tab, and scroll down to the “Aesthetics” section. If F1 is hard to summon on your keyboard, type and run ?geom_point in your Console tab.\n\n\nLet’s add color to our scatter plot. We can map the categorical variable region to the color aesthetic. We can do this by modifying the original code to add a new argument inside mapping = aes(). Let’s see what happens when we add color = region inside aes():\n\nggplot(data = nigerm96,      \n       mapping = aes(x = week,  \n                     y = cases,   \n                     color = region)) +  # use a different color for each region\n  geom_point()               \n\n\n\n\nNow we have a colorful scatter plot! Each point is colored according to the region it belongs to. This allows us to better distinguish between regions.\nNote that ggplot() automatically provides a color legend on the left.\n\n\n\n\n\n\nSide Note\n\n\n\nThe colors are from {ggplot2}’s default rainbow color palette. In later lessons we will learn how to customize color scales and palettes, including making figures colorblind-friendly.\n\n\nBy examining the color patterns in the plot, you can make out the classic bell-shaped epidemic curves showing a rise and fall in measles incidence in each region.\nZinder had the largest number of cases and the steepest epidemic curve, followed by Maradi and Niamey.\nWhile the colorful plot provides more insight into measles patterns at the regional level than the scatter plot with no color mapping, this graph still looks busy and is not the most intuitive to read. A different plot type could help with this.\nNext we will try a bar plot, then a line graph.\nLet’s try the same color = region aesthetic mapping with geom_col() instead:\n\nggplot(data = nigerm96, \n       mapping = aes(x = week, \n                     y = cases, \n                     color = region)) +  # use a different outline color for each region\n  geom_col()\n\n\n\n\nThis gives us a stacked bar plot, where the bars are divided into smaller sections. This shows us the proportional contribution of individual regions (i.e., the height or length of each subsection represents how much each region contributes to the total number of cases that week).\nThe stacked bar plot here is outlined by color. This is because the color aesthetic in {ggplot2} generally refers to the border around a shape. This did not apply to the default shapes in our scatter plot created with geom_point() because they are solid dots (not hollow), but you can see that it does apply to the bars in a bar chart created geom_col(). However, the grey filling is not very pretty.\nWe might want to color the inside of the bars instead. This is done by mapping our variable to the fill aesthetic. We can copy the code above and simply change color to fill inside aes():\n\nggplot(data = nigerm96, \n       mapping = aes(x = week, \n                     y = cases, \n                     fill = region)) +  # use a different fill color for each region\n  geom_col()\n\n\n\n\nVoila! The inside of the bars are now filled with colors.\nNow practice using the color aesthetic mapping with a new plot type: line graphs. Line graphs are generally considered one of the best plot types for time series data.\n\n\n\n\n\n\nPractice\n\n\n\nUse the nigerm04 data frame to create a line graph of weekly cases, colored by region. Map cases on the y-axis, week on the x-axis, and region to color. The geom_* function for a line graph is called geom_line().\n\n\n\n\n17.6.4 Fixed aesthetics outside aes()\nIt is very important to understand the difference between aesthetic mappings and fixed aesthetics. The main aesthetics in ggplot are: x, y, color, fill, and size, and any of these could be either a mapping or a fixed value. This depends on whether they appear inside or outside the aes() function.\nWhen we apply an aesthetic to modify the geometric objects according to a variable (e.g., the color of points changes according to the region variable), that’s an aesthetic mapping. This must always be defined inside mapping = aes(), like we just did in previous examples.\nBut if you want to apply a visual modification to all the geometric objects evenly (e.g., manually change the color of all points to be one color), that’s a fixed aesthetic. We must set fixed aesthetics to a constant value outside mapping = aes() and directly inside the geom_* function - e.g., geom_point(color = \"COLOR_NAME\").\nHere let’s change the color of all the points in our scatter plot to blue:\n\nggplot(data = nigerm96, \n       mapping = aes(x = week, \n                     y = cases)) +\n  geom_point(color = \"blue\")        # use the same color for all points\n\n\n\n\nThis colors each point with the same R color (“blue”). In this plot, the color aesthetic does not represent any values from the data frame. Note that the color names in R are character strings, so it needs to go inside quotation marks.\n\n\n\n\n\n\nSide Note\n\n\n\nIf you’re curious, run colors() in your console to see all possible choice of colors in R! To find out exactly how many options that is, try running colors() %&gt;% length().\n\n\nNow let’s add a fixed aesthetic called size. The default line width used by geom_line() is 0.5 mm, which looks like this:\n\nggplot(data = nigerm96, \n             mapping = aes(x = week, \n                           y = cases,\n                           color = region)) + \n      geom_line()\n\n\n\n\nTo make all of the lines in our figure a little thicker, let’s fix this aesthetic at 1 mm. We do this by adding size = 1 inside the geom_line() function:\n\nggplot(data = nigerm96, \n             mapping = aes(x = week, \n                           y = cases,\n                           color = region)) + \n      geom_line(size = 1)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\nAll the lines in the plot have been made thicker, and the line width is set to a constant value of 1 mm. Note that here the value of size is numeric, so it should not be in quotation marks.\n\n\n\n\n\n\nWatch Out\n\n\n\nRemember that fixed aesthetics are manually set to constant value (as opposed to a variable from the data), and goes directly in the geom_* function, not inside aes(). If you try to put a fixed aesthetic in aes(), you might get a weird result. For example, let’s try moving the size = 1 aesthetic from geom_line() to aes() to see how it can go wrong:\n\nggplot(data = nigerm96, \n             mapping = aes(x = week, \n                           y = cases,\n                           color = region,\n                           size = 1)) +     # INCORRECT placement\n      geom_line()\n\n\n\n\naes() is a mapping function that modifies plots based on variables from the data. Since there is no variable called “1” in the nigerm96 data frame, aes() cannot process or map this aesthetic correctly.\n\n\nPractice using fill as a fixed aesthetic for a bar plot.\n\n\n\n\n\n\nPractice\n\n\n\nUse the nigerm04 data frame to create a bar graph of weekly cases, and fill all bars with the same color. Map cases on the y-axis, week on the x-axis, and fix the color aesthetic of the bars to the R color “hotpink”."
  },
  {
    "objectID": "data_on_display_ls01_gg_intro.html#additional-gg-layers",
    "href": "data_on_display_ls01_gg_intro.html#additional-gg-layers",
    "title": "17  Intro to ggplot2",
    "section": "17.7 Additional GG layers",
    "text": "17.7 Additional GG layers\nIn this lesson, we kept things simple and only worked with the three required layers. As you start to delve deeper into plotting with {ggplot2}, you’ll start to encounter the other layers more frequently.\nSoon you’ll be able to create more complex plots, like this one:\n\n\n\n\n\n\n\n\n\n\n\nRecap\n\n\n\nTo build a complete ggplot, you must first supply a data frame using the data argument of ggplot(), and define variables and map them to aesthetics inside aes() using the mapping argument of ggplot(). Then start a new layer with a + sign and specify the type of plot you want using an appropriate geom_* function. You can copy this code template and adapt it to create different ggplot graphics:\n\nggplot(data = DF_NAME,\n       mapping = aes(AES1 = VAR1,\n                     AES2 = VAR2, \n                     AES3 = VAR3, \n                     ...)) +\n  geom_FUCNTION()"
  },
  {
    "objectID": "data_on_display_ls01_gg_intro.html#learning-outcomes",
    "href": "data_on_display_ls01_gg_intro.html#learning-outcomes",
    "title": "17  Intro to ggplot2",
    "section": "17.8 Learning outcomes",
    "text": "17.8 Learning outcomes\n\nYou can recall and explain how the {ggplot2} package for data visualization is based on a theoretical framework called the grammar of graphics.\nYou can name and describe the 3 essential layers for building a graph: data, aesthetics, and geometries.\nYou can write code to build a complete ggplot graphic by correctly supplying the 3 essential layers to the ggplot() function.\nYou can create different types of plots such as scatter plots, line graphs, and bar graphs.\nYou can add or modify aesthetics of a plot such as the color, and size."
  },
  {
    "objectID": "data_on_display_ls01_gg_intro.html#references",
    "href": "data_on_display_ls01_gg_intro.html#references",
    "title": "17  Intro to ggplot2",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nBlake, Alexandre, Ali Djibo, Ousmane Guindo, and Nita Bharti. 2020. “Investigating Persistent Measles Dynamics in Niger and Associations with Rainfall.” Journal of The Royal Society Interface 17 (169): 20200480. https://doi.org/10.1098/rsif.2020.0480.\nCmprince. Administrative divisions of Niger: Departments and Regions. 29 October 2017. Wikimedia Commons. Accessed October 14, 2022. https://commons.wikimedia.org/wiki/File:Niger_administrative_divisions.svg\nDeBruine, Lisa, and Dale Barr. 2022. Chapter 3 Data Visualisation | Data Skills for Reproducible Research. https://psyteachr.github.io/reprores-v3/ggplot.html.\nFranke, Michael. n.d. 6 Data Visualization | An Introduction to Data Analysis. Accessed October 12, 2022. https://michael-franke.github.io/intro-data-analysis/Chap-02-02-visualization.html.\nGeography Now, dir. 2019. Geography Now! NIGER. https://www.youtube.com/watch?v=AHeq99pojLo.\nGiroux-Bougard, Xavier, Maxwell Farrell, Amanda Winegardner, Étienne Low-Decarie and Monica Granados. 2020. Workshop 3: Introduction to Data Visualisation with Ggplot2. http://r.qcbs.ca/workshop03/book-en/.\nIsmay, Chester, and Albert Y. Kim. 2022. A ModernDive into R and the Tidyverse. https://moderndive.com/.\nKabacoff, Rob. 2020. Data Visualization with R. https://rkabacoff.github.io/datavis/.\nLisa DeBruine. 2020. Basic Plots. https://www.youtube.com/watch?v=tOFQFPRgZ3M.\nPius, Ewen Harrison and Riinu. n.d. R for Health Data Science. Accessed October 11, 2022. https://argoshare.is.ed.ac.uk/healthyr_book/.\nPrabhakaran, Selva. 2016. “How to Make Any Plot in Ggplot2? | Ggplot2 Tutorial.” 2016. http://r-statistics.co/ggplot2-Tutorial-With-R.html."
  },
  {
    "objectID": "data_on_display_ls01_gg_intro.html#solutions",
    "href": "data_on_display_ls01_gg_intro.html#solutions",
    "title": "17  Intro to ggplot2",
    "section": "17.9 Solutions",
    "text": "17.9 Solutions\n\n.SOLUTION_nigerm04_scatter()\n\nggplot(data = nigerm04,\n             mapping = aes(x = week, \n                           y = cases)) +\n      geom_point()\n\n.SOLUTION_nigerm04_bar()\n\nggplot(data = nigerm04, \n          mapping = aes(x = week, \n                        y = cases)) + \n     geom_col()\n\n.SOLUTION_nigerm04_line()\n\nggplot(data = nigerm04,\n         mapping = aes(x = week,\n                       y = cases,\n                       color = region)) + \n    geom_line()\n\n.SOLUTION_nigerm04_pinkbar()\n\nggplot(data = nigerm04, \n          mapping = aes(x = week, \n                        y = cases)) +\n      geom_col(fill = \"hotpink\")\n\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  },
  {
    "objectID": "data_on_display_ls02_scatter.html#introduction",
    "href": "data_on_display_ls02_scatter.html#introduction",
    "title": "18  Scatter plots and smoothing lines",
    "section": "18.1 Introduction",
    "text": "18.1 Introduction\nScatter plots - which are sometimes called bivariate plots - allow you to visualize the relationship between two numerical variables.\nThey are among the most commonly used plots because they can provide an immediate way to see how one numerical variable varies against another.\nScatter plots can also display multiple relationships by mapping additional variable to aesthetic properties, such as color of the points.\nTrends and relationships in a scatter plot can be made clearer by adding a smoothing line over the points.\nWe will use ggplot to do all that and more. Let’s get started!"
  },
  {
    "objectID": "data_on_display_ls02_scatter.html#learning-objectives",
    "href": "data_on_display_ls02_scatter.html#learning-objectives",
    "title": "18  Scatter plots and smoothing lines",
    "section": "18.2 Learning Objectives",
    "text": "18.2 Learning Objectives\n\nYou can visualize relationships between numerical variables using scatter plots with geom_point().\nYou can use color as an aesthetic argument to map variables from the dataset onto individual points.\nYou can change the size, shape, color, fill, and opacity of geometric objects by setting fixed aesthetics.\nYou can add a trend line to a scatter plot with geom_smooth()."
  },
  {
    "objectID": "data_on_display_ls02_scatter.html#childhood-diarrheal-diseases-in-mali",
    "href": "data_on_display_ls02_scatter.html#childhood-diarrheal-diseases-in-mali",
    "title": "18  Scatter plots and smoothing lines",
    "section": "18.3 Childhood diarrheal diseases in Mali",
    "text": "18.3 Childhood diarrheal diseases in Mali\nWe will be using data collected for a prospective observational study of acute diarrhea in children aged 0-59 months. The study was conducted in Mali and in early 2020.\nThe full dataset can be obtained from Dryad, and the paper can be viewed here.\n\n\n\n\n\n\nVocab\n\n\n\nA prospective study watches for outcomes, such as the development of a disease, during the study period and relates this to other factors such as suspected risk or protection factors.\n\n\nSpend some time browsing through this dataset. Each row corresponds to one patient surveyed. There are demographic, physiological, clinical, socioeconomic, and geographic variables.\n\n\n\n\n\n\n\nWe will begin by visualizing the relationship between the following two numerical variables:\n\nage_months: the patient’s age in months on the horizontal x-axis and\nviral_load: the patient’s viral load on the vertical y-axis"
  },
  {
    "objectID": "data_on_display_ls02_scatter.html#scatter-plots-via-geom_point",
    "href": "data_on_display_ls02_scatter.html#scatter-plots-via-geom_point",
    "title": "18  Scatter plots and smoothing lines",
    "section": "18.4 Scatter plots via geom_point()",
    "text": "18.4 Scatter plots via geom_point()\nWe will explore relationships between some numerical variables in the malidd data frame.\nWe will now examine at and run the code that will create the desired scatter plot, while keeping in mind the GG framework. Let’s take a look at the code and break it down piece-by-piece.\nRemember that we specify the first two GG layers as arguments (i.e., inputs) within the ggplot() function:\n\nWe provide the malidd data frame with the data argument, by inputting data = malidd.\nWe define the variables to be plotted in the aesthetics function of the mapping argument, by inputting mapping = aes(x = age_months, y = viral_load). Specifically, the variable age_months is mapped to the x aesthetic, while the variable viral_load is mapped to the y aesthetic.\n\nWe then add the geom_*() function on a new layer with a + sign. The geometric objects (i.e., shapes) needed for a scatter plot are points, so we add geom_point().\nAfter running the following lines of code, you’ll produce the scatter plot below:\n\n## Simple scatter plot of viral load vs age\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point()\n\n\n\n\nThis suggests that viral load generally decreases with age.\n\n\n\n\n\n\nPractice\n\n\n\n\nUsing the malidd data frame, create a scatter plot showing the relationship between age and height (height_cm)."
  },
  {
    "objectID": "data_on_display_ls02_scatter.html#aesthetic-modifications",
    "href": "data_on_display_ls02_scatter.html#aesthetic-modifications",
    "title": "18  Scatter plots and smoothing lines",
    "section": "18.5 Aesthetic modifications",
    "text": "18.5 Aesthetic modifications\nAn aesthetic is a visual property of the geometric objects (geoms) in your plot. Aesthetics include things like the size, the shape, or the color of your points. You can display a point in different ways by changing the values of its aesthetic properties.\nRemember, there are two methods for changing the aesthetic properties of your geoms (in this case, points).\n\nYou can convey information about your data by mapping the variables in your dataset to aesthetics in your plot. For this method, you use aes() in the mapping argument to associate the name of the aesthetic with a variable to display.\nYou can also set the aesthetic properties of your geoms manually. Here the aesthetic doesn’t convey information about a variable, but only changes the appearance of the plot. To change an aesthetic manually, you set the aesthetic by name as an argument of your geom_*() function; i.e. it goes outside of aes().\n\n\n18.5.1 Mapping data to aesthetics\nIn addition to mapping variables to the x and y axes like with did above, variables can be mapped to the color, shape, size, opacity, and other visual characteristics of geoms. This allows groups of observations to be superimposed in a single graph.\nTo map a variable to an aesthetic, associate the name of the aesthetic to the name of the variable inside aes(). This way, we can visualize a third variable to our simple two dimensional scatter plot by mapping it to a new aesthetic.\nFor example, let’s map height_cm to the colors of our points, to show us how height varies with age and viral load:\n\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point(mapping = aes(color = height_cm))\n\n\n\n\nWe see that {ggplot2} has automatically assigned the values of our variable to an aesthetic, a process known as scaling. {ggplot2} will also add a legend that explains which levels correspond to which values.\nHere the points are colored by different shades of the same blue hue, with darker colors representing lower values.\nThis shows us that height increases with age, as expected.\nInstead of a continuous variable like height_cm, we can also map a binary variable like breastfeeding, to show us the which children are breastfed and which ones are not:\n\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point(mapping = aes(color = breastfeeding))\n\n\n\n\nWe get the same gradual color scaling like with did with height. This communicates a continuum of values, rather than the two distinct values in our variable - 0 or 1.\nThis is because of the data class of the breastfeeding variable in malidd:\n\nclass(malidd$breastfeeding)\n\n[1] \"numeric\"\n\n\nBut even though binary variables are numerical, they represent two discrete possibilities. So the continuous color scaling in the plot above is not ideal.\nIn cases like this, we add the function factor() around the breastfeeding variable to tell ggplot() to treat the variable as a factor. Let’s see what happens when we do that:\n\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point(mapping = aes(color = factor(breastfeeding)))\n\n\n\n\nWhen the variable is treated like a factor, the colors chosen are clearly distinguishable. With factors, {ggplot2} will automatically assign a unique level of the aesthetic (here a unique color) to each unique value of the variable. (this is what happened with the region variable of the nigerm dataframe that we use in the last lesson)\nThis plot reveals a clear relationship between age and breastfeeding, as we might expect. Children are likely to stop breastfeeding around 20 months of age. In this study, no child at or above 25 months was being breastfed.\nAdding colors to the scatter plot allowed us to visualize a third variable in addition to the relationship between age and viral load. The third variable could be either discrete or continuous.\n\n\n\n\n\n\nPractice\n\n\n\n\nUsing the malidd data frame, create a scatter plot showing the relationship between age and viral load, and map a third variable, freqrespi, to color:\nCreate the same age vs. height scatterplot again, but this time, map the binary variable fever to the color of the points. Keep in mind that fever should be treated as a factor.\n\n\n## Type and view your answer:\nage_height_fever &lt;-  \"YOUR ANSWER HERE\"\nage_height_fever\n\n\n\n\n\n18.5.2 Setting fixed aesthetics\nAesthetic arguments set to a fixed value will be static, and the visual effect is not data-dependent. To add a fixed aesthetic, we add as a direct argument of the geom_*() function; i.e., it goes outside of mapping = aes().\nLet’s look at some of the aesthetic arguments we can place directly within geom_point() to make visual changes to the points in our scatter plot:\n\ncolor - point color or point outline color\nsize - point size\nalpha - point opacity\nshape - point shape\nfill - point fill color (only applies if the point has an outline)\n\nTo use these options to create a more attractive scatter plot, you’ll need to pick a value for each argument that makes sense for that aesthetic, as shown in the examples below.\n\n18.5.2.1 Changing color, size and alpha\nLet’s change the color of the points to a fixed value by setting the color argument directly within geom_point(). The color we choose must be a character string that R recognizes as a color. Here we will set the point colors to steel blue:\n\n##  Modify original scatter plot by setting `color = \"steelblue\"`\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point(color = \"steelblue\")       # set color\n\n\n\n\nIn addition to changing the default color, now we will modify the size aesthetic of the points by assigning it to a fixed number (in millimeters). The default size is 1 mm, so let’s chose a larger value:\n\n##  Set size to 2 mm by ading `size = 2`\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point(color = \"steelblue\",       # set color\n             size = 2)                  # set size (mm)\n\n\n\n\nThe alpha aesthetic controls the level of opacity of geoms. alpha is also numerical, and ranges from 0 (completely transparent) to the default of 1 (completely opaque). Let’s make our points more transparent by reducing the opacity:\n\n##  Set opacity to 75% by adding `alpha = 0.75`\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point(color = \"steelblue\",       # set color\n             size = 2,                  # set size (mm)\n             alpha = 0.75)              # set level of opacity\n\n\n\n\nNow we can see where multiple points overlap. This is a useful parameter for scatter plots where there is overplotting.\nRemember, changing the color, size, or opacity of our points here is not conveying any information in the data - they are design choices we make to create prettier plots.\n\n\n\n\n\n\nPractice\n\n\n\n\nCreate a scatter plot with the same variables as the previous example, but change the color of the points to cornflowerblue, increase the size of points to 3 mm and set the opacity to 60%.\n\n\n\n\n\n18.5.2.2 Changing shape and fill\nWe can change the appearance of points in a scatter plot with the shape aesthetic.\nTo change the shape of your geoms to a fixed value, set shape equal to a number corresponding to your desired shape.\n{ggplot2} will accept the following numbers:\n Notice that some of the shapes are filled in with red. This indicates that objects 21-24 are sensitive to both color and fill, but the others are only sensitive to color.\nFirst let’s modify our original scatterplot by changing the shapes to a something that can be filled in:\n\n## Set shape to fillable circles by adding `shape = 21`\n\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point(shape = 21)                # set shapes to display\n\n\n\n\nFillable shapes can have different colors for the outline and interior. Changing the color aesthetic will only change the outline of our points:\n\n## Set outline color of the shapes by adding `color = cyan4`\n\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point(shape = 21,                # set shapes to display\n             color = \"cyan4\")           # set outline color\n\n\n\n\nNow let’s fill in the points:\n\n## Set interior color of the shapes by adding `fill = \"seagreen\"` \n\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point(shape = 21,                # set shapes to display\n             color = \"cyan4\",           # set outline color\n             fill = \"seagreen\")         # set fill color\n\n\n\n\nWe can improve the readability by increasing size and reducing opcaity with size and alpha, like we did before:\n\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point(shape = 21,                # set shapes to display\n             color = \"cyan4\",           # set outline color\n             fill = \"seagreen\",         # set fill color\n             size = 2,                  # set size (mm)\n             alpha = 0.75)              # set level of opacity"
  },
  {
    "objectID": "data_on_display_ls02_scatter.html#adding-a-trend-line",
    "href": "data_on_display_ls02_scatter.html#adding-a-trend-line",
    "title": "18  Scatter plots and smoothing lines",
    "section": "18.6 Adding a trend line",
    "text": "18.6 Adding a trend line\nIt can be hard to view relationships or trends with just points alone. Often we want to add a smoothing line in order to see what the trends look like. This can be especially helpful when trying to understand regressions.\nTo get a better idea of the relationship between these to variables, we can add a trend line (also known as a best fit line or a smoothing line).\nTo do this, we add the function geom_smooth() to our scatter plot:\n\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point() +\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nThe smoothing line comes after our points an another geometric layer added onto our plot.\nThe default smoothing function used in this scatter plot is “loess” which stands for for locally weighted scatter plot smoothing. Loess smoothing is a process used by many statistical softwares. In {ggplot2} this generally should be done when you have less than 1000 points, otherwise it can be time consuming.\nMany other smoothing functions can also be used in geom_smooth().\nLet’s request a linear regression method. This time we will use a generalized linear model by setting the method argument inside geom_smooth():\n\n## Change to a linear smoothing function with `method = \"glm\"`\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point() +\n  geom_smooth(method = \"glm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nBy default, 95% confidence limits for these lines are displayed.\nYou can suppress the confidence bands by including the argument se = FALSE inside geom_smooth():\n\n## Remove confidence interval bands by adding `se = FALSE`\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point() +\n  geom_smooth(method = \"glm\",\n              se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nIn addition to changing the method, let’s add the color argument inside geom_smooth() to change the color of the line.\n\n## Change the color of the trend line by adding `color = \"darkred\"`\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point() +\n  geom_smooth(method = \"glm\",\n              se = FALSE,\n              color = \"darkred\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nThis linear regression concurs with what we initially observed in the first scatter plot. A negative relationship exists between age_months and viral_load: as age increases, viral load tends to decrease.\nLet’s add a third variable from the malidd dataset calledvomit. This which is a binary variable that records whether or not the patient vomited. We will add the vomit variable to the plot by mapping it to the color aesthetic. We will again change the smoothing method to generalized additive model (“gam”) and make some aesthetic modifications to the line in the geom_smooth() layer.\n\nggplot(data = malidd, \n       mapping = aes(x = age_months, \n                     y = viral_load)) + \n  geom_point(mapping = aes(color = factor(vomit))) +\n  geom_smooth(method = \"gam\", \n              size = 1.5,\n              color = \"darkgray\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\nObserve the distribution of blue points (children who vomited) compared to red points (children who did not vomit). The blue points mostly occur above the trend line. This shows that higher viral loads were not only associated with younger children, but that children with higher viral loads were more likely to exhibit symptoms of vomiting.\n\n\n\n\n\n\nPractice\n\n\n\n\nCreate a scatter plot with the age_months and height_cm variables. Set the color of the points to “steelblue”, the size to 2.5mm, the opacity to 80%. Then add trend line with the smoothing method “lm” (linear model). To make the trend line stand out, set its color to “indianred3”.\nRecreate the plot you made in the previous question, but this time adapt the code to change the shape of the points to tilted rectangles (number 23), and add the body temperature variable (temp) by mapping it to fill color of the points.\n\n\n## Type and view your answer:\nage_height_3 &lt;-  \"YOUR ANSWER HERE\"\nage_height_3"
  },
  {
    "objectID": "data_on_display_ls02_scatter.html#summary",
    "href": "data_on_display_ls02_scatter.html#summary",
    "title": "18  Scatter plots and smoothing lines",
    "section": "18.7 Summary",
    "text": "18.7 Summary\nScatter plots display the relationship between two numerical variables.\nWith medium to large datasets, you may need to play around with the different modifications to scatter plots we saw such as adding trend lines, changing the color, size, shape, fill, or opacity of the points. This tweaking is often a fun part of data visualization, since you’ll have the chance to see different relationships emerge as you tinker with your plots."
  },
  {
    "objectID": "data_on_display_ls02_scatter.html#references",
    "href": "data_on_display_ls02_scatter.html#references",
    "title": "18  Scatter plots and smoothing lines",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nIsmay, Chester, and Albert Y. Kim. 2022. A ModernDive into R and the Tidyverse. https://moderndive.com/.\nKabacoff, Rob. 2020. Data Visualization with R. https://rkabacoff.github.io/datavis/.\nGiroux-Bougard, Xavier, Maxwell Farrell, Amanda Winegardner, Étienne Low-Decarie and Monica Granados. 2020. Workshop 3: Introduction to Data Visualisation with {ggplot2}. http://r.qcbs.ca/workshop03/book-en/."
  },
  {
    "objectID": "data_on_display_ls02_scatter.html#solutions",
    "href": "data_on_display_ls02_scatter.html#solutions",
    "title": "18  Scatter plots and smoothing lines",
    "section": "18.8 Solutions",
    "text": "18.8 Solutions\n\n.SOLUTION_age_height()\n\nggplot(data = malidd,\n             mapping = aes(x = age_months, \n                           y = height_cm)) +\n      geom_point()\n\n.SOLUTION_age_height_respi()\n\nggplot(data = malidd, \n             mapping = aes(x = age_months, \n                           y = viral_load)) + \n      geom_point(mapping = aes(color = freqrespi))\n\n.SOLUTION_age_viral_respi() \n\nggplot(data = malidd, \n             mapping = aes(x = age_months, \n                           y = viral_load)) + \n      geom_point(mapping = aes(color = freqrespi))\n\n.SOLUTION_age_height_fever()\n\nggplot(data = malidd, \n             mapping = aes(x = age_months, \n                           y = height_cm)) + \n      geom_point(mapping = aes(color = factor(fever)))\n\n.SOLUTION_age_viral_blue()\n\nggplot(data = malidd, \n             mapping = aes(x = age_months, \n                           y = viral_load)) + \n      geom_point(color = \"cornflowerblue\",\n                 size = 3,\n                 alpha = 0.6)\n\n.SOLUTION_age_height_2()\n\nggplot(data = malidd, \n          mapping = aes(x = age_months, \n                        y = height_cm)) + \n      geom_point(color = \"steelblue\",\n                 size = 2.5,\n                 alpha = 0.8) +\n      geom_smooth(method = \"lm\", color = \"indianred3\")\n\n.SOLUTION_age_height_3()\n\nggplot(data = malidd, \n          mapping = aes(x = age_months, y = height_cm)) + \n      geom_point(color = \"steelblue\",\n                 size = 2.5,\n                 alpha = 0.8,\n                 shape = 23,\n                 mapping = aes(fill = temp)) +\n      geom_smooth(method = \"lm\", color = \"indianred3\")\n\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#learning-objectives",
    "href": "data_on_display_ls03_line_graphs.html#learning-objectives",
    "title": "19  Lines, scales, and labels",
    "section": "19.1 Learning Objectives",
    "text": "19.1 Learning Objectives\n\nYou can create line graphs to visualize relationships between two numerical variables with geom_line().\nYou can add points to a line graph with geom_point().\nYou can use aesthetics like color, size, color, and linetype to modify line graphs.\nYou can manipulate axis scales for continuous data with scale_*_continuous() and scale_*_log10().\nYou can add labels to a plot such as a title, subtitle, or caption with the labs() function."
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#introduction",
    "href": "data_on_display_ls03_line_graphs.html#introduction",
    "title": "19  Lines, scales, and labels",
    "section": "19.2 Introduction",
    "text": "19.2 Introduction\nLine graphs are used to show relationships between two numerical variables, just like scatterplots. They are especially useful when the variable on the x-axis, also called the explanatory variable, is of a sequential nature. In other words, there is an inherent ordering to the variable.\nThe most common examples of line graphs have some notion of time on the x-axis: hours, days, weeks, years, etc. Since time is sequential, we connect consecutive observations of the variable on the y-axis with a line. Line graphs that have some notion of time on the x-axis are also called time series plots."
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#packages",
    "href": "data_on_display_ls03_line_graphs.html#packages",
    "title": "19  Lines, scales, and labels",
    "section": "19.3 Packages",
    "text": "19.3 Packages\n\n## Load packages\npacman::p_load(tidyverse, \n               gapminder, \n               here)"
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#the-gapminder-data-frame",
    "href": "data_on_display_ls03_line_graphs.html#the-gapminder-data-frame",
    "title": "19  Lines, scales, and labels",
    "section": "19.4 The gapminder data frame",
    "text": "19.4 The gapminder data frame\nIn February 2006, a Swedish physician and data advocate named Hans Rosling gave a famous TED talk titled “The best stats you’ve ever seen” where he presented global economic, health, and development data complied by the Gapminder Foundation.\n\n\n\nInteractive data visualization tools with up-to-date data are available on the Gapminder’s website.\n\n\nWe can access a clean subset of this data with the R package {gapminder}, which we just loaded.\n\n## Load gapminder data frame from the gapminder package\ndata(gapminder, package=\"gapminder\")\n\n## Print dataframe\ngapminder\n\n# A tibble: 10 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n\n\nEach row in this table corresponds to a country-year combination. For each row, we have 6 columns:\n\ncountry: Country name\ncontinent: Geographic region of the world\nyear: Calendar year\nlifeExp: Average number of years a newborn child would live if current mortality patterns were to stay the same\npop: Total population\ngdpPercap: Gross domestic product per person (inflation-adjusted US dollars)\n\nThe str() function can tell us more about these variables.\n\n## Data structure\nstr(gapminder)\n\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n\n\nThis version of the gapminder dataset contains information for 142 countries, divided in to 5 continents.\n\n\n## Data summary\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Asia    :396   Median :1980   Median :60.71  \n Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.47  \n Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\n\nData are recorded every 5 years from 1952 to 2007 (a total of 12 years).\nLet’s say we want to visualize the relationship between time (year) and life expectancy (lifeExp).\nFor now let’s just focus on one country - United States. First, we need to create a new data frame with only the data from this country.\n\n## Select US cases\ngap_US &lt;- dplyr::filter(gapminder,\n                        country == \"United States\")\n\ngap_US\n\n# A tibble: 10 × 6\n   country       continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 United States Americas   1952    68.4 157553000    13990.\n 2 United States Americas   1957    69.5 171984000    14847.\n 3 United States Americas   1962    70.2 186538000    16173.\n 4 United States Americas   1967    70.8 198712000    19530.\n 5 United States Americas   1972    71.3 209896000    21806.\n 6 United States Americas   1977    73.4 220239000    24073.\n 7 United States Americas   1982    74.6 232187835    25010.\n 8 United States Americas   1987    75.0 242803533    29884.\n 9 United States Americas   1992    76.1 256894189    32004.\n10 United States Americas   1997    76.8 272911760    35767.\n\n\n\n\n\n\n\n\nReminder\n\n\n\nThe code above is a covered in our course on Data Wrangling using the {dplyr} package. Data wrangling is the process of transforming and modifying existing data with the intent of making it more appropriate for analysis purposes. For example, this code segments used the filter() function to create a new data frame (gap_US) by choosing only a subset of rows of original gapminder data frame (only those that have “United States” in the country column)."
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#line-graphs-via-geom_line",
    "href": "data_on_display_ls03_line_graphs.html#line-graphs-via-geom_line",
    "title": "19  Lines, scales, and labels",
    "section": "19.5 Line graphs via geom_line()",
    "text": "19.5 Line graphs via geom_line()\nNow we’re ready to feed the gap_US data frame to ggplot(), mapping time in years on the horizontal x axis and life expectancy on the vertical y axis.\nWe can visualize this time series data by using geom_line() to create a line graph, instead of using geom_point() like we used previously to create scatterplots:\n\n## Simple line graph\nggplot(data = gap_US, \n       mapping = aes(x = year, \n                     y = lifeExp)) +\n  geom_line() \n\n\n\n\nMuch as with the ggplot() code that created the scatterplot of age and viral load with geom_point(), let’s break down this code piece-by-piece in terms of the grammar of graphics:\nWithin the ggplot() function call, we specify two of the components of the grammar of graphics as arguments:\n\nThe data to be the gap_US data frame by setting data = gap_US.\nThe aesthetic mapping by setting mapping = aes(x = year, y = lifeExp). Specifically, the variable year maps to the x position aesthetic, while the variable lifeExp maps to the y position aesthetic.\n\nAfter telling R which data and aesthetic mappings we wanted to plot we then added the third essential component, the geometric object using the + sign, In this case, the geometric object was set to lines using geom_line().\n\n\n\n\n\n\nPractice\n\n\n\nCreate a time series plot of the GPD per capita (gdpPercap) recorded in the gap_US data frame by using geom_line() to create a line graph.\n\n\n\n19.5.1 Fixed aesthetics in geom_line()\nThe color, line width and line type of the line graph can be customized making use of color, size and linetype arguments, respectively.\nWe’ve changed the color and size of geoms in previous lessons.\nHere we will add these as fixed aesthetics:\n\n## enhanced line graph with color and size as fixed aesthetics\nggplot(data = gap_US, \n       mapping = aes(x = year, \n                     y = lifeExp)) +\n  geom_line(color = \"thistle\",\n            size = 1.5) \n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\nIn this lesson we introduce a new fixed aesthetic that is specific to line graphs: linetype (or lty for short).\n\nLine type can be specified using a name or with an integer. Valid line types can be set using a human readable character string: \"blank\", \"solid\", \"dashed\", \"dotted\", \"dotdash\", \"longdash\", and \"twodash\" are all understood by linetype or lty.\n\n## Enhanced line graph with color, size, and line type as fixed aesthetics\nggplot(data = gap_US, \n       mapping = aes(x = year, \n                     y = lifeExp)) +\n  geom_line(color = \"thistle3\",\n            size = 1.5,\n            linetype = \"twodash\") \n\n\n\n\nIn these line graphs, it can be hard to tell where exactly there data points are. In the next plot, we’ll add points to make this clearer."
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#combining-compatible-geoms",
    "href": "data_on_display_ls03_line_graphs.html#combining-compatible-geoms",
    "title": "19  Lines, scales, and labels",
    "section": "19.6 Combining compatible geoms",
    "text": "19.6 Combining compatible geoms\nAs long as the geoms are compatible, we can layer them on top of one another to further customize a graph.\nFor example, we can add points to our line graph using the + sign to add a second geom layer with geom_point():\n\n## Simple line graph with points\nggplot(data = gap_US, \n       mapping = aes(x = year,\n                     y = lifeExp)) +\n  geom_line() +\n  geom_point()\n\n\n\n\nWe can create a more attractive plot by customizing the size and color of our geoms.\n\n## Line graph with points and fixed aesthetics\nggplot(data = gap_US, \n       mapping = aes(x = year,\n                     y = lifeExp)) +\n  geom_line(size = 1.5, \n            color = \"lightgrey\") +\n  geom_point(size = 3, \n             color = \"steelblue\")\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nBuilding on the code above, visualize the relationship between time and GPD per capita from the gap_US data frame.\nUse both points and lines to represent the data.\nChange the line type of the line and the color of the points to any valid values of your choice."
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#mapping-data-to-multiple-lines",
    "href": "data_on_display_ls03_line_graphs.html#mapping-data-to-multiple-lines",
    "title": "19  Lines, scales, and labels",
    "section": "19.7 Mapping data to multiple lines",
    "text": "19.7 Mapping data to multiple lines\nIn the previous section, we only looked at data from one country, but what if we want to plot data for multiple countries and compare?\nFirst let’s add two more countries to our data subset:\n\n## Create data subset for visualizing multiple categories\ngap_mini &lt;- filter(gapminder,\n                   country %in% c(\"United States\",\n                                  \"Australia\",\n                                  \"Germany\"))\ngap_mini\n\n# A tibble: 10 × 6\n   country   continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Australia Oceania    1952    69.1  8691212    10040.\n 2 Australia Oceania    1957    70.3  9712569    10950.\n 3 Australia Oceania    1962    70.9 10794968    12217.\n 4 Australia Oceania    1967    71.1 11872264    14526.\n 5 Australia Oceania    1972    71.9 13177000    16789.\n 6 Australia Oceania    1977    73.5 14074100    18334.\n 7 Australia Oceania    1982    74.7 15184200    19477.\n 8 Australia Oceania    1987    76.3 16257249    21889.\n 9 Australia Oceania    1992    77.6 17481977    23425.\n10 Australia Oceania    1997    78.8 18565243    26998.\n\n\nIf we simply enter it using the same code and change the data layer, the lines are not automatically separated by country:\n\n## Line graph with no grouping aesthetic\nggplot(data = gap_mini, \n       mapping = aes(y = lifeExp, \n                     x = year)) +\n  geom_line() +\n  geom_point()\n\n\n\n\nThis is not a very helpful plot for comparing trends between groups.\nTo tell ggplot() to map the data from each country separately, we can the group argument as an as aesthetic mapping:\n\n## Line graph with grouping by a categorical variable\nggplot(data = gap_mini, \n       mapping = aes(y = lifeExp,\n                     x = year, \n                     group = country)) +\n  geom_line() +\n  geom_point()\n\n\n\n\nNow that the data is grouped by country, we have 3 separate lines - one for each level of the country variable.\nWe can also apply fixed aesthetics to the geometric layers.\n\n## Applying fixed aesthetics to multiple lines\nggplot(data = gap_mini, \n       mapping = aes(y = lifeExp,\n                     x = year, \n                     group = country)) +\n  geom_line(linetype=\"longdash\",        # set line type\n            color=\"tomato\",             # set line color\n            size=1) +                   # set line size\n  geom_point(size = 2)                  # set point size\n\n\n\n\nIn the graphs above, line types, colors and sizes are the same for the three groups.\nThis doesn’t tell us which is which though. We should add an aesthetic mapping that can help us identify which line belongs to which country, like color or line type.\n\n## Map country to color\nggplot(data = gap_mini, \n       mapping = aes(y = lifeExp, x = year, \n                     group = country, \n                     color = country)) +\n  geom_line(size = 1) +\n  geom_point(size = 2)\n\n\n\n\nAesthetic mappings specified within ggplot() function call are passed down to subsequent layers.\nInstead of grouping by country, we can also group by continent:\n\n## Map continent to color, line type, and shape\nggplot(data = gap_mini, \n       mapping = aes(x = year,\n                     y = lifeExp,\n                     color = continent,\n                     lty = continent,\n                     shape = continent)) +\n  geom_line(size = 1) +\n  geom_point(size = 2)\n\n\n\n\nWhen given multiple mappings and geoms, {ggplot2} can discern which mappings apply to which geoms.\nHere color was inherited by both points and lines, but lty was ignored by geom_point() and shape was ignored by geom_line(), since they don’t apply.\n\n\n\n\n\n\nChallenge\n\n\n\nChallenge\nMappings can either go in the ggplot() function or in geom_*() layer.\nFor example, aesthetic mappings can go in geom_line() and will only be applied to that layer:\n\nggplot(data = gap_mini, \n       mapping = aes(x = year,\n                     y = lifeExp)) +\n  geom_line(size = 1, mapping = aes(color = continent)) + \n  geom_point(mapping = aes(shape = country, \n                                     size = pop))\n\n\n\n\nTry adding mapping = aes() in geom_point() and map continent to any valid aesthetic!\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUsing the gap_mini data frame, create a population growth chart with these aesthetic mappings:\n\n\n\n\n\nNext, add a layer of points to the previous plot, and add the required aesthetic mappings to produce a plot that looks like this:\n\n\n\n\n\nDon’t worry about any fixed aesthetics, just make sure the mapping of data variables is the same."
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#modifying-continuous-x-y-scales",
    "href": "data_on_display_ls03_line_graphs.html#modifying-continuous-x-y-scales",
    "title": "19  Lines, scales, and labels",
    "section": "19.8 Modifying continuous x & y scales",
    "text": "19.8 Modifying continuous x & y scales\n{ggplot2} automatically scales variables to an aesthetic mapping according to type of variable it’s given.\n\n## Automatic scaling for x, y, and color\nggplot(data = gap_mini,\n       mapping = aes(x = year,\n                     y = lifeExp,\n                     color = country)) +\n  geom_line(size = 1)\n\n\n\n\nIn some cases the we might want to transform the axis scaling for better visualization. We can customize these scales with the scale_*() family of functions.\n\nscale_x_continuous() and scale_y_continuous() are the default scale functions for continuous x and y aesthetics.\n\n\n19.8.1 Scale breaks\nLet’s create a new subset of countries from gapminder, and this time we will plot changes in GDP over time.\n\n## Data subset to include India, China, and Thailand\ngap_mini2 &lt;- filter(gapminder,\n                    country %in% c(\"India\",\n                                   \"China\",\n                                   \"Thailand\"))\ngap_mini2\n\n# A tibble: 10 × 6\n   country continent  year lifeExp        pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;\n 1 China   Asia       1952    44    556263527      400.\n 2 China   Asia       1957    50.5  637408000      576.\n 3 China   Asia       1962    44.5  665770000      488.\n 4 China   Asia       1967    58.4  754550000      613.\n 5 China   Asia       1972    63.1  862030000      677.\n 6 China   Asia       1977    64.0  943455000      741.\n 7 China   Asia       1982    65.5 1000281000      962.\n 8 China   Asia       1987    67.3 1084035000     1379.\n 9 China   Asia       1992    68.7 1164970000     1656.\n10 China   Asia       1997    70.4 1230075000     2289.\n\n\nHere we will change the y-axis mapping from lifeExp to gdpPercap:\n\nggplot(data = gap_mini2, \n       mapping = aes(x = year, \n                     y = gdpPercap, \n                     group = country, \n                     color = country)) +\n  geom_line(size = 0.75)\n\n\n\n\nThe x-axis labels for year in don’t match up with the dataset.\n\ngap_mini2$year %&gt;% unique()\n\n [1] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007\n\n\nWe can specify exactly where to label the axis by providing a numeric vector.\n\n## You can manually enter scale breaks (don't do this)\nc(1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, 2002, 2007)\n\n [1] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007\n\n## It's better to create the vector with seq()\nseq(from = 1952, to = 2007, by = 5)\n\n [1] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007\n\n\nUse scale_x_continuous to make the axis breaks match up with the dataset:\n\n## Customize x-axis breaks with `scale_x_continuous(breaks = VECTOR)`\nggplot(data = gap_mini2, \n       mapping = aes(x = year, \n                     y = gdpPercap, \n                     color = country)) +\n  geom_line(size = 1) +\n  scale_x_continuous(breaks = seq(from = 1952, to = 2007, by = 5)) +\n  geom_point()\n\n\n\n\nStore scale break values as an R object for easier reference:\n\n## Store numeric vector to a named object\ngap_years &lt;- seq(from = 1952, to = 2007, by = 5)\n\n\n## Replace seq() code with named vector\nggplot(data = gap_mini2, \n       mapping = aes(x = year, \n                     y = gdpPercap, \n                     color = country)) +\n  geom_line(size = 1) +\n  scale_x_continuous(breaks = gap_years)\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nWe can customize scale breaks on a continuous y-axis values with scale_y_continuous().\nCopy the code from the last example, and add scale_y_continuous() to add the following y-axis breaks:\n\n\n\n\n\n\n\n\n\n19.8.2 Logarithmic scaling\nIn the last two mini sets, I chose three countries that had similar range of GDP or life expectancy for good scaling and readability so that we can make out these changes.\nBut if we add a country to the group that significantly differs, default scaling is not so great.\nWe’ll look at an example plot where you may want to rescale the axes from linear to a log scale.\nLet’s add New Zealand to the previous set of countries and create gap_mini3:\n\n## Data subset to include India, China, Thailand, and New Zealand\ngap_mini3 &lt;- filter(gapminder,\n                    country %in% c(\"India\",\n                                   \"China\",\n                                   \"Thailand\",\n                                   \"New Zealand\"))\ngap_mini3\n\n# A tibble: 10 × 6\n   country continent  year lifeExp        pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;\n 1 China   Asia       1952    44    556263527      400.\n 2 China   Asia       1957    50.5  637408000      576.\n 3 China   Asia       1962    44.5  665770000      488.\n 4 China   Asia       1967    58.4  754550000      613.\n 5 China   Asia       1972    63.1  862030000      677.\n 6 China   Asia       1977    64.0  943455000      741.\n 7 China   Asia       1982    65.5 1000281000      962.\n 8 China   Asia       1987    67.3 1084035000     1379.\n 9 China   Asia       1992    68.7 1164970000     1656.\n10 China   Asia       1997    70.4 1230075000     2289.\n\n\nNow we will recreate the plot of GDP over time with the new data subset:\n\nggplot(data = gap_mini3, \n       mapping = aes(x = year, \n                     y = gdpPercap, \n                     color = country)) +\n  geom_line(size = 0.75) +\n  scale_x_continuous(breaks = gap_years)\n\n\n\n\nThe curves for India and China show an exponential increase in GDP per capita. However, the y-axes values for these two countries are much lower than that of New Zealand, so the lines are a bit squashed together. This makes the data hard to read. Additionally, the large empty area in the middle is not a great use of plot space.\nWe can address this by log-transforming the y-axis using scale_y_log10(), which log-scales the y -axis (as the name suggests). We will add this function as a new layer after a + sign, as usual:\n\n## Add scale_y_log10()\nggplot(data = gap_mini3, \n       mapping = aes(x = year, \n                     y = gdpPercap, \n                     color = country)) +\n  geom_line(size = 1) +\n  scale_x_continuous(breaks = gap_years) +\n  scale_y_log10()\n\n\n\n\nNow the y-axis values are rescaled, and the scale break labels tell us that it is nonlinear.\nWe can add a layer of points to make this clearer:\n\nggplot(data = gap_mini3, \n       mapping = aes(x = year, \n                     y = gdpPercap, \n                     color = country)) +\n  geom_line(size = 1) +\n  scale_x_continuous(breaks = gap_years) +\n  scale_y_log10() +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nFirst subset gapminder to only the rows containing data for Uganda:\nNow, use gap_Uganda to create a time series plot of population (pop) over time (year). Transform the y axis to a log scale, edit the scale breaks to gap_years, change the line color to forestgreen and the size to 1mm.\n\n\nNext, we can change the text of the axis labels to be more descriptive, as well as add titles, subtitles, and other informative text to the plot."
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#labeling-with-labs",
    "href": "data_on_display_ls03_line_graphs.html#labeling-with-labs",
    "title": "19  Lines, scales, and labels",
    "section": "19.9 Labeling with labs()",
    "text": "19.9 Labeling with labs()\nYou can add labels to a plot with the labs() function. Arguments we can specify with the labs() function include:\n\ntitle: Change or add a title\nsubtitle: Add subtitle below the title\nx: Rename x-axis\ny: Rename y-axis\ncaption: Add caption below the graph\n\nLet’s start with this plot and start adding labels to it:\n\n## Time series plot of life expectancy in the United States\nggplot(data = gap_US, \n       mapping = aes(x = year, \n                     y = lifeExp)) +\n  geom_line(size = 1.5, \n            color = \"lightgrey\") +\n  geom_point(size = 3, \n             color = \"steelblue\") +\n  scale_x_continuous(breaks = gap_years) \n\n\n\n\nWe add the labs() to our code using a + sign.\nFirst we will add the x and y arguments to labs(), and change the axis titles from the default (variable name) to something more informative.\n\n## Rename axis titles\nggplot(data = gap_US, \n       mapping = aes(x = year, \n                     y = lifeExp)) +\n  geom_line(size = 1.5, \n            color = \"lightgrey\") +\n  geom_point(size = 3, \n             color = \"steelblue\") +\n  scale_x_continuous(breaks = gap_years) +\n  labs(x = \"Year\",\n       y = \"Life Expectancy (years)\")\n\n\n\n\nNext we supply a character string to the title argument to add large text above the plot.\n\n## Add main title: \"Lifespan increases over time\"\nggplot(data = gap_US, \n       mapping = aes(x = year, \n                     y = lifeExp)) +\n  geom_line(size = 1.5, \n            color = \"lightgrey\") +\n  geom_point(size = 3, \n             color = \"steelblue\") +\n  scale_x_continuous(breaks = gap_years) +\n  labs(x = \"Year\",\n       y = \"Life Expectancy (years)\",\n       title = \"Lifespan increases over time\")\n\n\n\n\nThe subtitle argument adds smaller text below the main title.\n\n## Add subtitle with location and time frame\nggplot(data = gap_US, \n       mapping = aes(x = year, \n                     y = lifeExp)) +\n  geom_line(size = 1.5, \n            color = \"lightgrey\") +\n  geom_point(size = 3, \n             color = \"steelblue\") +\n  scale_x_continuous(breaks = gap_years) +\n  labs(x = \"Year\",\n       y = \"Life Expectancy (years)\",\n       title = \"Life expectancy changes over time\",\n       subtitle = \"United States (1952-2007)\")\n\n\n\n\nFinally, we can supply the caption argument to add small text to the bottom-right corner below the plot.\n\n## Add caption with data source: \"Source: www.gapminder.org/data\"\nggplot(data = gap_US, \n       mapping = aes(x = year, \n                     y = lifeExp)) +\n  geom_line(size = 1.5, \n            color = \"lightgrey\") +\n  geom_point(size = 3, \n             color = \"steelblue\") +\n  scale_x_continuous(breaks = gap_years) +\n  labs(x = \"Year\",\n       y = \"Life Expectancy (years)\",\n       title = \"Life expectancy changes over time\",\n       subtitle = \"United States (1952-2007)\", \n       caption = \"Source: http://www.gapminder.org/data/\")\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhen you use an aesthetic mapping (e.g., color, size), {ggplot2} automatically scales the given aesthetic to match the data and adds a legend.\nHere is an updated version of the gap_mini3 plot we made before. We are changing the of points and lines by setting aes(color = country) in ggplot(). Then the size of points is scaled to the pop variable. See that labs() is used to change the title, subtitle, and axis labels.\n\nggplot(data = gap_mini2, \n       mapping = aes(x = year, \n                     y = gdpPercap, \n                     color = country)) +\n  geom_line(size = 1) +\n  geom_point(mapping = aes(size = pop),\n                           alpha = 0.5) +\n  geom_point() +\n  scale_x_continuous(breaks = gap_years) +\n  scale_y_log10()  +\n  labs(x = \"Year\", \n       y = \"Income per person\",\n       title = \"GDP per capita in selected Asian economies, 1952-2007\",\n       subtitle = \"Income is measured in US dollars and is adjusted for inflation.\")\n\n\n\n\nThe default title of a legend or key is the name of the data variable it corresponds to. Here the color lengend is titled country, and the size legend is titled pop.\nWe can also edit these in labs() by setting AES_NAME = \"CUSTOM_TITLE\".\n\nggplot(data = gap_mini2, \n       mapping = aes(x = year, \n                     y = gdpPercap, \n                     color = country)) +\n  geom_line(size = 1) +\n  geom_point(mapping = aes(size = pop),\n                           alpha = 0.5) +\n  geom_point() +\n  scale_x_continuous(breaks = gap_years) +\n  scale_y_log10()  +\n  labs(x = \"Year\", \n       y = \"Income per person\",\n       title = \"GDP per capita in selected Asian economies, 1952-2007\",\n       subtitle = \"Income is measured in US dollars and is adjusted for inflation.\",\n       color = \"Country\",\n       size = \"Population\")\n\n\n\n\nThe same syntax can be used to edit legend titles for other aesthetic mappings. A common mistake is to use the variable name instead of the aesthetic name in labs(), so watch out for that!\n\n\n\n\n\n\n\n\nPractice\n\n\n\nCreate a time series plot comparing the trends in life expectancy from 1952-2007 for three countries in the gapminder data frame.\nFirst, subset the data to three countries of your choice:\nUse my_gap_mini to create a plot with the following attributes:\n\nAdd points to the line graph\nColor the lines and points by country\nIncrease the width of lines to 1mm and the size of points to 2mm\nMake the lines 50% transparent\nChange the x-axis scale breaks to match years in dataset\n\nFinally, add the following labels to your plot:\n\nTitle: “Health & wealth of nations”\nAxis titles: “Longevity” and “Year”\nCapitalize legend title\n\n(Note: subtitle requirement has been removed.)"
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#preview-themes",
    "href": "data_on_display_ls03_line_graphs.html#preview-themes",
    "title": "19  Lines, scales, and labels",
    "section": "19.10 Preview: Themes",
    "text": "19.10 Preview: Themes\nIn the next lesson, you will learn how to use theme functions.\n\n## Use theme_minimal()\nggplot(data = gap_mini2, \n       mapping = aes(x = year, \n                     y = gdpPercap, \n                     color = country)) +\n  geom_line(size = 1, alpha = 0.5) +\n  geom_point(size = 2) +\n  scale_x_continuous(breaks = gap_years) +\n  scale_y_log10() +\n  labs(x = \"Year\", \n       y = \"Income per person\",\n       title = \"GDP per capita in selected Asian economies, 1952-2007\",\n       subtitle = \"Income is measured in US dollars and is adjusted for inflation.\",\n       caption = \"Source: www.gapminder.org/data\") +\n  theme_minimal()"
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#wrap-up",
    "href": "data_on_display_ls03_line_graphs.html#wrap-up",
    "title": "19  Lines, scales, and labels",
    "section": "19.11 Wrap up",
    "text": "19.11 Wrap up\nLine graphs, just like scatterplots, display the relationship between two numerical variables. When one of the two variables represents time, a line graph can be a more effective method of displaying relationship. Therefore, it is preferred to use line graphs over scatterplots when the variable on the x-axis (i.e., the explanatory variable) has an inherent ordering, such as some notion of time, like the year variable of gapminder.\nWe can change scale breaks and transform scales to make plots easier to read, and label them to add more information.\nHope you found this lesson helpful!"
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#references",
    "href": "data_on_display_ls03_line_graphs.html#references",
    "title": "19  Lines, scales, and labels",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nIsmay, Chester, and Albert Y. Kim. 2022. A ModernDive into R and the Tidyverse. https://moderndive.com/.\nKabacoff, Rob. 2020. Data Visualization with R. https://rkabacoff.github.io/datavis/.\nhttps://www.rebeccabarter.com/blog/2017-11-17-ggplot2_tutorial/"
  },
  {
    "objectID": "data_on_display_ls03_line_graphs.html#solutions",
    "href": "data_on_display_ls03_line_graphs.html#solutions",
    "title": "19  Lines, scales, and labels",
    "section": "19.12 Solutions",
    "text": "19.12 Solutions\n\n.SOLUTION_q1()\n\nggplot(gap_US, \n          mapping = aes(x = year, \n                        y = gdpPercap)) +\n      geom_line()\n\n.SOLUTION_q2()\n\nggplot(gap_US, \n          mapping = aes(x = year, \n                           y = gdpPercap)) +\n      geom_line(lty = \"dotdash\") +\n      geom_point(color = \"aquamarine\")\n\n.SOLUTION_q3()\n\nggplot(gap_mini,\n             aes(x = year,\n                 y = pop,\n                 color = country,\n                 linetype = country)) +\n      geom_line()\n\n.SOLUTION_q4()\n\nggplot(gap_mini,\n             aes(x = year,\n                 y = pop,\n                 color = country,\n                 shape = continent,\n                 lty = country)) +\n      geom_line() +\n      geom_point()\n\n.SOLUTION_q5()\n\nggplot(data = gap_mini2, \n       mapping = aes(x = year, \n                     y = gdpPercap, \n                     color = country)) +\n  geom_line(linewidth = 1) +\n  scale_x_continuous(breaks = gap_years) +\n  scale_y_continuous(breaks = seq(from = 1000, to = 7000, by = 1000))\n\n.SOLUTION_q6()\n\nggplot(data = gap_Uganda, mapping = aes(x = year, y = pop)) + \n      geom_line(linewidth = 1, color = \"forestgreen\")+\n      scale_x_continuous(breaks = gap_years) +\n      scale_y_log10()\n\n.SOLUTION_q7()\n\nggplot(data = my_gap_mini, \n       mapping = aes(y = lifeExp, \n                     x = year, \n                     color = country)) +\n  geom_line(linewidth = 1, alpha = 0.5) +\n  geom_point(size = 2) +\n  scale_x_continuous(breaks = gap_years)\n\n.SOLUTION_q8()\n\nggplot(data = my_gap_mini, \n       mapping = aes(y = lifeExp, \n                     x = year, \n                     color = country)) +\n  geom_line(linewidth = 1, alpha = 0.5) +\n  geom_point(size = 2) +\n  scale_x_continuous(breaks = gap_years) +\n  labs(x = \"Year\", \n       y = \"Longevity\",\n       title = \"Health & wealth of nations\",\n       color = \"Color\")\n\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  },
  {
    "objectID": "data_on_display_ls04_histograms.html#histograms-with-ggplot2",
    "href": "data_on_display_ls04_histograms.html#histograms-with-ggplot2",
    "title": "20  Histograms with {ggplot2}",
    "section": "20.1 Histograms with {ggplot2}",
    "text": "20.1 Histograms with {ggplot2}"
  },
  {
    "objectID": "data_on_display_ls04_histograms.html#learning-objectives",
    "href": "data_on_display_ls04_histograms.html#learning-objectives",
    "title": "20  Histograms with {ggplot2}",
    "section": "20.2 Learning Objectives",
    "text": "20.2 Learning Objectives\nBy the end of this lesson, you will be able to:\n\nPlot a histogram to visualize the distribution of continuous variables using geom_histogram().\nAdjust the number or size of bins on a histogram by with the bins or binwidth arguments.\nShift and align bins on a histogram with the boundary argument.\nSet bin boundaries to a sequence of values with the breaks argument."
  },
  {
    "objectID": "data_on_display_ls04_histograms.html#introduction",
    "href": "data_on_display_ls04_histograms.html#introduction",
    "title": "20  Histograms with {ggplot2}",
    "section": "20.3 Introduction",
    "text": "20.3 Introduction\nA histogram is a plot that visualizes the distribution of a numerical value as follows:\n\nWe first cut up the x-axis into a series of bins, where each bin represents a range of values.\nFor each bin, we count the number of observations that fall in the range corresponding to that bin.\nThen for each bin, we draw a bar whose height marks the corresponding count."
  },
  {
    "objectID": "data_on_display_ls04_histograms.html#packages",
    "href": "data_on_display_ls04_histograms.html#packages",
    "title": "20  Histograms with {ggplot2}",
    "section": "20.4 Packages",
    "text": "20.4 Packages\n\npacman::p_load(tidyverse,\n               here)"
  },
  {
    "objectID": "data_on_display_ls04_histograms.html#childhood-diarrheal-diseases-in-mali",
    "href": "data_on_display_ls04_histograms.html#childhood-diarrheal-diseases-in-mali",
    "title": "20  Histograms with {ggplot2}",
    "section": "20.5 Childhood diarrheal diseases in Mali",
    "text": "20.5 Childhood diarrheal diseases in Mali\nWe will visualize distributions of numerical variables in the malidd data frame, which we’ve seen in previous lessons.\n\n## Import data from CSV\nmalidd &lt;- read_csv(here::here(\"data/clean/malidd.csv\"))\n\n\n\n\n\n\n\nRecap\n\n\n\nThese data were collected as part of an observational study of acute diarrhea in children aged 0-59 months. The study was conducted in Mali and in early 2020. The dataset records demographic and clinical information for 150 patients.\n\n\n\n## View first few rows of the data frame\nhead(malidd)\n\n\n\n\n\n\nThe dataframe has 21 variables, many of which are continuous, like height_cm, viral_load, and freqrespi."
  },
  {
    "objectID": "data_on_display_ls04_histograms.html#basic-histograms-with-geom_histogram",
    "href": "data_on_display_ls04_histograms.html#basic-histograms-with-geom_histogram",
    "title": "20  Histograms with {ggplot2}",
    "section": "20.6 Basic histograms with geom_histogram()",
    "text": "20.6 Basic histograms with geom_histogram()\nNow let’s use {ggplot2} to plot the distribution of childrens’ heights, which is recorded in the heigh_cm column of malidd.\nThe geom_*() function used for histograms is geom_histogram()\n\n## Simple histogram showing the distribution of height_cm\nggplot(data = malidd, \n       mapping = aes(x = height_cm)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\nSide Note\n\n\n\nIf we don’t adjust the bins in geom_histogram(), we get a warning message. You can ignore this warning message for now, and will learn how to customize bins in the next section.\n\n\nIn the previous histogram, it’s hard to where the boundaries for each bin start and end since everything is one big amorphous blob. So let’s add borders around the bins:\n\n## Set border color to \"white\"\nggplot(data =  malidd , \n       mapping = aes(x = height_cm)) +\n  geom_histogram(color = \"white\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nWe now have an easier time associating ranges of cases to each of the bins.\nWe can also vary the color of the bars by setting the fill argument:\n\n## Set fill color to \"steelblue\"\nggplot(data =  malidd , \n       mapping = aes(x = height_cm)) +\n  geom_histogram(color = \"white\", \n                 fill = \"steelblue\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nNow that we can see the bars more clearly, let’s unpack the resulting histogram. Some questions we might want to answer are:\n\nWhat are the smallest and largest values?\nWhat is the “center” or “most typical” value?\nHow do the values spread out?\nWhat are frequent and infrequent values?\n\nWe can see that heights range from 50 to 105cm. The center is around 70cm, most patients fall in the 60-80cm range, with very few below 55cm or above 90cm. Observe that the histogram has a bell shape, meaning that the variable has a normal distribution (more or less).\n\n\n\n\n\n\nPractice\n\n\n\n\nPlot a histogram showing the distribution of age (age_months) in malidd. Make the borders and fill of the bars “seagreen”, and reduce opacity to 40%.\nBuilding on your code for the previous plot, modify the axis titles to “Age (months)” and “Number of children”, respectively."
  },
  {
    "objectID": "data_on_display_ls04_histograms.html#adjusting-bins-in-a-histogram",
    "href": "data_on_display_ls04_histograms.html#adjusting-bins-in-a-histogram",
    "title": "20  Histograms with {ggplot2}",
    "section": "20.7 Adjusting bins in a histogram",
    "text": "20.7 Adjusting bins in a histogram\n\n\n\nHistograms plotting the same variable with different bin settings.\n\n\nAfter running code in previous examples, we got a histogram as well as a warning message about bins and bin width. The warning message is telling us that the histogram was constructed using bins = 30 for 30 equally spaced bins.\n\n## Warning message tells us to change the default of 30 bins\nggplot(data =  malidd , \n       mapping = aes(x = height_cm)) +\n  geom_histogram(color = \"white\", \n                 fill = \"steelblue\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nUnless you override this default number of bins with a number you specify, R will keep giving this message.\nWe can change the number of bins to another value using one of these three arguments to geom_histogram():\n\nSet the number of bins with bins\nSet the width of the bins with binwidth\nSet bin boundaries breaks\n\n\n20.7.1 Set the number of bins with bins\nUsing the first method, we have the power to specify how many bins we would like to cut the x-axis up in by setting bins = INTEGER:\n\n## Try different numbers of bins\n\nggplot(data =  malidd , \n       mapping = aes(x = height_cm)) +\n  geom_histogram(bins = 5, \n                 color = \"white\", \n                 fill = \"steelblue\")\n\n\n\nggplot(data =  malidd , \n       mapping = aes(x = height_cm)) +\n  geom_histogram(bins = 20, \n                 color = \"white\", \n                 fill = \"steelblue\")\n\n\n\nggplot(data =  malidd , \n       mapping = aes(x = height_cm)) +\n  geom_histogram(bins = 50, \n                 color = \"white\", \n                 fill = \"steelblue\")\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nMake a histogram of frequency of respiration (freqrespi), which is measured in breaths per minute. Set the interior color to “indianred3”, and border color to “lightgray”.\nNotice that with the default of 30 bins, there are some intervals for which no bar is plotted (i.e., there were no observations in that range).\nLow the number of bins until there are no empty intervals. You should choose the highest value of bins for which there are no empty spaces.\n\n\n\n\n20.7.2 Set the width of bins with binwidth\nUsing the second method, instead of specifying the number of bins, we specify the width of the bins by using the binwidth argument in geom_histogram().\n\n## Try different bin widths\nggplot(data =  malidd, \n       mapping = aes(x = height_cm)) +\n  geom_histogram(color = \"white\", \n                 fill = \"steelblue\",\n                 binwidth = 3)\n\n\n\n\nLooking at the range of the variable can help us choose an appropriate bin width.\n\nrange(malidd$height_cm)\n\n[1]  50.3 103.4\n\n\n\nggplot(data =  malidd, \n       mapping = aes(x = height_cm)) +\n  geom_histogram(color = \"white\", \n                 fill = \"steelblue\", \n                 binwidth = 5)\n\n\n\n\nWe can use the boundary argument to align the bins to the x-axis intervals.\n\n## Set `boundary` equal to the low end of the variable\nggplot(data =  malidd, \n       mapping = aes(x = height_cm)) +\n  geom_histogram(color = \"white\", \n                 fill = \"steelblue\", \n                 binwidth = 5,\n                 boundary = 50)\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nCreate the same freqrespi histogram from the last practice question, but this time set the bin width to to a value that results in 18 bins. Then align the bars to the x axis breaks by adjusting the bin boundaries.\n\n\n\n\n20.7.3 Modify bin boundaries with breaks\nSet breaks equal to a numeric vector in geom_histogram():\n\n## Supply a vector that covers the range of values in height_cm\nggplot(data =  malidd, \n       mapping = aes(x = height_cm)) +\n  geom_histogram(color = \"white\", \n                 fill = \"steelblue\",\n                 breaks = seq(50, 105, 5))\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nPlot the freqrespi histogram with bin breaks that range from the lowest value of freqrespi to the highest, with intervals of 4.\nNext, adjust the x-axis scale breaks by adding a scale_*() function. Set the range to 24-60, with an intervals of 8."
  },
  {
    "objectID": "data_on_display_ls04_histograms.html#summary",
    "href": "data_on_display_ls04_histograms.html#summary",
    "title": "20  Histograms with {ggplot2}",
    "section": "20.8 Summary",
    "text": "20.8 Summary\nHistograms, unlike scatterplots and linegraphs, present information on only a single numerical variable. Specifically, they are visualizations of the distribution of the numerical variable in question."
  },
  {
    "objectID": "data_on_display_ls04_histograms.html#references",
    "href": "data_on_display_ls04_histograms.html#references",
    "title": "20  Histograms with {ggplot2}",
    "section": "References",
    "text": "References\nSome material in this lesson was adapted from the following sources:\n\nIsmay, Chester, and Albert Y. Kim. 2022. A ModernDive into R and the Tidyverse. https://moderndive.com/.\nChang, Winston. 2013. R Graphics Cookbook: Practical Recipes for Visualizing Data. 1st edition. Beijing Köln: O’Reilly Media."
  },
  {
    "objectID": "data_on_display_ls04_histograms.html#solutions",
    "href": "data_on_display_ls04_histograms.html#solutions",
    "title": "20  Histograms with {ggplot2}",
    "section": "20.9 Solutions",
    "text": "20.9 Solutions\n\n.SOLUTION_q1()\n\nggplot(data = malidd, \n         mapping = aes(x = age_months)) +\n    geom_histogram(fill = \"seagreen\",\n                   color = \"seagreen\",\n                   alpha = 0.4)`\n\n.SOLUTION_q2()\n\nggplot(data = .malidd, \n             mapping = aes(x = age_months)) +\n      geom_histogram(fill = \"seagreen\",\n                     color = \"seagreen\",\n                     alpha = 0.4) +\n      labs(x = \"Age (months)\",\n           y = \"Number of children\")\n\n.SOLUTION_q3() \n\nggplot(data = malidd, \n       mapping = aes(x = freqrespi)) +\n    geom_histogram(fill = \"indianred3\",\n                   color = \"lightgray\",\n                   bins = 20)\n\n.SOLUTION_q4()\n\nggplot(data = malidd, \n       mapping = aes(x = freqrespi)) +\n    geom_histogram(binwidth = 2,\n                   fill = \"indianred3\",\n                   color = \"lightgray\",\n                   boundary = 24)\n\n.SOLUTION_q5()\n\nggplot(data = malidd, \n       mapping = aes(x = freqrespi)) +\n    geom_histogram(fill = \"indianred3\",\n                   color = \"lightgray\", \n                   binwidth = 4) +\n  scale_x_continuous(breaks = seq(24, 60, 8))\n\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  },
  {
    "objectID": "data_on_display_ls05_boxplots.html#boxplots-with-ggplot2",
    "href": "data_on_display_ls05_boxplots.html#boxplots-with-ggplot2",
    "title": "21  Boxplots with {ggplot2}",
    "section": "21.1 Boxplots with {ggplot2}",
    "text": "21.1 Boxplots with {ggplot2}\n\n21.1.1 Learning Objectives\nBy the end of this lesson, you will be able to:\n\nPlot a boxplot to visualize the distribution of continuous data using geom_boxplot().\nReorder side-by-side boxplots with the reorder() function.\nAdd a layer of data points on a bloxplot using geom_jitter().\n\n\n\n21.1.2 Introduction\n\n21.1.2.1 Anatomy of a boxplot\nA boxplot allows us to visualize the distribution of numeric variables.\n\nIt consists of two parts:\n\nBox — Extends from the first to the third quartile (Q1 to Q3) with a line in the middle that represents the median. The range of values between Q1 and Q3 is also known as an Interquartile range (IQR).\nWhiskers — Lines extending from both ends of the box indicate variability outside Q1 and Q3. The minimum/maximum whisker values are calculated as \\(Q1 - 1.5 \\times IQR\\) to \\(Q3 + 1.5 \\times IQR\\) . Everything outside is represented as an outlier using dots or other markers.\n\nThis is side-by-side boxplot. It lets us compare the distribution of a numerical variable split by the values of another variable.\n\nHere we are looking at the variation in GDP per capita – which is a continuous variable – split by different world regions – a categorical variable.\n\n\n21.1.2.2 Potential pitfalls\nBoxplots summarize the data into five numbers, so we might miss important characteristics of the data.\nIf the amount of data you are working with is not too large, adding individual data points can make the graphic more insightful.\n\n\n\n\n\n\n\n\n21.1.3 Load packages\n\npacman::p_load(tidyverse,\n               gapminder,\n               here)\n\n\n\n21.1.4 The gapminder dataset\nFor this lesson, we will be visualizing global health and economic data from the gapminder data frame, which we’ve encountered in previous lessons.\n\n## View first few rows of the data\nhead(gapminder)\n\n\n\n\n\n\n\n\n\n\n\n\nRecap\n\n\n\nGapminder is a country-year dataset with information on 142 countries, divided in to 5 “continents” or world regions.\n\n## Data summary\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Asia    :396   Median :1980   Median :60.71  \n Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.47  \n Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\n\nData are recorded every 5 years from 1952 to 2007 (a total of 12 years).\n\n\n\n\n21.1.5 Basic boxplots with geom_boxplot()\nThe function for creating boxplots in {ggplot2} is geom_boxplot().\n\nWe’re going to make a base boxplot and then then add more aesthetics and layers.\nLet’s start with a simple boxplot by mapping one numeric variable from gapminder, life expectancy (lifeExp) to the x position.\n\n## Simple boxplot of lifeExp\nggplot(data = gapminder,\n       mapping = aes(x = lifeExp)) +\n  geom_boxplot()\n\n\n\n\nTo create a side-by-side boxplot (which is what we usually want), we need to add a categorical variable to the y position aesthetic.\nLet’s compare life expectancy distributions between continents - i.e., split lifeExp by the continent variable.\n\n## Side-by-side boxplot of lifeExp by continent\nggplot(gapminder, \n       aes(x = lifeExp, \n           y = continent)) +\n  geom_boxplot()\n\n\n\n\nThe result is a basic boxplot of lifeExp for multiple continents.\n\n## Side-by-side boxplot of lifeExp by continent (vertical)\nggplot(data = gapminder,\n       mapping = aes(x = continent,\n                     y = lifeExp)) +\n  geom_boxplot()\n\n\n\n\nLet us color in the boxes. We can map the continent variable to fill so that each box is colored according to which continent it represents.\n\n## Fill each continent with a different color\nggplot(gapminder, \n       aes(x = continent,\n           y = lifeExp, \n           fill = continent)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\nReminder\n\n\n\n{ggplot2} allows you to color by specifying a variable. We can use fill argument inside the aes() function to specify which variable is mapped to fill color.\n\n\nWe can also add the color and alpha aesthetics to change outline color and transparency.\n\n## Change outline color and increase transparency\nggplot(gapminder, \n       aes(x = continent,\n           y = lifeExp, \n           fill = continent,\n           color = continent)) +\n  geom_boxplot(alpha = 0.6)\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nUsing the gapminder data frame create a boxplot comparing the distribution of GDP per capita (gdpPercap) across continents. Map the fill color of the boxes to continent, and set the line width to 1.\nBuilding on your code from the last question, add a scale_*() function that transforms the y-axis to a logarithmic scale.\n\n\n\n\n\n21.1.6 Reordering boxes with reorder()\n\n\n\nReorder boxplots by life expectancy instead of alphabetical order.\n\n\nThe values of the continent variable are ordered alphabetically by default. If you look at the x-axis, it starts with Africa and goes alphabetically to Oceania.\nIt might be more useful to order them according to life expectancy, the y-axis variable.\nWe can change the levels of a factor in R using the reorder() function. If we reorder the levels of the continent variable, the boxplots will be plotted on the x-axis in that order.\nreorder() treats its first argument as a categorical variable , and reorders its levels based on the values of a second numeric variable.\nTo reorder the levels of the continent variable based on lifeExp, we will use the syntax reorder(CATEGORIAL_VAR, NUMERIC_VAR). Like this: reorder(continent, lifeExp).\nHere we will edit the x argument and tell ggplot() to reorder the variable.\n\nggplot(gapminder, \n       aes(x = reorder(continent, lifeExp),\n           y = lifeExp, \n           fill = continent,\n           color = continent)) +\n  geom_boxplot(alpha = 0.6)\n\n\n\n\nWe can clearly see that there are notable differences in median life expectancy between continents. However, there is a lot of overlap between the range of values from each continent. For example, the median life expectancy for the continent of Africa is lower than that of Europe, but several African countries have life expectancy values higher than than the majority of European countries.\n\n21.1.6.1 Reordering by function\nThe default method reorders factor based on the mean of the numeric variable.\nWe can add a third argument to choose a different method, like the median or maximum.\n\n## Arrange boxplots by median life expectancy\nggplot(gapminder, \n       aes(x = reorder(continent, lifeExp, median),\n           y = lifeExp, \n           fill = continent,\n           color = continent)) +\n  geom_boxplot(alpha = 0.6)\n\n\n\n## Arrange boxplots by max life expectancy\nggplot(gapminder, \n       aes(x = reorder(continent, lifeExp, max),\n           y = lifeExp, \n           fill = continent,\n           color = continent)) +\n  geom_boxplot(alpha = 0.6)\n\n\n\n\nThe boxplots are arranged in increasing order.\nTo sort boxes in boxplot in descending order, we add negation to lifeExp within the reorder() function.\n\n## Arrange boxplots by descending median life expectancy\nggplot(gapminder, \n       aes(x = reorder(continent, -lifeExp, median),\n           y = lifeExp, \n           fill = continent,\n           color = continent)) +\n  geom_boxplot(alpha = 0.6)\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nCreate the boxplot showing the distribution of GDP per capita for each continent, like you did in practice question 2. Retain the fill, line width, and scale from that plot.\nNow, reorder the boxes by mean gdpPercap, in descending order.\nBuilding on the code from the previous question, add labels to your plot.\n\nSet the main title to “Variation in GDP per capita across continents (1952-2007)”\nChange the x-axis title to “Continent”, and\nChange the y-axis title to “Income per person (USD)”.\n\n\n\n\n\n\n21.1.7 Adding data points with geom_jitter()\nBoxplots give us a very high-level summary of the distribution of a numeric variable for several groups. The problem is that summarizing also means losing information.\nIf we consider our lifeExp boxplot, it is easy to conclude that Oceania has a higher value than the others. However, we cannot see the underlying distribution of data points in each group or their number of observations.\n\n## Basic lifeExp boxplot from earlier\nggplot(gapminder, \n       aes(x = reorder(continent, lifeExp),\n           y = lifeExp, \n           fill = continent,\n           color = continent)) +\n  geom_boxplot(alpha = 0.6)\n\n\n\n\nLet’s see what happens when the boxplot is improved using additional elements.\nOne way to display the distribution of individual data points is to plot an additional layer of points on top of the boxplot.\nWe could do this by simply adding the geom_point() function.\n\nggplot(gapminder, \n       aes(x = reorder(continent, lifeExp), \n           y = lifeExp,\n           fill = continent)) +\n      geom_boxplot()+\n      geom_point()\n\n\n\n\nHowever, geom_point() as has plotted all the data points on a vertical line. That’s not very useful since all the points with same life expectancy value directly overlap and are plotted on top of each other.\nOne solution for this is to randomly “jitter” data points horizontally. ggplot allows you to do that with the geom_jitter() function.\n\nggplot(gapminder, \n       aes(x = reorder(continent, lifeExp), \n           y = lifeExp,\n           fill = continent)) +\n  geom_boxplot() +\n  geom_jitter()\n\n\n\n\nYou can also control the amount of jittering with width argument and specify opacity of points with alpha.\n\nggplot(gapminder, \n       aes(x = reorder(continent, lifeExp), \n           y = lifeExp,\n           fill = continent)) +\n  geom_boxplot() +\n  geom_jitter(width = 0.25, \n              alpha = 0.5)\n\n\n\n\nHere some new patterns appear clearly. Oceania has a small sample size compared to the other groups. This is definitely something you want to find out before saying that Oceania has higher life expectancy than the others.\n\n\n\n\n\n\nRecap\n\n\n\nBoxplots have the limitation that they summarize the data into five numbers: the 1st quartile, the median (the 2nd quartile), the 3rd quartile, and the upper and lower whiskers. By doing this, we might miss important characteristics of the data. One way to avoid this is by showing the data with points.\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nCreate the boxplot showing the distribution of GDP per capita for each continent, like you did in practice question 3. Then add a layer of jittered points.\nAdapt your answer to question 4 to make the points 45% transparent and change the width of the jitter to 0.3mm.\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nAdding mean markers to a boxplot\nYou may want to visualize the mean (average) value of the distributions on a boxplot.\nWe can do this by adding a statistics layer using the stat_summary() function.\n\n## Add a marker to show the mean\nggplot(gapminder, \n       aes(x = reorder(continent, lifeExp), \n           y = lifeExp, \n           fill = continent,\n           color = continent)) +\n  geom_boxplot(alpha = 0.6) +\n  stat_summary(fun = \"mean\",\n               geom = \"point\",\n               size = 3,\n               shape = 23,\n               fill = \"white\")\n\n\n\n\n\n\n\n\n21.1.8 Wrap up\nSide-by-side boxplots provide us with a way to compare the distribution of a continuous variable across multiple values of another variable. One can see where the median falls across the different groups by comparing the solid lines in the center of the boxes.\nTo study the spread of a continuous variable within one of the boxes, look at both the length of the box and also how far the whiskers extend from either end of the box. Outliers are even more easily identified when looking at a boxplot than when looking at a histogram as they are marked with distinct points.\n\n\n21.1.9 Learning Outcomes\n\nYou can plot a boxplot to visualize the distribution of continuous data using geom_boxplot().\nYou can reorder side-by-side boxplots with the reorder() function.\nYou can add a layer of individual data points on a bloxplot using geom_jitter().\n\n\n\nReferences\nSome material in this lesson was adapted from the following sources:\n\nIsmay, Chester, and Albert Y. Kim. 2022. A ModernDive into R and the Tidyverse. https://moderndive.com/."
  },
  {
    "objectID": "data_on_display_ls05_boxplots.html#solutions",
    "href": "data_on_display_ls05_boxplots.html#solutions",
    "title": "21  Boxplots with {ggplot2}",
    "section": "21.2 Solutions",
    "text": "21.2 Solutions\n\n.SOLUTION_q1()\n\nggplot(data = gapminder,\n  mapping = aes(x = continent, y = gdpPercap, fill = continent)) +\n  geom_boxplot(linewidth = 1)\n\n.SOLUTION_q2()\n\nggplot(data = gapminder,\n  mapping = aes(x = continent, y = gdpPercap, fill = continent)) +\n  geom_boxplot(linewidth = 1) +\n  scale_y_log10()\n\n.SOLUTION_q3() \n\nggplot(data = gapminder,\n  mapping = aes(\n  x = reorder(continent, -gdpPercap), \n  y = gdpPercap, \n  fill = continent)) +\n  geom_boxplot(linewidth = 1) +\n  scale_y_log10()\n\n.SOLUTION_q4()\n\nggplot(data = gapminder,\n  mapping = aes(\n  x = reorder(continent, -gdpPercap), \n  y = gdpPercap, \n  fill = continent)) +\n  geom_boxplot(linewidth = 1) +\n  scale_y_log10() +\n  labs(title = \"Variation in GDP per capita across continents (1952-2007)\",\n    x = \"Continent\",\n    y = \"Income per person (USD)\")\n\n.SOLUTION_q5()\n\nggplot(data = gapminder,\n  mapping = aes(\n  x = reorder(continent, -gdpPercap), \n  y = gdpPercap, \n  fill = continent)) +\n  geom_boxplot(linewidth = 1) +\n  scale_y_log10() +\n  labs(title = \"Variation in GDP per capita across continents (1952-2007)\",\n    x = \"Continent\",\n    y = \"Income per person (USD)\") + \n  geom_jitter()\n\n.SOLUTION_q6()\n\nggplot(data = gapminder,\n  mapping = aes(\n  x = reorder(continent, -gdpPercap), \n  y = gdpPercap, \n  fill = continent)) +\n  geom_boxplot(linewidth = 1) +\n  scale_y_log10() +\n  labs(title = \"Variation in GDP per capita across continents (1952-2007)\",\n    x = \"Continent\",\n    y = \"Income per person (USD)\") + \n  geom_jitter(width = 0.3, alpha = 0.55)\n\n\nThis work is licensed under the  Creative Commons Attribution Share Alike license."
  }
]